'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 4 October 2004 at 8:32 pm'!Object subclass: #ScriptEvent	instanceVariableNames: 'priorEvent sender selector arguments '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptEvent subclass: #ScriptChangeEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptEvent class	instanceVariableNames: ''!ScriptChangeEvent class	instanceVariableNames: ''!Object subclass: #ScriptEventBuffer	instanceVariableNames: 'firstEvent lastEvent size bufferSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptEventBuffer class	instanceVariableNames: ''!Object subclass: #ScriptEventObserver	instanceVariableNames: 'flags semaphore buffer nextHandler suspended signaler selector '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptEventObserver class	instanceVariableNames: ''!Object subclass: #ScriptEventTraceEntry	instanceVariableNames: 'event message script parent '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptEventTraceEntry class	instanceVariableNames: ''!Object subclass: #ScriptEventTracer	instanceVariableNames: 'traceLog traceEvent traceTarget traceDonePosition '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptEventTracer class	instanceVariableNames: ''!Link weakSubclass: #ScriptHandlerLink	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptHandlerLink class	instanceVariableNames: ''!MessageSend subclass: #ScriptMessageSend	instanceVariableNames: 'eventSpec extraArgs paused '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptMessageSend subclass: #AsyncScriptMessageSend	instanceVariableNames: 'myProcess myQueue myScheduler myTrigger myScripts '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptMessageSend class	instanceVariableNames: ''!AsyncScriptMessageSend class	instanceVariableNames: ''!Process subclass: #ScriptProcess	instanceVariableNames: 'owner message result flags properties scheduler myEventMap myLink myTriggerBlock myHandler '	classVariableNames: 'FlagScriptDone FlagScriptSignalResume FlagScriptSignalWait FlagScriptStarted FlagScriptStopRequest FlagScriptTraceEvents '	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptProcess class	instanceVariableNames: ''!Object subclass: #ScriptProcessLink	instanceVariableNames: 'prevLink nextLink '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptProcessLink class	instanceVariableNames: ''!ScriptProcessLink weakSubclass: #ScriptProcessLinkStrong	instanceVariableNames: 'process '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptProcessLinkStrong class	instanceVariableNames: ''!ScriptProcessLink weakSubclass: #ScriptProcessLinkWeak	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptProcessLinkWeak class	instanceVariableNames: ''!Object subclass: #ScriptScheduler	instanceVariableNames: 'activeList scheduledList tickList activeScript interruptProtect myEventMap pending myTickEvent tickTime syncList '	classVariableNames: 'ActiveScheduler ActiveSchedulerProcess Debug '	poolDictionaries: ''	category: 'Scripting-Kernel'!ScriptScheduler class	instanceVariableNames: ''!ScriptMessageSend subclass: #TickMessageSend	instanceVariableNames: 'frequency myProcess myTrigger '	classVariableNames: ''	poolDictionaries: ''	category: 'Scripting-Kernel'!TickMessageSend class	instanceVariableNames: ''!!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 12:08'!asAsyncScriptMessageIn: scriptPerformer arguments: args	^self error: 'Invalid script descriptor: ', self printString! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/24/2001 21:20'!asScriptMessageIn: scriptPerformer arguments: args	^self error: 'Invalid script descriptor: ', self printString! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/14/2003 04:36'!asTickMessageIn: scriptPerformer arguments: args	^self error: 'Invalid script descriptor: ', self printString! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 2/18/2002 00:21'!catchAnyOf: eventSpec during: aBlock	^self catchAnyOf: eventSpec during: aBlock queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:35'!catchAnyOf: eventSpec during: aBlock queueSize: queueSize	"Catch any of the events in eventSpec during the evaluation of aBlock.	DETAILS: All of the events triggered will be passed into the shared queue. If there are multiple events triggered, the last one will be passed upon return but any others (or older ones) are still accessible as dropped events."	aBlock numArgs = 0 ifFalse:[^self error:'0 argument block expected'].	eventSpec size = 0 ifTrue:[^aBlock value].	^Processor activeProcess		observe: eventSpec 		semaphore: nil 		buffer: ScriptEventBuffer new		during:[:handler|			queueSize ifNotNil:[handler bufferSize: queueSize].			aBlock value.			handler nextEvent]! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/22/2001 00:42'!clock	"Return the clock driving the receiver"	^Processor activeProcess clock! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 22:29'!evaluate: aBlock	^aBlock value! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 22:29'!evaluate: aBlock with: arg1	^aBlock value: arg1! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 22:31'!evaluate: aBlock with: arg1 with: arg2	^aBlock value: arg1 value: arg2! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/28/2002 16:33'!findScript: scriptDescriptor	| myScripts script |	myScripts := self myScripts.	1 to: myScripts size do:[:i|		script := myScripts at: i.		(scriptDescriptor isScriptDescriptorIn: script) ifTrue:[^script].	].	^nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/19/2002 01:07'!findScript: scriptDescriptor withArguments: args	| myScripts script |	myScripts := self myScripts.	1 to: myScripts size do:[:i|		script := myScripts at: i.		(scriptDescriptor isScriptDescriptorIn: script) ifTrue:[			script arguments = args ifTrue:[^script].		].	].	^nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/21/2001 23:24'!forAnyOf: eventSpec do: aBlock	"Evaluate aBlock whenever any of the events in eventSpec is triggered."	^self forAnyOf: eventSpec do: aBlock until:[false] queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 23:47'!forAnyOf: eventSpec do: aBlock until: stopCondition	"Evaluate aBlock whenever any of the events in eventSpec is triggered"	^self forAnyOf: eventSpec do: aBlock until: stopCondition queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:35'!forAnyOf: eventSpec do: aBlock until: stopCondition queueSize: queueSize	"Evaluate aBlock whenever any of the events in eventSpec is triggered.	DETAILS: All of the events triggered will be passed into the shared queue. If there are multiple events triggered, the last one will be passed into the block but any others (or older ones) are still accessible as dropped events."	| nArgs |	(nArgs _ aBlock numArgs) > 2 ifTrue:[^self error:'0-2 argument block expected'].	eventSpec size = 0 ifTrue:[^nil].	^Processor activeProcess		observe: eventSpec		semaphore: Semaphore new 		buffer: ScriptEventBuffer new		during:[:handler|			queueSize ifNotNil:[handler bufferSize: queueSize].			[Processor activeProcess waitProcessOn: handler semaphore.			self privateSendEvent: handler nextEvent to: aBlock args: nArgs.			stopCondition value] whileFalse.			nil].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 2/17/2002 15:49'!forAnyOf: eventSpec until: stopCondition do: aBlock			 	"Evaluate aBlock whenever any of the events in eventSpec is triggered"	^self forAnyOf: eventSpec do: aBlock until: stopCondition queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 23:48'!forEach: eventName do: aBlock	"Evaluate aBlock whenever the event is triggered."	^self forEach: eventName do: aBlock until: [false] queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 23:48'!forEach: eventName do: aBlock until: stopName	^self waitUntil: stopName forEach: eventName do: aBlock! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:35'!forEach: eventName do: aBlock until: stopCondition queueSize: queueSize	"Evaluate the given block whenever eventName is triggered"	| nArgs |	(nArgs _ aBlock numArgs) > 2 ifTrue:[^self error:'0-2 argument block expected'].	^Processor activeProcess		observe: {self. eventName}		semaphore: nil 		buffer: nil		during:[:handler|			[Processor activeProcess waitProcessOn: handler semaphore.			self privateSendEvent: handler nextEvent to: aBlock args: nArgs.			stopCondition value] whileFalse.			nil]! !!Object methodsFor: '*Scripting-Extensions'!forEach: eventName do: aBlock untilAnyOf: stopEvents	^self waitUntilAnyOf: stopEvents forEach: eventName do: aBlock! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 2/6/2002 16:17'!forEach: eventName until: stopCondition do: aBlock	"Evaluate the given block whenever eventName is triggered"	^self forEach: eventName do: aBlock until: stopCondition queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/24/2002 21:49'!forEach: loopEvents untilAnyOf: stopEvents do: aBlock	^self waitUntilAnyOf: stopEvents forEach: loopEvents do: aBlock queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 20:21'!handlesAnyOf: eventList	| map |	map := self myEventMap ifNil:[^false].	eventList do:[:evtName| (self handlesEvent: evtName map: map) ifTrue:[^true]].	^false! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 20:22'!handlesEvent: eventName	^self handlesEvent: eventName map: (self myEventMap ifNil:[^false]).! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 14:43'!handlesEvent: eventName map: map	| list |	list := map at: eventName ifAbsent:[^false].	1 to: list size do:[:i|		(list at: i) ifNotNil:[^true].	].	self removeEvent: eventName map: map.	^false! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/17/2002 20:46'!isEventTracer	^false! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 2/17/2002 19:11'!isScript	^false! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 2/6/2004 17:42'!isSpecialSystemScript: scriptDescriptor	"A fall-back for special system scripts which need to be handled in slightly different ways"	^scriptDescriptor == #runTicking:at:! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/28/2004 21:55'!makeTicking: scriptDescriptor withArguments: args at: frequency	"If no trigger is given, the script is evaluated exactly once"	| script |	script := scriptDescriptor asTickMessageIn: self arguments: args.	script eventSpec: (Array with: self with: #ticking).	script frequency: frequency.	self privateAddScript: script.	^script! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 21:53'!myEventMap	^self myEventRegistry at: self ifAbsent:[nil]! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 21:56'!myEventMap: anEventMap	anEventMap 		ifNil:[self myEventRegistry removeKey: self ifAbsent:[]]		ifNotNil:[self myEventRegistry at: self put: anEventMap].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 21:55'!myEventRegistry	^Smalltalk at: #TestingEventMap  ifAbsentPut:[WeakIdentityKeyDictionary new].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 21:54'!myScriptRegistry	^Smalltalk at: #TestingScriptRegistry  ifAbsentPut:[WeakIdentityKeyDictionary new].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 17:15'!myScripts	^self myScriptRegistry at: self ifAbsent:[#()]! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 21:56'!myScripts: scripts	scripts		ifNil:[self myScriptRegistry removeKey: self ifAbsent:[]]		ifNotNil:[self myScriptRegistry  at: self put: scripts].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 20:36'!newEventMap	^IdentityDictionary new! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/9/2004 17:19'!on: eventName notify: anObserver	"Notify the observer when the given event is triggered."	| map list |	eventName ifNil:[^self].	map := self myEventMap.	map ifNil:[self myEventMap: (map := self newEventMap)].	list := map at: eventName ifAbsentPut:[WeakArray new: 1].	1 to: list size do:[:i|		(list at: i) ifNil:[^list at: i put: anObserver].	].	map at: eventName put: (list copyWith: anObserver).	^anObserver! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/9/2004 17:20'!on: eventName traceWith: aTraceObserver	"Start tracing events when the given event name is triggered.	The provided trace observer will replace any existing trace observer for this event.	If nil, the trace observer is removed."	| map list |	eventName ifNil:[^self].	map := self myEventMap.	map ifNil:[self myEventMap: (map := self newEventMap)].	list := map at: eventName ifAbsentPut:[WeakArray new: 1].	"tracer is always the first entry"	(list at: 1) ifNil:[^list at: 1 put: aTraceObserver].	(list at: 1) isEventTracer ifTrue:[^list at: 1 put: aTraceObserver].	2 to: list size do:[:i|		(list at: i) ifNil:[			list at: i put: (list at: 1).			^list at: 1 put: aTraceObserver].	].	map at: eventName put: (WeakArray with: aTraceObserver), list.	^aTraceObserver! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/9/2004 17:20'!on: eventName unNotify: anObserver	"Notify the observer when the given event is triggered."	| map list |	map := self myEventMap ifNil:[^self].	list := map at: eventName ifAbsent:[^self].	list := list reject:[:any| any == nil or:[any == anObserver]].	list size = 0 		ifTrue:[self removeEvent: eventName map: map]		ifFalse:[map at: eventName put: list].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/19/2002 23:47'!pauseScript: scriptDescriptor	| myScripts script |	myScripts := self myScripts.	1 to: myScripts size do:[:i|		script := myScripts at: i.		(scriptDescriptor isScriptDescriptorIn: script) ifTrue:[			script pauseScript.		].	].	^script! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:35'!primitiveWaitUntil: eventName	"Wait until an event with the given name is signaled."	^Processor activeProcess		observe: {self. eventName}		semaphore: nil 		buffer: nil		during:[:handler|			handler semaphore primitiveWait.			handler nextEvent		].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:36'!primitiveWaitUntilAnyOf: eventSpec	"Wait until any of the events in eventSpec are triggered."	eventSpec size = 0 ifTrue:[^nil].	^Processor activeProcess		observe: eventSpec		semaphore: Semaphore new 		buffer: ScriptEventBuffer new		during:[:handler|			handler semaphore primitiveWait.			handler nextEvent		].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 19:19'!privateAddScript: aScript	| scriptList |	aScript receiver == self ifFalse:[^self error:'Not my script'].	scriptList := self myScripts.	scriptList size = 0		ifTrue:[scriptList := Array with: aScript] 		ifFalse:[scriptList := scriptList copyWith: aScript].	self myScripts: scriptList! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 21:42'!privateRemoveScript: aScript	| scriptList |	scriptList := self myScripts.	(scriptList size = 1 and:[(scriptList at: 1) == aScript]) 		ifTrue:[scriptList := nil]		ifFalse:[scriptList := scriptList reject:[:s| s == aScript]].	self myScripts: scriptList! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 20:37'!privateSendEvent: anEvent to: aBlock args: nArgs	"Private. Send an event to the block given the number of block arguments"	nArgs = 0 ifTrue:[^aBlock value].	nArgs = 1 ifTrue:[^aBlock value: anEvent].	nArgs = 2 ifTrue:[^aBlock value: anEvent value: self].	self error:'0-2 argument block expected'! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 2/17/2004 19:10'!privateSignalEvent: anEvent	"Signal the occurance of anEvent"	| map list msg tracing |	map := self myEventMap ifNil:[^self].	list := map at: anEvent selector ifAbsent:[^self].	tracing := (list at: 1) isEventTracer.	1 to: list size do:[:i|		(msg := list at: i) ifNotNil:[msg valueWithEvent: anEvent clone]].	tracing ifTrue:[Processor activeProcess eventTracer stopTracing].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/30/2003 01:31'!privateSignalSynchronousEvent: anEvent	"Signal the occurance of anEvent"	| map list msg tracing |	map := self myEventMap ifNil:[^self].	list := map at: anEvent selector ifAbsent:[^self].	tracing := (list at: 1) isEventTracer.	1 to: list size do:[:i|		(msg := list at: i) ifNotNil:[msg synchronousValueWithEvent: anEvent clone]].	tracing ifTrue:[Processor activeProcess eventTracer stopTracing].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 20:33'!removeEvent: eventName map: eventMap	eventMap removeKey: eventName ifAbsent:[].	eventMap size = 0 ifTrue:[self myEventMap: nil].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 2/24/2004 01:34'!resumeScript: scriptDescriptor	| myScripts script |	myScripts := self myScripts.	1 to: myScripts size do:[:i|		script := myScripts at: i.		(scriptDescriptor isScriptDescriptorIn: script) ifTrue:[			script resumeScript.			^script		].	].	^nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 12:11'!runScript: scriptDescriptor	^self runScript: scriptDescriptor withArguments: #() when: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 12:11'!runScript: aScriptDescriptor when: aTrigger	"Evaluate the given script whenever the trigger becomes active."	^self runScript: aScriptDescriptor withArguments: #() when: aTrigger! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 12:11'!runScript: scriptDescriptor withArguments: args	^self runScript: scriptDescriptor withArguments: args when: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/31/2004 17:57'!runScript: aScriptDescriptor withArguments: args when: aTrigger	"Evaluate the given script whenever the trigger becomes active."	| script spec |	script := aScriptDescriptor asScriptMessageIn: self arguments: args.	self privateAddScript: script.	spec := aTrigger asEventSpecificationIn: self.	spec ifNil:[^script valueWithEvent: nil].	1 to: spec size by: 2 do:[:i|		(spec at: i) on: (spec at: i+1) notify: script.	].	script eventSpec: spec.	^script! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/14/2003 04:56'!runTicking: aMessage at: frequency	"Run the given script ticking at the provided frequency"	| delay script |	self flag: #waitProcessOn:. "optimized"	script := Processor activeProcess.	frequency < 1000 		ifTrue:[delay := Delay forMilliseconds: (1000 / frequency) asInteger].	[true] whileTrue:[		"fire script"		aMessage valueWithEvent: script scheduler tickEvent.		"wait on delay"		script beginWait.		delay ifNotNil:[delay primitiveWait].		script scheduler tickingList primitiveWait.		script endWait.	].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/22/2001 00:41'!scriptScheduler	"Return the receiver's script scheduler.	Note: Written so that we can safely run this in the presence of Processor."	| scheduler |	scheduler _ Processor activeProcess scheduler.	scheduler isScriptScheduler ifTrue:[^scheduler].	"This is really a fallback position"	^ScriptScheduler activeScheduler! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/20/2003 12:29'!send: aSelector to: anObject	^anObject perform: aSelector! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/20/2003 12:29'!send: aSelector to: anObject with: arg1	^anObject perform: aSelector with: arg1! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/20/2003 12:29'!send: aSelector to: anObject with: arg1 with: arg2	^anObject perform: aSelector with: arg1 with: arg2! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/20/2003 12:29'!send: aSelector to: anObject withArguments: args	^anObject perform: aSelector withArguments: args! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/22/2001 00:42'!signal: eventName	"Signal the occurance of anEvent"	^self signalEvent: (ScriptEvent new setSender: self selector: eventName).! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/22/2001 00:42'!signal: eventName with: arg1	"Signal the occurance of anEvent"	^self signalEvent: (ScriptEvent new setSender: self selector: eventName arguments: (Array with: arg1))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/22/2001 00:43'!signal: eventName with: arg1 with: arg2	"Signal the occurance of anEvent"	^self signalEvent: (ScriptEvent new setSender: self selector: eventName arguments: (Array with: arg1 with: arg2))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/17/2002 20:14'!signal: eventName with: arg1 with: arg2 with: arg3	"Signal the occurance of anEvent"	^self signalEvent: (ScriptEvent new setSender: self selector: eventName arguments: (Array with: arg1 with: arg2 with: arg3))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/17/2002 20:15'!signal: eventName with: arg1 with: arg2 with: arg3 with: arg4	"Signal the occurance of anEvent"	^self signalEvent: (ScriptEvent new setSender: self selector: eventName arguments: (Array with: arg1 with: arg2 with: arg3 with: arg4))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/22/2001 00:43'!signal: eventName withArguments: anArray	"Signal the occurance of anEvent"	^self signalEvent: (ScriptEvent new setSender: self selector: eventName arguments: anArray)! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 9/8/2004 16:20'!signalChanged: eventName from: oldValue to: newValue	"Signal the occurance of anEvent"	^self signalEvent: (ScriptChangeEvent new setSender: self selector: eventName arguments: (Array with: newValue with: oldValue))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/21/2001 23:38'!signalEvent: anEvent	"Signal the occurance of anEvent"	^self privateSignalEvent: anEvent! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/30/2003 01:31'!signalSynchronousEvent: anEvent	"Signal the occurance of anEvent"	^self privateSignalSynchronousEvent: anEvent! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/24/2001 21:26'!startScript: scriptDescriptor	"If no trigger is given, the script is evaluated exactly once"	^self startScript: scriptDescriptor withArguments: #() when: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 12:12'!startScript: aScriptDescriptor when: aTrigger	"Evaluate the given script whenever the trigger becomes active."	^self startScript: aScriptDescriptor withArguments: #() when: aTrigger! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/24/2001 21:25'!startScript: scriptDescriptor withArguments: args	"If no trigger is given, the script is evaluated exactly once"	^self startScript: scriptDescriptor withArguments: args when: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/31/2004 17:56'!startScript: aScriptDescriptor withArguments: args when: aTrigger	"Evaluate the given script whenever the trigger becomes active."	| script spec |	script := aScriptDescriptor asAsyncScriptMessageIn: self arguments: args.	self privateAddScript: script.	aTrigger ifNil:[^script valueWithEvent: ScriptEvent new].	spec := aTrigger asEventSpecificationIn: self.	spec ifNil:[^script valueWithEvent: ScriptEvent new].	"Note: Normally, we should be able to just do a pauseScript/resumeScript here. 	However, this would dump any existing event queue in the async scripts which	may already contain events."	1 to: spec size by: 2 do:[:i|		(spec at: i) on: (spec at: i+1) notify: script.	].	script eventSpec size = 0		ifTrue:[script eventSpec: spec]		ifFalse:[script eventSpec: script eventSpec, spec].	^script! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/14/2003 04:45'!startTicking: scriptDescriptor at: frequency	"If no trigger is given, the script is evaluated exactly once"	^self startTicking: scriptDescriptor withArguments: #() at: frequency! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/28/2004 21:55'!startTicking: scriptDescriptor withArguments: args at: frequency	"If no trigger is given, the script is evaluated exactly once"	| script |	script := self makeTicking: scriptDescriptor withArguments: args at: frequency.	script resumeScript.	^script! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/29/2002 22:47'!stopScript: scriptDescriptor	| myScripts script |	myScripts := self myScripts.	1 to: myScripts size do:[:i|		script := myScripts at: i.		(scriptDescriptor isScriptDescriptorIn: script) ifTrue:[			script terminateScript.		].	].	^script! !!Object methodsFor: '*Scripting-Extensions'!stopScript: aScript when: anEvent	self startScript: #stopScript: withArguments:{aScript} when: anEvent! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/29/2002 22:54'!stopScripts: scriptList	scriptList do:[:script| self stopScript: script].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 00:11'!syncScript	"Sync the current script, e.g., suspend it until all pending scripts have completed"	Processor activeProcess scheduler syncList primitiveWait.! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/30/2003 01:32'!synchronousSignal: eventName	"Signal the occurance of anEvent"	^self signalSynchronousEvent: (ScriptEvent new setSender: self selector: eventName).! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/14/2003 00:10'!synchronousSignal: eventName with: arg1	"Signal the occurance of anEvent"	^self signalSynchronousEvent: 		(ScriptEvent new 			setSender: self 			selector: eventName			arguments: (Array with: arg1))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/14/2003 00:10'!synchronousSignal: eventName with: arg1 with: arg2	"Signal the occurance of anEvent"	^self signalSynchronousEvent: 		(ScriptEvent new 			setSender: self 			selector: eventName			arguments: (Array with: arg1 with: arg2))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/14/2003 00:11'!synchronousSignal: eventName with: arg1 with: arg2 with: arg3	"Signal the occurance of anEvent"	^self signalSynchronousEvent: 		(ScriptEvent new 			setSender: self 			selector: eventName			arguments: (Array with: arg1 with: arg2 with: arg3))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/14/2003 00:11'!synchronousSignal: eventName with: arg1 with: arg2 with: arg3 with: arg4	"Signal the occurance of anEvent"	^self signalSynchronousEvent: 		(ScriptEvent new 			setSender: self 			selector: eventName			arguments: (Array with: arg1 with: arg2 with: arg3 with: arg4))! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/19/2002 23:30'!wait: timeOut	"Wait for the given number of seconds"	timeOut > 0 ifTrue:[(Delay forMilliseconds: (timeOut * 1000) asInteger) wait].! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/21/2001 21:38'!waitOn: aWaitable	^Processor activeProcess waitProcessOn: aWaitable.! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 20:04'!waitTick	^self clock waitTick.! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 3/14/2004 15:14'!waitUntil: eventName	"Wait until an event with the given name is signaled.	[ar 3/14/2004] Something is wrong with the semantics here. While it is perfectly fine for a player to wait until something happens inside himself, e.g., 'self waitUntil: #mouseDown', it seems Very Wrong Indeed to ask another player to 'container waitUntil: #mouseDown' since it isn't the container who is waiting but rather the sender of the request. 	So what might be a good representation for this? We know it's always the sender who is waiting and never the guy initiating the event... maybe self waitUntil: #mouseDown in: container? Or even 'self waitUntil: container's mouseDown'? Grrrrr... so how do we distinguish the name of some event from the name of a method???"	| script |	^(script := Processor activeProcess)		observe: {self. eventName}		semaphore: nil 		buffer: nil		during:[:handler|			script waitProcessOn: handler semaphore.			handler nextEvent		]! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/24/2001 22:17'!waitUntil: eventName do: aBlock	"Repeatedly evaluate aBlock until the given event is signaled."	^self waitUntil: eventName forAnyOf: #() do: aBlock queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 8/21/2001 23:26'!waitUntil: stopEvent forAnyOf: eventSpec do: aBlock	"Evaluate aBlock for each of the events generated from event spec. Stop if stopEvent occurs in stopObject."	^self waitUntil: stopEvent forAnyOf: eventSpec do: aBlock queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:42'!waitUntil: stopEvent forAnyOf: eventSpec do: aBlock queueSize: queueSize	"Evaluate aBlock for each of the events generated from event spec. Stop if stopEvent occurs in stopObject. See comment at the end for details."	| sema nArgs script loopHandler |	(nArgs _ aBlock numArgs) > 2 ifTrue:[^self error:'0-2 argument block expected'].	^(script := Processor activeProcess)		observe: {self. stopEvent}		semaphore: nil		buffer: nil		during:[:stopHandler|			sema := stopHandler semaphore.			loopHandler := script				observe: eventSpec				semaphore: sema 				buffer: ScriptEventBuffer new.			queueSize ifNotNil:[loopHandler bufferSize: queueSize].			 [sema ifNotNil:[script waitProcessOn: sema]. "until something happens"			stopHandler size = 0] whileTrue:				[self privateSendEvent: loopHandler nextEvent to: aBlock args: nArgs].			stopHandler nextEvent].	"DETAILS: This method establishes two separate scopes to handle stop and loop events independently. An alternative way would be to use something like:		self forAnyOf: {			self. stopEvent.			loopObject. loopEvent.		} do:[:evt|			evt selector == stopEvent				ifTrue:[doStop _ true]				ifFalse:[aBlock value: evt].		] until:[doStop]	but this has some complicated implications when the block takes a long time to complete. In this case, the stop event could get lost (if too many loop events come in afterwards) and it would also increase the complexity for the case if any loop events come in after the stop event. The way it is done above avoids these problems completely."! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 23:49'!waitUntil: stopEvent forEach: loopEvent do: aBlock	^self waitUntil: stopEvent forEach: loopEvent in: self do: aBlock queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 23:49'!waitUntil: stopEvent forEach: loopEvent in: loopObject do: aBlock	"Evaluate aBlock for each of the loop events generated by loopObject. Stop if stopEvent occurs in stopObject."	^self waitUntil: stopEvent forEach: loopEvent in: loopObject do: aBlock queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 9/8/2002 15:37'!waitUntil: stopEvent forEach: loopEvent in: loopObject do: aBlock queueSize: queueSize	"Evaluate aBlock for each of the loop events generated by loopObject. Stop if stopEvent occurs in stopObject. See comment at the end for details."	| sema nArgs loopHandler script |	(nArgs _ aBlock numArgs) > 2 ifTrue:[^self error:'0-2 argument block expected'].	^(script := Processor activeProcess)		observe: {self. stopEvent}		semaphore: nil		buffer: nil		during:[:stopHandler|			sema _ stopHandler semaphore.			loopHandler _ script observe: {loopObject. loopEvent} semaphore: sema.			queueSize ifNotNil:[loopHandler bufferSize: queueSize].			[script waitProcessOn: sema. "until something happens"			stopHandler size = 0] whileTrue:				[self privateSendEvent: loopHandler nextEvent to: aBlock args: nArgs].			stopHandler nextEvent].	"DETAILS: This method establishes two separate scopes to handle stop and loop events independently. An alternative way would be to use something like:		self forAnyOf: {			self. stopEvent.			loopObject. loopEvent.		} do:[:evt|			evt selector == stopEvent				ifTrue:[doStop _ true]				ifFalse:[aBlock value: evt].		] until:[doStop]	but this has some complicated implications when the block takes a long time to complete. In this case, the stop event could get lost (if too many loop events come in afterwards) and it would also increase the complexity for the case if any loop events come in after the stop event. The way it is done below avoids these problems completely."! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:48'!waitUntilAllOf: eventSpec	"Wait until all of the events in event spec are triggered.	Return an array of events corresponding the event specification."	| tempList anObject selector handler script |	eventSpec size = 0 ifTrue:[^#()].	"Since we need to have access to all the semaphores,	create and remember each handler individually."	script := Processor activeProcess.	tempList _ Array new: eventSpec size // 2.	1 to: eventSpec size // 2 do:[:i|		anObject _ eventSpec at: 2*i-1.		selector _ eventSpec at: 2*i.		tempList at: i put: (script observe: {anObject. selector}).	].	handler _ tempList at: 1. "the outermost one"	[		tempList do:[:h| script waitProcessOn: h semaphore].		1 to: tempList size do:[:i|			tempList at: i put: (tempList at: i) nextEvent].	] ensure:[		script releaseObserver: handler.	].	^tempList! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 4/23/2002 19:49'!waitUntilAnyOf: eventSpec	"Wait until any of the events in eventSpec are triggered."	| script |	eventSpec size = 0 ifTrue:[^nil].	^(script := Processor activeProcess)		observe: eventSpec		semaphore: Semaphore new 		buffer: ScriptEventBuffer new		during:[:handler|			script waitProcessOn: handler semaphore.			handler nextEvent]! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/24/2002 21:49'!waitUntilAnyOf: stopEvents forEach: loopEvents do: aBlock	^self waitUntilAnyOf: stopEvents forEach: loopEvents do: aBlock queueSize: nil! !!Object methodsFor: '*Scripting-Extensions' stamp: 'ar 5/24/2002 23:09'!waitUntilAnyOf: stopEvents forEach: loopEvents do: aBlock queueSize: queueSize	"Evaluate aBlock for each of the loop events generated by loopObject. Stop if stopEvent occurs in stopObject. See comment at the end for details."	| sema nArgs loopHandler script |	(nArgs _ aBlock numArgs) > 2 ifTrue:[^self error:'0-2 argument block expected'].	^(script := Processor activeProcess)		observe: stopEvents		semaphore: Semaphore new		buffer: ScriptEventBuffer new		during:[:stopHandler|			sema _ stopHandler semaphore.			loopHandler _ script observe: loopEvents semaphore: sema.			queueSize ifNotNil:[loopHandler bufferSize: queueSize].			[script waitProcessOn: sema. "until something happens"			stopHandler buffer size = 0] whileTrue:				[self privateSendEvent: loopHandler nextEvent to: aBlock args: nArgs].			stopHandler nextEvent].! !!Array methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 15:42'!asEventSpecificationIn: owner	self size = 0 ifTrue:[^nil].	^self! !!BlockContext methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 22:31'!asAsyncScriptMessageIn: scriptPerformer arguments: args	"Convert the receiver into an appropriate ScriptMessageSend"	| nArgs selector |	nArgs _ self numArgs.	nArgs = 0 ifTrue:[selector _ #evaluate:].	nArgs = 1 ifTrue:[selector _ #evaluate:with:].	nArgs = 2 ifTrue:[selector _ #evaluate:with:with:].	selector ifNil:[^super asAsyncScriptMessageIn: scriptPerformer arguments: args].	^AsyncScriptMessageSend 		receiver: scriptPerformer 		selector: selector		arguments: {self},args! !!BlockContext methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 22:32'!asScriptMessageIn: scriptPerformer arguments: args	"Convert the receiver into an appropriate ScriptMessageSend"	| nArgs selector |	nArgs _ self numArgs.	nArgs = 0 ifTrue:[selector _ #evaluate:].	nArgs = 1 ifTrue:[selector _ #evaluate:with:].	nArgs = 2 ifTrue:[selector _ #evaluate:with:with:].	selector ifNil:[^super asAsyncScriptMessageIn: scriptPerformer arguments: args].	^ScriptMessageSend 		receiver: scriptPerformer 		selector: selector		arguments: {self},args! !!BlockContext methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 14:48'!isScriptDescriptorIn: aScript	"Convert the receiver into an appropriate ScriptMessageSend"	| nArgs selector |	nArgs _ self numArgs.	nArgs = 0 ifTrue:[selector := #value].	nArgs = 1 ifTrue:[selector := #value:].	nArgs = 2 ifTrue:[selector := #value:value:].	selector ifNil:[selector := #valueWithArguments:].	^aScript receiver == self and:[aScript selector == selector]! !!Delay methodsFor: '*Scripting-Extensions' stamp: 'ar 7/20/2001 13:46'!delaySemaphore	^delaySemaphore! !!Delay methodsFor: '*Scripting-Extensions' stamp: 'ar 3/4/2002 12:43'!primitiveWait	"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."	self schedule.	delaySemaphore primitiveWait.! !!Delay methodsFor: '*Scripting-Extensions' stamp: 'ar 8/22/2001 14:18'!setDelayDuration: millisecondCount	delayDuration _ millisecondCount asInteger max: 0.! !!Heap methodsFor: '*Scripting-Extensions' stamp: 'ar 3/5/2002 01:29'!firstOrNil	tally = 0 ifTrue:[^nil] ifFalse:[^array at: 1]! !!LinkedList methodsFor: '*Scripting-Extensions' stamp: 'ar 7/8/2001 14:24'!firstOrNil	"Answer the first element of the receiver or nil if empty"	^firstLink! !!LinkedList methodsFor: '*Scripting-Extensions' stamp: 'ar 3/5/2002 23:17'!includes: aLink	| link |	link := firstLink.	[link == nil] whileFalse:[		aLink == link ifTrue:[^true].		link := link nextLink].	^false! !!LinkedList methodsFor: '*Scripting-Extensions' stamp: 'ar 3/4/2002 14:39'!removeAll	| link oldLink |	link := firstLink.	[link == lastLink] whileFalse:[		oldLink := link.		link := link nextLink.		oldLink nextLink: nil.	].	firstLink := lastLink := nil.! !!MessageSend methodsFor: '*Scripting-Extensions' stamp: 'ar 5/18/2002 17:18'!printMessage	^String streamContents:[:s| self printMessageOn: s].! !!MessageSend methodsFor: '*Scripting-Extensions' stamp: 'ar 5/18/2002 17:50'!printMessageOn: aStream	aStream print: receiver identityHash.	aStream nextPutAll: (receiver printStringLimitedTo: 50).	aStream nextPutAll:'>>'.	aStream nextPutAll: (selector printStringLimitedTo: 50).	aStream print: arguments.! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 7/18/2001 21:17'!clock	"To prevent infinite recursion"	^ScriptScheduler activeScheduler! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 5/17/2002 20:16'!eventTracer	^nil! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 5/17/2002 20:17'!eventTracer: aTracer	"Ignored"! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 7/7/2001 15:30'!isScriptingProcess	^false! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 3/4/2002 12:42'!isSystemProcess	^true! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 7/9/2001 17:13'!scheduler	^Processor! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 7/13/2001 16:40'!suspendedTallyContext	"Return the context to tally"	self == ScriptScheduler activeSchedulerProcess ifFalse:[^suspendedContext].	^ScriptScheduler activeSuspendedContext ifNil:[suspendedContext].! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 5/17/2002 20:12'!traceEvents	^false! !!Process methodsFor: '*Scripting-Extensions' stamp: 'ar 5/17/2002 20:16'!traceEvents: aBool	"ignored"! !!ProcessorScheduler methodsFor: '*Scripting-Extensions' stamp: 'ar 7/7/2001 15:15'!anyProcessesAbove: highestPriority			 	"Do any instances of Process exist with higher priorities?"	^(Process allSubInstances select: [:aProcess | 		aProcess priority > highestPriority]) isEmpty		"If anyone ever makes a subclass of Process, be sure to use allSubInstances."! !!ProcessorScheduler methodsFor: '*Scripting-Extensions' stamp: 'ar 7/21/2001 23:28'!initialScriptPriority	"Return the priority at which a user script process should be started.	NOTE: The initial script priority needs to be higher than the priority	during execution of the script. This is so that any scripts which are scheduled	from another script preempt the running script to get in sync with the scheduler."	^UserScriptPriority + 1! !!ProcessorScheduler methodsFor: '*Scripting-Extensions' stamp: 'ar 8/21/2001 23:33'!isScriptScheduler	"No, I am not. I schedule 'regular' processes."	^false! !!ProcessorScheduler methodsFor: '*Scripting-Extensions' stamp: 'ar 7/8/2001 17:16'!userScriptPriority	"Return the priority at which a user script process should be run"	^UserScriptPriority! !!ProcessorScheduler class methodsFor: '*Scripting-override' stamp: 'ar 3/9/2004 15:38'!initialize	(self classPool includesKey: #UserScriptPriority) ifFalse:[		"A quick hack for getting the installation through MC right..."		self addClassVarName: #UserScriptPriority.	].	SystemRockBottomPriority _ 10.	SystemBackgroundPriority _ 20.	UserBackgroundPriority _ 30.	UserSchedulingPriority _ 40.	UserScriptPriority _ 45.	UserInterruptPriority _ 50.	LowIOPriority _ 60.	HighIOPriority _ 70.	TimingPriority _ 80.	"ProcessorScheduler initialize."! !!ScriptEvent methodsFor: 'accessing' stamp: 'ar 7/14/2001 16:33'!arguments	^arguments ifNil:[arguments _ #()]! !!ScriptEvent methodsFor: 'accessing' stamp: 'ar 7/20/2001 21:16'!droppedEvent	"Return the prior (e.g., dropped) event that occured before the receiver"	^priorEvent! !!ScriptEvent methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:19'!firstEvent	"Answer the first (oldest) event in the chain of events"	| evt |	evt := self.	[evt priorEvent == nil] whileFalse:[evt := evt priorEvent].	^evt! !!ScriptEvent methodsFor: 'accessing' stamp: 'ar 7/14/2001 16:33'!selector	^selector! !!ScriptEvent methodsFor: 'accessing' stamp: 'ar 7/14/2001 16:33'!sender	^sender! !!ScriptEvent methodsFor: 'accessing' stamp: 'ar 7/20/2001 20:55'!withDroppedEvents	"Return an array of events that contain the receiver and all dropped events from the oldest to the newest (e.g., in reverse order of prior events)."	^(self droppedEventStreamOfSize: 0) contents! !!ScriptEvent methodsFor: 'accessing' stamp: 'bf 9/8/2004 14:26'!withDroppedEventsDo: aBlock	"Evaluate aBlock with the receiver and all dropped events from the oldest to the newest."	priorEvent ifNotNil:[priorEvent withDroppedEventsDo: aBlock].	^aBlock value: self! !!ScriptEvent methodsFor: 'private' stamp: 'ar 7/20/2001 20:57'!droppedEventStreamOfSize: sizeNeeded	priorEvent ifNil:[		^(WriteStream on: (Array new: sizeNeeded+1))			nextPut: self;			yourself	] ifNotNil:[		^(priorEvent droppedEventStreamOfSize: sizeNeeded+1) 			nextPut: self;			yourself.	].! !!ScriptEvent methodsFor: 'private' stamp: 'ar 7/20/2001 21:16'!priorEvent	"Return the prior (e.g., dropped) event that occured before the receiver"	^priorEvent! !!ScriptEvent methodsFor: 'private' stamp: 'ar 7/20/2001 20:53'!priorEvent: anEvent	priorEvent _ anEvent! !!ScriptEvent methodsFor: 'private' stamp: 'ar 7/20/2001 18:35'!setArguments: args	arguments _ args.! !!ScriptEvent methodsFor: 'private' stamp: 'ar 2/9/2004 18:06'!setSender: newSender	sender := newSender.! !!ScriptEvent methodsFor: 'private' stamp: 'ar 7/14/2001 16:33'!setSender: aSender selector: aSelector	sender _ aSender.	selector _ aSelector.! !!ScriptEvent methodsFor: 'private' stamp: 'ar 7/14/2001 16:33'!setSender: aSender selector: aSelector arguments: args	sender _ aSender.	selector _ aSelector.	arguments _ args.! !!ScriptEvent methodsFor: 'experimental' stamp: 'ar 7/20/2001 21:19'!handler	"Return the handler scope that received the event"	^Processor activeProcess eventHandlerFor: self! !!ScriptEvent methodsFor: 'experimental' stamp: 'ar 7/20/2001 21:19'!pass	"Pass the event to the next event handler scope"	^Processor activeProcess passEvent: self.! !!ScriptChangeEvent methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:18'!arguments	^Array 		with: self newValue		with: self firstEvent oldValue! !!ScriptChangeEvent methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:17'!newValue	^arguments at: 1! !!ScriptChangeEvent methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:17'!oldValue	^arguments at: 2! !!ScriptChangeEvent methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:17'!value	^self newValue! !!ScriptEventBuffer methodsFor: 'accessing' stamp: 'ar 7/20/2001 21:13'!bufferSize	"Return the current buffer size of the receiver"	^bufferSize! !!ScriptEventBuffer methodsFor: 'accessing' stamp: 'ar 7/20/2001 21:13'!bufferSize: newSize	"Set a new buffer size"	bufferSize _ newSize max: 1.! !!ScriptEventBuffer methodsFor: 'accessing' stamp: 'ar 7/20/2001 21:13'!size	"Return the number of elements in the receiver"	^size! !!ScriptEventBuffer methodsFor: 'streaming' stamp: 'ar 4/25/2002 11:56'!next	| prev now next |	size > 1 ifTrue:["READ THE CLASS COMMENT!!!!!!"		prev _ firstEvent.		now _ firstEvent priorEvent.		firstEvent priorEvent: nil.		[now == nil] whileFalse:[			"Change link now->next to now->prev"			next := now priorEvent.			now priorEvent: prev.			prev := now.			now := next].	].	next := lastEvent.	lastEvent := firstEvent := nil.	size := 0.	^next! !!ScriptEventBuffer methodsFor: 'streaming' stamp: 'ar 4/25/2002 11:55'!nextPut: anEvent	size = 0 ifTrue:[		firstEvent := lastEvent := anEvent.		size := 1.	] ifFalse:[		lastEvent priorEvent: anEvent. "READ THE CLASS COMMENT!!!!!!"		lastEvent _ anEvent.		(size := size + 1) > bufferSize ifTrue:[			"drop the first (oldest) recorded event"			firstEvent := firstEvent priorEvent. "READ THE CLASS COMMENT!!!!!!"			size := size - 1.		].	].! !!ScriptEventBuffer methodsFor: 'initialize' stamp: 'ar 7/23/2001 22:44'!flush	firstEvent _ lastEvent _ nil.	size _ 0.! !!ScriptEventBuffer methodsFor: 'initialize' stamp: 'ar 7/20/2001 18:47'!initialize	firstEvent _ lastEvent _ nil.	size _ 0.	bufferSize _ 100.! !!ScriptEventBuffer class methodsFor: 'instance creation' stamp: 'ar 7/24/2001 20:06'!new	^super new initialize! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:22'!buffer	^buffer ifNil:[buffer := ScriptEventBuffer new]! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:22'!buffer: aBuffer	buffer := aBuffer! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:31'!bufferSize	^self buffer bufferSize! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:31'!bufferSize: aNumber	^self buffer bufferSize: aNumber! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:27'!nextHandler	^nextHandler! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:28'!nextHandler: aHandler	nextHandler := aHandler! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 20:36'!noticeEvent: anEvent	^self nextPut: anEvent! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:20'!selector	^selector! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:20'!selector: anObject	selector := anObject! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:21'!semaphore	^semaphore! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:21'!semaphore: sema	semaphore := sema! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:20'!signaler	^signaler! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:21'!signaler: anObject	signaler := anObject! !!ScriptEventObserver methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:28'!suspendedHandler	^suspended! !!ScriptEventObserver methodsFor: 'initialize-release' stamp: 'ar 4/24/2002 15:18'!release	suspended ifNotNil:[suspended resume].	suspended := signaler := nil.! !!ScriptEventObserver methodsFor: 'initialize-release' stamp: 'ar 4/23/2002 19:29'!releaseTo: aHandler	aHandler == self ifTrue:[^self].	self release.	^nextHandler ifNotNil:[nextHandler releaseTo: aHandler].! !!ScriptEventObserver methodsFor: 'initialize-release' stamp: 'ar 4/24/2002 15:23'!resume	flags := flags bitClear: 1.! !!ScriptEventObserver methodsFor: 'initialize-release' stamp: 'ar 4/24/2002 15:22'!resumeSuspending: aHandler	flags := 0.	aHandler ifNotNil:[aHandler suspend].	suspended := aHandler.! !!ScriptEventObserver methodsFor: 'initialize-release' stamp: 'ar 4/24/2002 15:23'!suspend	flags := flags bitOr: 1.! !!ScriptEventObserver methodsFor: 'initialize-release' stamp: 'ar 4/24/2002 15:19'!suspend: aHandler	aHandler ifNotNil:[aHandler suspend].	suspended := aHandler.! !!ScriptEventObserver methodsFor: 'streaming' stamp: 'ar 4/23/2002 20:35'!next	semaphore initSignals.	^buffer ifNotNil:[buffer next]! !!ScriptEventObserver methodsFor: 'streaming' stamp: 'ar 4/23/2002 20:52'!nextEvent	semaphore initSignals.	^buffer ifNotNil:[buffer next]! !!ScriptEventObserver methodsFor: 'streaming' stamp: 'ar 4/23/2002 20:35'!nextPut: anEvent	self buffer nextPut: anEvent.	semaphore signal.! !!ScriptEventObserver methodsFor: 'streaming' stamp: 'ar 4/23/2002 20:36'!size	^buffer ifNil:[0] ifNotNil:[buffer size]! !!ScriptEventObserver methodsFor: 'streaming' stamp: 'ar 4/24/2002 15:23'!valueWithEvent: event	self isSuspended ifTrue:[^self].	self buffer nextPut: event.	semaphore signal.! !!ScriptEventObserver methodsFor: 'experimental' stamp: 'ar 4/23/2002 19:53'!passEvent: anEvent	suspended ifNil:[^false].	anEvent priorEvent: nil.	suspended noticeEvent: anEvent.	^true! !!ScriptEventObserver methodsFor: 'testing' stamp: 'ar 4/24/2002 15:23'!isSuspended	^(flags bitAnd: 1) == 1! !!ScriptEventTraceEntry methodsFor: 'accessing' stamp: 'ar 5/17/2002 20:21'!event	^event! !!ScriptEventTraceEntry methodsFor: 'accessing' stamp: 'ar 5/17/2002 20:22'!message	^message! !!ScriptEventTraceEntry methodsFor: 'accessing' stamp: 'ar 5/17/2002 20:39'!parent	^parent! !!ScriptEventTraceEntry methodsFor: 'accessing' stamp: 'ar 5/17/2002 20:22'!script	^script! !!ScriptEventTraceEntry methodsFor: 'initialize' stamp: 'ar 5/17/2002 20:39'!event: anEvent message: aMessage script: aScript parent: parentScript	event := anEvent.	message := aMessage.	script := aScript.	parent := parentScript.! !!ScriptEventTracer methodsFor: 'testing' stamp: 'ar 5/17/2002 21:01'!isDone	"Return true if no more events can be traced"	| entry script |	traceLog position = 0 ifTrue:[^false].	traceDonePosition = traceLog size ifTrue:[^true].	"See if any of the scripts found after traceDonePosition are still running"	traceDonePosition = 0 ifTrue:[traceDonePosition := 1].	traceLog position: traceDonePosition.	[(entry := traceLog next) == nil] whileFalse:[		script := entry script.		(script notNil and:[script isDone]) ifFalse:[			"Not yet finished"			traceDonePosition := traceLog position.			traceLog position: traceLog size.		].	].	traceDonePosition := traceLog position.	^true! !!ScriptEventTracer methodsFor: 'testing' stamp: 'ar 5/17/2002 20:46'!isEventTracer	^true! !!ScriptEventTracer methodsFor: 'tracing' stamp: 'ar 5/17/2002 20:45'!stopTracing	"For now, just uninstall - we might allow repeated evaluation later"	traceTarget on: traceEvent traceWith: nil. "uninstall"! !!ScriptEventTracer methodsFor: 'tracing' stamp: 'ar 5/17/2002 20:38'!traceEvent: anEvent message: aMessage script: aScript from: parentScript	traceLog nextPut: (ScriptEventTraceEntry new		event: anEvent message: aMessage script: aScript parent: parentScript).! !!ScriptEventTracer methodsFor: 'tracing' stamp: 'ar 5/18/2002 01:08'!valueWithEvent: anEvent	"This initiates a new trace action"	| script |	script := Processor activeProcess.	script eventTracer: self.	script traceEvents: true.	self traceEvent: anEvent message: (MessageSend receiver: traceTarget selector: traceEvent) script: Processor activeProcess from: nil.! !!ScriptEventTracer methodsFor: 'initialize' stamp: 'ar 5/17/2002 20:50'!trace: eventName in: anObject	traceLog := (ReadWriteStream on: (Array new: 100)).	traceDonePosition := 0.	traceEvent := eventName.	traceTarget := anObject.	traceTarget on: eventName traceWith: self.! !!ScriptEventTracer class methodsFor: 'instance creation' stamp: 'ar 5/17/2002 20:40'!trace: eventName in: sender	^self new trace: eventName in: sender! !!ScriptHandlerLink methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:10'!value	^self at: 1! !!ScriptHandlerLink methodsFor: 'accessing' stamp: 'ar 4/23/2002 19:10'!value: anObject	self at: 1 put: anObject! !!ScriptHandlerLink class methodsFor: 'instance creation' stamp: 'ar 4/23/2002 19:09'!new	^self new: 1! !!ScriptHandlerLink class methodsFor: 'instance creation' stamp: 'ar 4/23/2002 19:10'!on: anObject	^(self new: 1) value: anObject! !!ScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 4/28/2002 00:50'!computeExtraArgs	^extraArgs ifNil:[		extraArgs := selector numArgs "how many do we need?"					- self arguments size "how many do we have?".		"resize arguments to fit"		extraArgs < 0 ifTrue:[			arguments := arguments copyFrom: 1 to: arguments size + extraArgs.			extraArgs := 0].		extraArgs > 0 ifTrue:[arguments _ arguments, (Array new: extraArgs)].		extraArgs].! !!ScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 4/24/2002 12:21'!noticeEvent: anEvent	selector ifNotNil:[^self valueWithEvent: anEvent]! !!ScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 3/30/2003 01:30'!synchronousValueWithArguments: anArray event: anEvent	| result myScript |	(myScript := Processor activeProcess) traceEvents 		ifTrue:[myScript traceEvent: anEvent message: self script: nil].	result := receiver perform: selector withArguments: anArray.	eventSpec ifNil:[receiver privateRemoveScript: self].	^result! !!ScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 3/30/2003 01:30'!synchronousValueWithEvent: anEvent	| args count index |	extraArgs ifNil:[self computeExtraArgs]. "resize"	(extraArgs = 0 "no extra args needed"		or:[anEvent == nil]) "or no extra args available"			ifTrue:[^self synchronousValueWithArguments: arguments event: anEvent].	"Need some arguments from args"	args := arguments clone.	index := arguments size - extraArgs.	count := extraArgs min: anEvent arguments size.	args replaceFrom: index+1 to: index+count with: anEvent arguments startingAt: 1.	index := index + count.	index < args size ifTrue:[args at: index+1 put: anEvent].	^self synchronousValueWithArguments: args event: anEvent! !!ScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 8/22/2001 01:01'!value	^self value: #()! !!ScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 4/24/2002 12:33'!value: anEvent	^self valueWithEvent: anEvent! !!ScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 3/30/2003 01:30'!valueWithEvent: anEvent	^self synchronousValueWithEvent: anEvent! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 4/28/2002 16:32'!eventSpec	^eventSpec ifNil:[#()].! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 4/24/2002 15:43'!eventSpec: anArray	eventSpec := anArray! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 4/28/2002 00:49'!extraArgs	^extraArgs ifNil:[self computeExtraArgs].! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 9/23/2003 01:14'!myTrigger	^nil! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 2/24/2004 01:29'!pauseScript	"Stop notifications from event sources"	self isPaused ifTrue:[^self].	eventSpec ifNil:[^self].	1 to: eventSpec size by: 2 do:[:i|		(eventSpec at: i) on: (eventSpec at: i+1) unNotify: self.	].	paused := true.! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 2/24/2004 01:29'!resumeScript	"Resume notifications from event sources"	self isPaused ifFalse:[^self].	eventSpec ifNil:[^self].	1 to: eventSpec size by: 2 do:[:i|		(eventSpec at: i) on: (eventSpec at: i+1) notify: self.	].	paused := false.! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 4/24/2002 14:48'!runningScript	^nil! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 4/24/2002 17:06'!terminateScript	eventSpec ifNotNil:[		1 to: eventSpec size by: 2 do:[:i|			(eventSpec at: i) on: (eventSpec at: i+1) unNotify: self.		].		eventSpec := nil].	receiver privateRemoveScript: self.! !!ScriptMessageSend methodsFor: 'accessing' stamp: 'ar 2/24/2004 14:15'!wakeupScript	"Resume notifications from event sources"	eventSpec ifNil:[^self].	1 to: eventSpec size by: 2 do:[:i|		(eventSpec at: i) on: (eventSpec at: i+1) notify: self.	].	paused := false.! !!ScriptMessageSend methodsFor: 'testing' stamp: 'ar 2/6/2004 17:45'!isEventTriggered	"Am I triggered by some event?"	^eventSpec notNil and:[eventSpec size >= 2]! !!ScriptMessageSend methodsFor: 'testing' stamp: 'ar 9/23/2003 01:18'!isPaused	^paused == true! !!ScriptMessageSend methodsFor: 'testing' stamp: 'ar 4/24/2002 17:02'!isScriptDescriptorIn: aScript	^aScript == self! !!ScriptMessageSend methodsFor: 'testing' stamp: 'ar 3/23/2003 21:34'!isTickingScript	^false! !!ScriptMessageSend methodsFor: 'factory' stamp: 'ar 5/16/2002 22:11'!readArgumentsFrom: anArray	arguments := Array new: anArray size - 1.	2 to: anArray size do:[:idx|		arguments at: idx-1 put: (anArray at: idx).	].! !!ScriptMessageSend methodsFor: 'factory' stamp: 'ar 5/16/2002 22:10'!readEventsFrom: anArray	| index key value events rcvr sel evtSpec spec |	events := Array new: anArray size - 1 * 2.	index := 0.	2 to: anArray size do:[:idx|		spec := anArray at: idx.		key := spec first.		key == #event ifFalse:[self error:'#event expected'].		rcvr := sel := nil.		2 to: spec size do:[:i|			evtSpec := spec at: i.			key := evtSpec first.			value := evtSpec last.			key == #receiver ifTrue:[rcvr := value].			key == #selector ifTrue:[sel := value].		].		events at: (index := index + 1) put: rcvr.		events at: (index := index + 1) put: sel.	].	eventSpec := events! !!ScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 10/19/2003 13:54'!postBuildWith: aFactory	self computeExtraArgs.	eventSpec ifNil:[^self].	1 to: eventSpec size by: 2 do:[:i|			(eventSpec at: i) on: (eventSpec at: i+1) notify: self.	].! !!ScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/23/2003 01:19'!readFieldsFrom: deSerializer	super readFieldsFrom: deSerializer.	eventSpec := deSerializer readField: #eventSpec ifAbsent:[eventSpec].	extraArgs := deSerializer readField: #extraArgs ifAbsent:[extraArgs].	paused := deSerializer readField: #paused ifAbsent:[paused].! !!ScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/24/2003 18:02'!writeFieldsOn: aSerializer	extraArgs ifNil:[self computeExtraArgs].	super writeFieldsOn: aSerializer.	aSerializer writeField: #eventSpec value: eventSpec.	aSerializer writeField: #extraArgs value: extraArgs.	aSerializer writeField: #paused value: paused.! !!AsyncScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 4/24/2002 14:48'!runningScript	^myProcess! !!AsyncScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 5/20/2002 13:59'!scriptStopped: aScript	aScript == myProcess ifFalse:[self error:'must not happen'].	myProcess := nil.	myQueue := nil.	eventSpec ifNil:[self terminateScript].! !!AsyncScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 3/21/2004 19:40'!value	myQueue ifNil:[^nil].	^super valueWithEvent: myQueue next! !!AsyncScriptMessageSend methodsFor: 'evaluating' stamp: 'ar 2/26/2004 12:29'!valueWithEvent: anEvent	| myScript |	myQueue ifNil:[myQueue := ScriptEventBuffer new].	myQueue nextPut: anEvent."<--- this needs a test for whether the script is already executing --->"	myProcess ifNotNil:[^self]."<--- here we need to route the message to the scheduler --->"	myProcess := ScriptProcess newScript.	myProcess message: self.	myProcess owner: self.	myProcess setScheduler: myScheduler.	(myScript := Processor activeProcess) traceEvents ifTrue:[		myScript traceEvent: anEvent message: self script: myProcess.		myProcess eventTracer: myScript eventTracer.		myProcess traceEvents: true.	].	myProcess hand: myScript hand.	myProcess resume.	^myProcess! !!AsyncScriptMessageSend methodsFor: 'testing'!isRunning	^myProcess notNil! !!AsyncScriptMessageSend methodsFor: 'private' stamp: 'ar 8/5/2003 20:56'!myScripts	^myScripts ifNil:[#()]! !!AsyncScriptMessageSend methodsFor: 'private' stamp: 'ar 8/5/2003 20:56'!myScripts: newScripts	myScripts := newScripts! !!AsyncScriptMessageSend methodsFor: 'private' stamp: 'ar 2/7/2004 16:19'!myTrigger	^myTrigger! !!AsyncScriptMessageSend methodsFor: 'private' stamp: 'ar 2/7/2004 16:20'!myTrigger: aTrigger	myTrigger := aTrigger.! !!AsyncScriptMessageSend methodsFor: 'private' stamp: 'ar 2/18/2004 14:16'!onUpdateTrigger: newValue from: oldValue	eventSpec ifNil:[^self].	"This is pretty ugly ... but we really need to stop any message which may have been scheduled based on the old event spec"	myQueue := nil.	myProcess ifNotNil:[myProcess terminate].	(eventSpec at: 1) on: (eventSpec at: 2) unNotify: self.	eventSpec at: 1 put: newValue.	(eventSpec at: 1) on: (eventSpec at: 2) notify: self.! !!AsyncScriptMessageSend methodsFor: 'private' stamp: 'jh 5/5/2003 19:11'!requestStop	myProcess ifNotNil:[myProcess terminate]! !!AsyncScriptMessageSend methodsFor: 'private' stamp: 'ar 8/13/2003 22:59'!setDefaultScheduler	myScheduler := ScriptScheduler activeScheduler! !!AsyncScriptMessageSend methodsFor: 'accessing' stamp: 'ar 5/19/2002 23:50'!pauseScript	"Stop notifications from event sources"	super pauseScript.	myQueue := nil.! !!AsyncScriptMessageSend methodsFor: 'accessing' stamp: 'ar 5/19/2002 23:48'!terminateScript	Processor activeProcess == myProcess 		ifTrue:[^self startScript: #terminateScript].	super terminateScript.	myProcess ifNotNil:[		myProcess terminate.		myProcess := nil].! !!AsyncScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 11/17/2003 23:49'!postBuildWith: aMaker	super postBuildWith: aMaker.	self setDefaultScheduler.! !!AsyncScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/22/2003 01:09'!readFieldsFrom: deSerializer	super readFieldsFrom: deSerializer.	myTrigger := deSerializer readField: #trigger ifAbsent:[myTrigger].	myScripts := deSerializer readField: #scripts ifAbsent:[myScripts].	myScheduler := ScriptScheduler activeScheduler.! !!AsyncScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/21/2003 22:14'!writeFieldsOn: aSerializer	super writeFieldsOn: aSerializer.	aSerializer writeField: #trigger value: myTrigger.	aSerializer writeField: #scripts value: myScripts.! !!AsyncScriptMessageSend class methodsFor: 'instance creation' stamp: 'ar 6/11/2002 19:32'!receiver: anObject selector: aSymbol arguments: anArray	^ self new		receiver: anObject;		selector: aSymbol;		arguments: anArray;		setDefaultScheduler! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/9/2001 13:52'!clock	^scheduler! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 2/7/2004 16:21'!hand	^(self valueOfProperty: #hand) ifNil:[super hand]! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 2/7/2004 16:21'!hand: aHand	^self setProperty: #hand toValue: aHand! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/24/2001 20:43'!message	^message! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/24/2001 20:44'!message: aMessageSend	message _ aMessageSend! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 4/24/2002 15:10'!messageName	^message ifNotNil:[message selector]! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/16/2001 23:08'!owner	^owner! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/16/2001 23:08'!owner: anObject	owner _ anObject! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 4/24/2002 16:36'!processName	"For the process browser"	^String streamContents:[:s|		s nextPutAll: (self hash asString forceTo: 5 paddingStartWith: $ ).		s nextPutAll:' ['.		s nextPutAll: (self owner receiver printString contractTo: 50).		s nextPutAll:'>>'.		s nextPutAll: (self messageName ifNil:['???']).		s nextPut:$].	].! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 10/18/2002 22:09'!requestStop	"Request this script to be stopped"	flags := flags bitOr: FlagScriptStopRequest.! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/7/2001 15:31'!result	self waitUntil: #done.	^result! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/7/2001 15:31'!result: aValue	result _ aValue! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 7/7/2001 16:32'!scheduler	^scheduler! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 2/7/2004 16:21'!world	^(self valueOfProperty: #world) ifNil:[super world]! !!ScriptProcess methodsFor: 'accessing' stamp: 'ar 2/7/2004 16:22'!world: aPlayer	^self setProperty: #world toValue: aPlayer! !!ScriptProcess methodsFor: 'private' stamp: 'ar 6/11/2002 19:31'!newScript	suspendedContext := [		self privateRunMsg.		self suspend].	flags := 0.	priority := Processor initialScriptPriority.	scheduler ifNil:[scheduler := ScriptScheduler activeScheduler].! !!ScriptProcess methodsFor: 'private' stamp: 'ar 4/24/2002 14:26'!privateRunMsg	"Private. Evaluate the associated message."	self startScriptProcess.	result := message value. "if any"	self stopScriptProcess: result.! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 6/10/2002 20:15'!beginCritical: aSemaphore	self beginWait.! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 10/18/2002 22:09'!beginWait	"Signal the beginning of a wait cycle"	| time started |	(flags bitAnd: FlagScriptSignalWait) = 0 ifFalse:[		time _ Time millisecondClockValue.		(flags bitAnd: FlagScriptSignalResume) = 0 			ifTrue:[started _ time]			ifFalse:[started _ self valueOfProperty: #startTime ifAbsent:[time]].		self signal: #waiting with: time with: (time - started)].! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 6/10/2002 20:16'!beginWaitOn: aSemaphore	self beginWait.! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 9/21/2003 23:03'!endCritical: aSemaphore	scheduler ifNil:[^self].	(self isActiveScript)		ifFalse:[scheduler activeList primitiveWait].	self endWait.! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 10/18/2002 22:07'!endWait	"Signal the ending of a wait cycle"	| time |	(flags bitAnd: FlagScriptSignalResume) = 0 ifFalse:[		time _ Time millisecondClockValue.		(flags bitAnd: FlagScriptSignalWait) = 0 ifFalse:[self setProperty: #startTime toValue: time].		self signal: #resuming with: time].! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 6/10/2002 20:16'!endWaitOn: aSemaphore	"Resynchronize the receiver with the scheduler."	(self isActiveScript)		ifFalse:[scheduler activeList primitiveWait].	"Note: The reason for not resynchronizing when we're the active script is so that certain 'atomic' notions can be preserved. E.g., when we enter a signaled semaphore, the script should _not_ be rescheduled at the end of the scheduler since the meaning of entering a signaled semaphore is non-preemptive."	self endWait.	^nil! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 7/20/2001 18:56'!eventHandlerFor: anEvent	^self nextEventHandlerFor: anEvent sender selector: anEvent selector! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 4/23/2002 19:54'!passEvent: anEvent	myHandler ifNotNil:[myHandler passEvent: anEvent].! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 2/18/2002 21:54'!primitiveWaitUntil: eventName	(eventName == #started and:[self isStarted]) ifTrue:[^self].	(eventName == #done and:[self isDone]) ifTrue:[^self].	^super primitiveWaitUntil: eventName.! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 2/13/2002 18:22'!transferTo: aList	"Transfer the receiver to another list to wait on"	myList ifNil:[self error:'Not on any list'].	myList remove: self.	aList addLast: self.	myList := aList.! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 2/15/2002 15:01'!waitProcessOn: aWaitable	"Wait on the given waitable object (Semaphore or Delay).	Resynchronize with the scheduler when the wait completed."	self == Processor activeProcess ifFalse:[^self error:'Not the active process'].	self beginWait.	"Boost this scripts priority for the wait. This is necessary in order to keep both, scripts newly triggered (forked) by an event and those waiting for some event in the right order (e.g., without the boost a waiting script may run _after_ one that was 'created later' based on the same event)."	priority := Processor initialScriptPriority.	aWaitable primitiveWait.	priority := Processor userScriptPriority.	"Note: It is not necessary to yield here - scripts are _always_ synchronized so either the wait completed synchronuously in which case it will continue anyways. If not, then the following the scheduler wait will solve the problem for us."	"Resynchronize the receiver with the scheduler."	(self isActiveScript)		ifFalse:[scheduler activeList primitiveWait].	"Note: The reason for not resynchronizing when we're the active script is so that certain 'atomic' notions can be preserved. E.g., when we enter a signaled semaphore, the script should _not_ be rescheduled at the end of the scheduler since the meaning of entering a signaled semaphore is non-preemptive."	self endWait.	^nil! !!ScriptProcess methodsFor: 'synchronization' stamp: 'ar 7/7/2001 15:19'!waitUntil: eventName	(eventName == #started and:[self isStarted]) ifTrue:[^self].	(eventName == #done and:[self isDone]) ifTrue:[^self].	^super waitUntil: eventName.! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 7/24/2001 20:03'!myEventMap	^myEventMap! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 7/24/2001 20:03'!myEventMap: aDictionary	myEventMap _ aDictionary.! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 4/23/2002 19:52'!nextEventHandlerFor: anObject selector: eventName	^self nextEventHandlerFor: anObject selector: eventName startingAt: myHandler! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 4/23/2002 19:51'!nextEventHandlerFor: anObject selector: eventName startingAt: observer	"Find an return the enclosing event handler scope for the object/event pair. This method should be really fast; right now we're just searching the entire chain (which is bad) - we need something that's fast for the innermost event handler."	| next |	next _ observer.	[next == nil] whileFalse:[		(next signaler == anObject and:[next selector == eventName]) ifTrue:[^next].		next _ next nextHandler.	].	^nil! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 4/23/2002 19:44'!observe: eventSpec	^self observe: eventSpec semaphore: nil buffer: nil! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 4/23/2002 19:44'!observe: eventSpec semaphore: aSemaphore	^self observe: eventSpec semaphore: aSemaphore buffer: nil! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 4/24/2002 15:22'!observe: eventSpec semaphore: aSemaphore buffer: aBuffer	"Install a observer for each event specified in the event spec.	If a semaphore and buffer are provided, use those.	This method will return the outermost handler (that is the one created	for the first event) so that it's easy for the sender to release an entire	chain of handlers."		| sema anObject eventName handler topHandler |	topHandler _ nil.	sema _ aSemaphore ifNil:[Semaphore new].	1 to: eventSpec size // 2 do:[:i|		anObject _ eventSpec at: 2*i-1.		eventName _ eventSpec at: 2*i.		handler := ScriptEventObserver new.		topHandler ifNil:[topHandler _ handler].		handler semaphore: sema.		handler buffer: aBuffer."@@@ do we _really_ need the object/eventName pair here??? @@@"		handler signaler: anObject.		handler selector: eventName.		anObject on: eventName notify: handler.		handler resumeSuspending: 			(self nextEventHandlerFor: anObject selector: eventName).		handler nextHandler: myHandler.		myHandler _ handler].	^topHandler! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 4/23/2002 19:32'!observe: eventSpec semaphore: aSemaphore buffer: aBuffer during: aBlock	| handler |	handler := self observe: eventSpec semaphore: aSemaphore buffer: aBuffer.	^[aBlock value: handler] 		ensure:[myHandler := handler releaseTo: handler nextHandler].! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 10/18/2002 22:07'!on: eventName notify: anObserver	eventName == #waiting ifTrue:[flags _ flags bitOr: FlagScriptSignalWait].	eventName == #resuming ifTrue:[flags _ flags bitOr: FlagScriptSignalResume].	^super on: eventName notify: anObserver! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 4/23/2002 19:48'!releaseObserver: aHandler	myHandler := myHandler releaseTo: aHandler nextHandler.! !!ScriptProcess methodsFor: 'private-events' stamp: 'ar 10/18/2002 22:08'!removeEvent: eventName map: eventMap	super removeEvent: eventName map: eventMap.	(eventName == #waiting) 		ifTrue:[flags _ flags bitClear: FlagScriptSignalWait].	(eventName == #resuming) 		ifTrue:[flags _ flags bitClear: FlagScriptSignalResume].! !!ScriptProcess methodsFor: 'event trace' stamp: 'ar 5/17/2002 20:18'!eventTracer	^self valueOfProperty: #eventTracer! !!ScriptProcess methodsFor: 'event trace' stamp: 'ar 5/17/2002 20:18'!eventTracer: aTracer	^self setProperty: #eventTracer toValue: aTracer! !!ScriptProcess methodsFor: 'event trace' stamp: 'ar 5/17/2002 20:38'!traceEvent: anEvent message: aMessage script: aScript	^self eventTracer traceEvent: anEvent message: aMessage script: aScript from: self! !!ScriptProcess methodsFor: 'event trace' stamp: 'ar 10/18/2002 22:08'!traceEvents	^(flags bitAnd: FlagScriptTraceEvents) == FlagScriptTraceEvents! !!ScriptProcess methodsFor: 'event trace' stamp: 'ar 10/18/2002 22:07'!traceEvents: aBool	flags := aBool ifTrue:[flags bitOr: FlagScriptTraceEvents] ifFalse:[flags bitClear: FlagScriptTraceEvents].! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 7/9/2001 17:20'!isActive	^scheduler isScriptActive: self.! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 2/15/2002 14:57'!isActiveScript	^scheduler activeScript == self and:[scheduler isActiveScheduler]! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 10/18/2002 22:06'!isDone	^(flags bitAnd: FlagScriptDone) == FlagScriptDone! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 7/9/2001 17:15'!isScheduled	^myLink notNil! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 2/17/2002 19:12'!isScript	^true! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 7/7/2001 15:30'!isScriptingProcess	^true! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 10/18/2002 22:08'!isStarted	^(flags bitAnd: FlagScriptStarted) == FlagScriptStarted! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 10/18/2002 22:10'!isStopRequested	^(flags bitAnd: FlagScriptStopRequest) == FlagScriptStopRequest! !!ScriptProcess methodsFor: 'testing' stamp: 'ar 9/9/2002 03:12'!isSystemProcess	^false! !!ScriptProcess methodsFor: 'properties' stamp: 'ar 7/20/2001 22:41'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	properties == nil ifTrue: [^ false].	prop _ properties at: propName ifAbsent: [nil].	prop == nil ifTrue: [^ false].	prop == false ifTrue: [^ false].	^ true! !!ScriptProcess methodsFor: 'properties' stamp: 'ar 10/20/2002 15:44'!removeProperty: propName	| value |	properties == nil ifTrue: [^ nil].	value := properties removeKey: propName ifAbsent: [].	properties size == 0 ifTrue: [properties _ nil].	^value! !!ScriptProcess methodsFor: 'properties' stamp: 'ar 7/20/2001 22:42'!setProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	properties == nil ifTrue: [properties _ IdentityDictionary new].	properties at: propName put: aValue.! !!ScriptProcess methodsFor: 'properties' stamp: 'ar 7/20/2001 22:42'!valueOfProperty: propName 	^ self valueOfProperty: propName ifAbsent: [nil]! !!ScriptProcess methodsFor: 'properties' stamp: 'ar 7/20/2001 22:42'!valueOfProperty: propName ifAbsent: aBlock	properties == nil ifTrue: [^ aBlock value].	^ properties at: propName ifAbsent: [^ aBlock value]! !!ScriptProcess methodsFor: 'initialize-release' stamp: 'ar 5/17/2002 20:00'!setScheduler: aUserScriptScheduler	scheduler _ aUserScriptScheduler.! !!ScriptProcess methodsFor: 'initialize-release' stamp: 'ar 10/18/2002 22:07'!startScriptProcess	"Activate the receiver in the context of the (already provided) user script scheduler."	myLink _ scheduler scheduleScript: self.	"Note: From here on we are synchronized with the scheduler."	priority _ Processor userScriptPriority. "See comment in ProcessorScheduler>>initialScriptPriority"	flags _ flags bitOr: FlagScriptStarted.	myEventMap ifNotNil:[self signal: #started].	self endWait.! !!ScriptProcess methodsFor: 'initialize-release' stamp: 'ar 10/18/2002 22:08'!stopScriptProcess: resultObj	"Finish the receiver in the context of the user script scheduler."	self beginWait.	result _ resultObj.	flags _ flags bitOr: FlagScriptDone.	owner ifNotNil:[owner scriptStopped: self].	myHandler ifNotNil:[myHandler releaseTo: nil].	myEventMap ifNotNil:[self signal: #done with: resultObj].	myLink ifNotNil:[scheduler unscheduleScript: myLink].	myLink _ nil.! !!ScriptProcess methodsFor: 'initialize-release' stamp: 'ar 7/21/2001 23:30'!terminate	self isDone ifTrue:[^self].	self stopScriptProcess: nil.	super terminate.! !!ScriptProcess methodsFor: 'printing' stamp: 'ar 4/24/2002 17:22'!printOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: ' in '.	(self messageName notNil and:[self owner notNil]) ifTrue:[		aStream print: self owner; nextPutAll:'>>'; nextPutAll: self messageName.	] ifFalse:[		suspendedContext printOn: aStream.	].! !!ScriptProcess methodsFor: 'converting' stamp: 'ar 4/24/2002 14:48'!isScriptDescriptorIn: aScript	^aScript runningScript == self! !!ScriptProcess class methodsFor: 'class initialization' stamp: 'ar 10/18/2002 22:09'!initialize	"ScriptProcess initialize"	FlagScriptStarted := 1.	FlagScriptDone := 2.	FlagScriptSignalWait := 4.	FlagScriptSignalResume := 8.	FlagScriptTraceEvents := 16.	FlagScriptStopRequest := 32.! !!ScriptProcess class methodsFor: 'instance creation' stamp: 'ar 4/24/2002 14:16'!newScript	^self new newScript! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 7/14/2001 16:38'!nextLink	^nextLink! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 7/14/2001 16:38'!nextLink: aLink	nextLink _ aLink! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 7/14/2001 16:38'!prevLink	^prevLink! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 7/14/2001 16:38'!prevLink: aLink	prevLink _ aLink! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 4/23/2002 21:14'!process	^self subclassResponsibility! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 4/23/2002 21:14'!process: aProcess	^self subclassResponsibility! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 2/16/2002 20:53'!value	^self process! !!ScriptProcessLink methodsFor: 'accessing' stamp: 'ar 4/23/2002 21:11'!value: aProcess	^self process: aProcess! !!ScriptProcessLink class methodsFor: 'instance creation' stamp: 'ar 4/23/2002 21:13'!on: aProcess	^self new process: aProcess! !!ScriptProcessLink class methodsFor: 'instance creation' stamp: 'ar 4/23/2002 21:14'!strongOn: aProcess	^ScriptProcessLinkStrong new process: aProcess! !!ScriptProcessLink class methodsFor: 'instance creation' stamp: 'ar 4/23/2002 21:15'!weakOn: aProcess	^(ScriptProcessLinkWeak new: 1) process: aProcess! !!ScriptProcessLinkStrong methodsFor: 'accessing' stamp: 'ar 4/23/2002 21:13'!process	^process! !!ScriptProcessLinkStrong methodsFor: 'accessing' stamp: 'ar 4/23/2002 21:13'!process: aProcess	process := aProcess! !!ScriptProcessLinkWeak methodsFor: 'accessing' stamp: 'ar 4/23/2002 21:15'!process	^self at: 1! !!ScriptProcessLinkWeak methodsFor: 'accessing' stamp: 'ar 4/23/2002 21:15'!process: aProcess	self at: 1 put: aProcess! !!ScriptProcessLinkWeak class methodsFor: 'instance creation' stamp: 'ar 4/23/2002 21:13'!new	^self new: 1! !!ScriptProcessLinkWeak class methodsFor: 'instance creation' stamp: 'ar 4/23/2002 21:13'!on: aProcess	^(self new: 1) at: 1 put: aProcess; yourself! !!ScriptScheduler methodsFor: 'accessing' stamp: 'ar 7/14/2001 00:03'!activeList	^activeList! !!ScriptScheduler methodsFor: 'accessing' stamp: 'ar 7/14/2001 00:04'!activeScript	^activeScript! !!ScriptScheduler methodsFor: 'accessing'!myTickEvent	^myTickEvent! !!ScriptScheduler methodsFor: 'accessing'!scheduledScripts	^Array streamContents:[:s|		self scheduledScriptsDo:[:p| s nextPut: p].	].! !!ScriptScheduler methodsFor: 'accessing' stamp: 'ar 2/13/2002 18:16'!syncList	"Return the list used for serializing asynchronous scripts. This list is used for scripts triggering async events that need to be responded to synchronously."	^syncList ifNil:[syncList := Semaphore new].! !!ScriptScheduler methodsFor: 'accessing' stamp: 'ar 3/14/2003 04:29'!tickEvent	^myTickEvent clone! !!ScriptScheduler methodsFor: 'accessing' stamp: 'ar 7/16/2001 23:36'!tickTime	^tickTime! !!ScriptScheduler methodsFor: 'accessing' stamp: 'ar 7/20/2001 13:53'!tickingList	"Return the list into which objects can put themselves to wait for a single tick. This list is exposed because deep call chains can be very inefficient when waiting for many ticks. The ticking list should be used primitively, e.g., by calling 'self clock tickingList primitiveWait'."	^tickList! !!ScriptScheduler methodsFor: 'testing' stamp: 'ar 2/15/2002 14:42'!isActiveScheduler	^self == ActiveScheduler! !!ScriptScheduler methodsFor: 'testing' stamp: 'ar 7/14/2001 00:04'!isEmpty	^activeList isEmpty and:[scheduledList == nil]! !!ScriptScheduler methodsFor: 'testing' stamp: 'ar 7/14/2001 00:04'!isScriptActive: aScript	^aScript suspendingList == activeList! !!ScriptScheduler methodsFor: 'testing' stamp: 'ar 8/21/2001 23:33'!isScriptScheduler	"Yes. I am."	^true! !!ScriptScheduler methodsFor: 'event handling' stamp: 'ar 7/14/2001 00:05'!myEventMap	^myEventMap! !!ScriptScheduler methodsFor: 'event handling' stamp: 'ar 7/14/2001 00:05'!myEventMap: aDictionary	myEventMap _ aDictionary! !!ScriptScheduler methodsFor: 'event handling' stamp: 'ar 2/18/2002 21:55'!primitiveWaitUntil: eventName	eventName == #tick ifTrue:[^self waitTick].	^super primitiveWaitUntil: eventName! !!ScriptScheduler methodsFor: 'event handling' stamp: 'ar 7/20/2001 19:00'!waitUntil: eventName	eventName == #tick ifTrue:[^self waitTick].	^super waitUntil: eventName! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 6/11/2002 19:38'!addLink: link toList: aList	link nextLink: aList.	aList ifNotNil:[aList prevLink: link].	^link! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 2/18/2002 00:54'!debugPrintActive	"ActiveHand lastEvent shiftPressed ifTrue:[Transcript cr; show: activeScript]."! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/14/2001 00:04'!freePendingScripts	"Free any pending scripts that have been asynchronously released"	interruptProtect critical:[		scheduledList _ self removeLinksWithValue: nil from: scheduledList.		pending _ false].! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 5/20/2002 17:26'!proceedActiveScripts	"Proceed running all active scripts in the current time slot.	NOTE: This is a hack we currently need in order to deal with layout changes accordingly."	"Prevent recursive calls to the scheduler.	We need this since there are still callers of #doOneCycle"	Processor activeProcess == activeScript ifTrue:[^self].	"If any scripts need to be released, release them now"	pending ifTrue:[self freePendingScripts].	"Prepare for the next cycle of processing scripts"	ActiveSchedulerProcess _ Processor activeProcess.	ActiveScheduler _ self.	["Process any pending scripts that may have started in the mean time"	[(activeScript _ activeList firstOrNil) == nil]		whileFalse:[self debugPrintActive. activeList signal].	"Process synchronously waiting scripts in REVERSE order"	syncList isEmpty] whileFalse:[syncList last transferTo: activeList].! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 6/11/2002 19:40'!removeLink: aLink fromList: aList	| newHead |	newHead := aList.	aLink prevLink == nil		ifTrue:[newHead := aLink nextLink]		ifFalse:[newHead := aList.				aLink prevLink nextLink: aLink nextLink].	aLink nextLink == nil		ifFalse:[aLink nextLink prevLink: aLink prevLink].	^newHead! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 6/11/2002 19:40'!removeLinkSuchThat: aBlock from: aList	| newHead next prev |	newHead := next := aList.	prev := nil.	[next == nil] whileFalse:[		(aBlock value: next) 			ifTrue:[next := next nextLink]			ifFalse:[prev := next. next := nil]].	newHead := prev ifNil:[^nil].	next := prev nextLink.	[next == nil] whileFalse:[		(aBlock value: next) ifTrue:[			prev nextLink: next nextLink.			prev nextLink ifNotNil:[prev nextLink prevLink: prev].			next _ next nextLink.		] ifFalse:[			prev := next.			next := next nextLink.		].	].	^newHead! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 6/11/2002 19:39'!removeLinksWithValue: value from: aList	"Remove all links with the given value from aList. 	Return the new head of the list"	| newHead next prev |	newHead := next := aList.	prev := nil.	[next == nil] whileFalse:[		(next value == value) 			ifTrue:[next := next nextLink]			ifFalse:[prev := next. next := nil]].	newHead := prev ifNil:[^nil].	next := prev nextLink.	[next == nil] whileFalse:[		(next value == value) ifTrue:[			prev nextLink: next nextLink.			prev nextLink ifNotNil:[prev nextLink prevLink: prev].			next := next nextLink.		] ifFalse:[			prev := next.			next := next nextLink.		].	].	^newHead! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 4/24/2002 15:06'!removeLinksWithValue: value from: aList andDo: aBlock	"Remove all links with the given value from aList. 	Return the new head of the list"	| newHead next prev val |	newHead := next := aList.	prev := nil.	[next == nil] whileFalse:[		((val := next value) == value) 			ifTrue:[next := next nextLink]			ifFalse:[prev := next. next := nil. aBlock value: val]].	newHead := prev ifNil:[^nil].	next := prev nextLink.	[next == nil] whileFalse:[		((val := next value) == value) ifTrue:[			prev nextLink: next nextLink.			prev nextLink ifNotNil:[prev nextLink prevLink: prev].			next := next nextLink.		] ifFalse:[			prev := next.			next := next nextLink.			aBlock value: val.		].	].	^newHead! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/14/2001 00:04'!resumeScript: aUserScript	"Resume the given user script"	aUserScript == Processor activeProcess 		ifTrue:[^self error:'Can only resume inactive scripts'].	aUserScript setScheduler: self.	aUserScript resume.! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 5/24/2004 13:48'!runActiveScripts	"Run all active scripts in the current time slot"	| toTick |	"Prevent recursive calls to the scheduler.	We need this since there are still callers of #doOneCycle"	Processor activeProcess == activeScript ifTrue:[^self].	"If any scripts need to be released, release them now"	pending ifTrue:[self freePendingScripts].	"Prepare for the next cycle of processing scripts"	ActiveSchedulerProcess _ Processor activeProcess.	ActiveScheduler _ self.	tickTime _ Time millisecondClockValue.	myTickEvent setArguments: (Array with: tickTime).	toTick _ tickList.	tickList _ Semaphore new.	"Process pending active scripts first. This is so the 'main' UI process can spawn the redraw and the event processing script which should be processed before any tickers."	[(activeScript _ activeList firstOrNil) == nil]		whileFalse:[self debugPrintActive. activeList signal].	"Process all intrinsic tickers; this is equivalent to sending the #tick for objects registered with the tick list."	[(activeScript _ toTick firstOrNil) == nil] 		whileFalse:[self debugPrintActive. toTick signal].	"But also signal #tick explicitly in case we have some additional dependents"	self signalEvent: myTickEvent clone.	["Process any scripts that may have started in the mean time"	[(activeScript _ activeList firstOrNil) == nil]		whileFalse:[self debugPrintActive. activeList signal].	"Process synchronously waiting scripts in REVERSE order"	syncList isEmpty] whileFalse:[syncList last transferTo: activeList].! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 4/23/2002 21:16'!scheduleScript: aUserScript	| link |	aUserScript == Processor activeProcess		ifFalse:[^self error:'Can only schedule the active script'].	aUserScript isScheduled		ifTrue:[self error:'This script is already scheduled'].	aUserScript == activeScript ifFalse:[activeList primitiveWait].	"now we're in sync with the scheduler"	link := ScriptProcessLink weakOn: aUserScript.	scheduledList := self addLink: link toList: scheduledList.	self signal: #scheduleScript with: aUserScript.	^link! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/20/2001 22:00'!scheduledScriptsDo: aBlock	"Evaluate aBlock for all scripts scheduled in the receiver."	| link |	link _ scheduledList.	[link == nil] whileFalse:[		link process == nil ifFalse:[aBlock value: link process].		link _ link nextLink.	].! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/17/2001 17:54'!scriptsDo: aBlock	"Evaluate aBlock for all scripts associated with the receiver.	NOTE: Some scripts may never have been activated before.	Because of this they are not (yet) in the scheduled list but	waiting on the active list to be scheduled. To enumerate these	scripts as well we need to check the processes waiting in the	active list for any that have not been started yet."	| link |	link _ scheduledList.	[link == nil] whileFalse:[		link process == nil ifFalse:[aBlock value: link process].		link _ link nextLink.	].	link _ activeList firstOrNil.	[link == nil] whileFalse:[		link isStarted ifFalse:[aBlock value: link].		link _ link nextLink].! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/14/2001 00:05'!terminateScript: aUserScript	aUserScript terminate.! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/20/2001 21:32'!tick	^self runActiveScripts! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/22/2001 00:56'!unscheduleScript: aLink	"May be called asynchronously, e.g., when explicitly terminating scripts	from debugger etc. Need to make sure we don't interfere with	scheduledLists activity"	self signal: #unscheduleScript with: aLink process.	interruptProtect critical:[		pending _ true.		aLink process: nil.	].! !!ScriptScheduler methodsFor: 'scheduling' stamp: 'ar 7/21/2001 16:52'!waitTick	| script |	script _ Processor activeProcess.	self flag: #waitProcessOn:. "But subtly different since tickList is synchronized"	script beginWait.	tickList primitiveWait.	script endWait.	^myTickEvent clone! !!ScriptScheduler methodsFor: 'initialize' stamp: 'ar 6/11/2002 19:36'!initialize	activeList _ Semaphore new.	syncList := Semaphore new.	scheduledList := nil.	pending := false.	interruptProtect := Semaphore forMutualExclusion.	myTickEvent := ScriptEvent new setSender: self selector: #tick arguments: {0. 0}.	myEventMap := nil.	tickTime := Time millisecondClockValue.	tickList := Semaphore new.	ActiveScheduler ifNil:[ActiveScheduler := self].! !!ScriptScheduler methodsFor: 'initialize' stamp: 'ar 2/14/2003 20:25'!shutDown	"Shut down the receiver"	Processor activeProcess isScriptingProcess ifTrue:[		[self shutDown] forkAt: Processor userSchedulingPriority.	].	self scheduledScriptsDo:[:script| script terminate].	self == ActiveScheduler ifTrue:[		ActiveScheduler _ nil.		ActiveSchedulerProcess _ nil.	].! !!ScriptScheduler methodsFor: '*Tweak' stamp: 'ar 10/19/2003 19:56'!hasActiveScripts	"Answer whether the scheduler has any active scripts which need to be run"	activeList isEmpty ifFalse:[^true].	tickList isEmpty ifFalse:[^true].	^self handlesEvent: #tick! !!ScriptScheduler methodsFor: '*Tweak' stamp: 'ar 9/18/2003 02:19'!serializeOn: aSerializer	^aSerializer writeProhibited: self! !!ScriptScheduler class methodsFor: 'accessing' stamp: 'ar 7/14/2001 00:03'!activeScheduler	^ActiveScheduler! !!ScriptScheduler class methodsFor: 'accessing' stamp: 'ar 7/14/2001 00:03'!activeSchedulerProcess	^ActiveSchedulerProcess! !!ScriptScheduler class methodsFor: 'accessing' stamp: 'ar 7/14/2001 00:03'!activeScript	^ActiveScheduler ifNotNil:[ActiveScheduler activeScript]! !!ScriptScheduler class methodsFor: 'accessing' stamp: 'ar 7/14/2001 00:03'!activeSuspendedContext	| script |	script _ self activeScript.	^script ifNotNil:[script suspendedContext]! !!ScriptScheduler class methodsFor: 'instance creation' stamp: 'ar 7/14/2001 00:03'!new	^super new initialize.! !!Semaphore methodsFor: '*Scripting-override' stamp: 'ar 3/6/2002 00:53'!critical: mutuallyExcludedBlock			 	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue process |	process := Processor activeProcess.	process isSystemProcess ifFalse:[process beginCritical: self].	self primitiveWait.	[blockValue _ mutuallyExcludedBlock value]		ensure: [self signal].	process isSystemProcess ifFalse:[process endCritical: self].	^blockValue! !!Semaphore methodsFor: '*Scripting-override' stamp: 'ar 3/6/2002 00:56'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue process |	process := Processor activeProcess.	process isSystemProcess ifFalse:[process beginCritical: self].	self primitiveWait.	[ [blockValue _ mutuallyExcludedBlock value] ifCurtailed: terminationBlock ]		ensure: [self signal].	process isSystemProcess ifFalse:[process endCritical: self].	^blockValue! !!Semaphore methodsFor: '*Scripting-override' stamp: 'ar 3/6/2002 00:54'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr process |	process := Processor activeProcess.	process isSystemProcess ifFalse:[process beginCritical: self].	self primitiveWait.	hasError _ false.	blockValue _ [mutuallyExcludedBlock value] ifError:[:msg :rcvr|		hasError _ true.		errMsg _ msg.		errRcvr _ rcvr].	hasError ifTrue:[		self signal.		^errorBlock value: errMsg value: errRcvr].	self signal.	process isSystemProcess ifFalse:[process endCritical: self].	^blockValue! !!Semaphore methodsFor: '*Scripting-override' stamp: 'ar 3/4/2002 12:42'!primitiveWait	"Primitive. The active Process must receive a signal through the receiver 	before proceeding. If no signal has been sent, the active Process will be 	suspended until one is sent. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 86>	self primitiveFailed	"excessSignals>0  		ifTrue: [excessSignals _ excessSignals-1]  		ifFalse: [self addLastLink: Processor activeProcess suspend]"! !!Semaphore methodsFor: '*Scripting-override' stamp: 'ar 3/6/2002 00:44'!wait	"The active Process must receive a signal through the receiver 	before proceeding. If no signal has been sent, the active Process will be 	suspended until one is sent. Essential. See Object documentation 	whatIsAPrimitive."	| process |	(process := Processor activeProcess) isSystemProcess		ifTrue:[^self primitiveWait].	process beginWaitOn: self.	self primitiveWait.	process endWaitOn: self.! !!SharedQueue methodsFor: '*Scripting-override' stamp: 'ar 2/7/2002 11:54'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	| value any |	[readSynch wait.	any := false.	accessProtect critical: [		"Note: readPosition = writePosition used to raise an error but this is not necessarily correct if some other client has flushed or otherwise modified the queue. Rather than failing we simply record the fact the we didn't have an element and keep waiting."		readPosition < writePosition ifTrue:[			any := true.			value _ contentsArray at: readPosition.			contentsArray at: readPosition put: nil.			readPosition _ readPosition + 1]].	any] whileFalse.	^value! !!Symbol methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 12:08'!asAsyncScriptMessageIn: scriptPerformer arguments: args	"Convert the receiver into an appropriate ScriptMessageSend"	^AsyncScriptMessageSend receiver: scriptPerformer selector: self arguments: args! !!Symbol methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 15:41'!asEventSpecificationIn: owner	^Array with: owner with: self! !!Symbol methodsFor: '*Scripting-Extensions' stamp: 'ar 7/24/2001 21:18'!asScriptMessageIn: scriptPerformer arguments: args	"Convert the receiver into an appropriate ScriptMessageSend"	^ScriptMessageSend receiver: scriptPerformer selector: self arguments: args! !!Symbol methodsFor: '*Scripting-Extensions' stamp: 'ar 2/6/2004 17:46'!asTickMessageIn: scriptPerformer arguments: args	"Convert the receiver into an appropriate ScriptMessageSend"	^TickMessageSend receiver: scriptPerformer selector: self arguments: args! !!Symbol methodsFor: '*Scripting-Extensions' stamp: 'ar 4/24/2002 14:49'!isScriptDescriptorIn: aScript	^aScript selector == self! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 3/15/2003 18:48'!frequency	^frequency! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 3/15/2003 18:48'!frequency: aFrequency	frequency := aFrequency.! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 3/15/2003 18:56'!myProcess	^myProcess! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 3/15/2003 18:57'!myProcess: aProcess	myProcess := aProcess.! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 8/15/2003 01:42'!myTrigger	^myTrigger! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 8/15/2003 01:42'!myTrigger: aTrigger	myTrigger := aTrigger! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 3/23/2003 21:55'!pauseScript	myProcess ifNotNil:[		myProcess terminateScript.		myProcess := nil.	].	super pauseScript.! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 3/23/2003 21:57'!resumeScript	super resumeScript.	myProcess ifNil:[		myProcess := receiver startScript: #runTicking:at: withArguments:{self. frequency}.		myProcess := myProcess message.	].! !!TickMessageSend methodsFor: 'accessing' stamp: 'ar 3/15/2003 18:47'!terminateScript	self pauseScript.	super terminateScript.! !!TickMessageSend methodsFor: 'testing' stamp: 'ar 3/23/2003 21:33'!isTickingScript	^true! !!TickMessageSend methodsFor: '*Tweak' stamp: 'ar 9/22/2003 01:11'!readFieldsFrom: deSerializer	super readFieldsFrom: deSerializer.	myTrigger := deSerializer readField: #trigger ifAbsent:[myTrigger].	frequency := deSerializer readField: #frequency ifAbsent:[frequency].! !!TickMessageSend methodsFor: '*Tweak' stamp: 'ar 9/21/2003 22:17'!writeFieldsOn: aSerializer	super writeFieldsOn: aSerializer.	aSerializer writeField: #trigger value: myTrigger.	aSerializer writeField: #frequency value: frequency.! !!TickMessageSend class reorganize!('as yet unclassified')!!TickMessageSend reorganize!('accessing' frequency frequency: myProcess myProcess: myTrigger myTrigger: pauseScript resumeScript terminateScript)('testing' isTickingScript)('*Tweak' readFieldsFrom: writeFieldsOn:)!!ScriptScheduler class reorganize!('accessing' activeScheduler activeSchedulerProcess activeScript activeSuspendedContext)('instance creation' new)!!ScriptScheduler reorganize!('accessing' activeList activeScript myTickEvent scheduledScripts syncList tickEvent tickTime tickingList)('testing' isActiveScheduler isEmpty isScriptActive: isScriptScheduler)('event handling' myEventMap myEventMap: primitiveWaitUntil: waitUntil:)('scheduling' addLink:toList: debugPrintActive freePendingScripts proceedActiveScripts removeLink:fromList: removeLinkSuchThat:from: removeLinksWithValue:from: removeLinksWithValue:from:andDo: resumeScript: runActiveScripts scheduleScript: scheduledScriptsDo: scriptsDo: terminateScript: tick unscheduleScript: waitTick)('initialize' initialize shutDown)('*Tweak' hasActiveScripts serializeOn:)!!ScriptProcessLinkWeak class reorganize!('instance creation' new on:)!!ScriptProcessLinkWeak reorganize!('accessing' process process:)!!ScriptProcessLinkStrong class reorganize!('as yet unclassified')!!ScriptProcessLinkStrong reorganize!('accessing' process process:)!!ScriptProcessLink class reorganize!('instance creation' on: strongOn: weakOn:)!!ScriptProcessLink reorganize!('accessing' nextLink nextLink: prevLink prevLink: process process: value value:)!ScriptProcess initialize!!ScriptProcess class reorganize!('class initialization' initialize)('instance creation' newScript)!!ScriptProcess reorganize!('accessing' clock hand hand: message message: messageName owner owner: processName requestStop result result: scheduler world world:)('private' newScript privateRunMsg)('synchronization' beginCritical: beginWait beginWaitOn: endCritical: endWait endWaitOn: eventHandlerFor: passEvent: primitiveWaitUntil: transferTo: waitProcessOn: waitUntil:)('private-events' myEventMap myEventMap: nextEventHandlerFor:selector: nextEventHandlerFor:selector:startingAt: observe: observe:semaphore: observe:semaphore:buffer: observe:semaphore:buffer:during: on:notify: releaseObserver: removeEvent:map:)('event trace' eventTracer eventTracer: traceEvent:message:script: traceEvents traceEvents:)('testing' isActive isActiveScript isDone isScheduled isScript isScriptingProcess isStarted isStopRequested isSystemProcess)('properties' hasProperty: removeProperty: setProperty:toValue: valueOfProperty: valueOfProperty:ifAbsent:)('initialize-release' setScheduler: startScriptProcess stopScriptProcess: terminate)('printing' printOn:)('converting' isScriptDescriptorIn:)!!AsyncScriptMessageSend class reorganize!('instance creation' receiver:selector:arguments:)!!ScriptMessageSend class reorganize!('as yet unclassified')!!AsyncScriptMessageSend reorganize!('evaluating' runningScript scriptStopped: value valueWithEvent:)('testing' isRunning)('private' myScripts myScripts: myTrigger myTrigger: onUpdateTrigger:from: requestStop setDefaultScheduler)('accessing' pauseScript terminateScript)('*Tweak' postBuildWith: readFieldsFrom: writeFieldsOn:)!!ScriptMessageSend reorganize!('evaluating' computeExtraArgs noticeEvent: synchronousValueWithArguments:event: synchronousValueWithEvent: value value: valueWithEvent:)('accessing' eventSpec eventSpec: extraArgs myTrigger pauseScript resumeScript runningScript terminateScript wakeupScript)('testing' isEventTriggered isPaused isScriptDescriptorIn: isTickingScript)('factory' readArgumentsFrom: readEventsFrom:)('*Tweak' postBuildWith: readFieldsFrom: writeFieldsOn:)!!ScriptHandlerLink class reorganize!('instance creation' new on:)!!ScriptHandlerLink reorganize!('accessing' value value:)!!ScriptEventTracer class reorganize!('instance creation' trace:in:)!!ScriptEventTracer reorganize!('testing' isDone isEventTracer)('tracing' stopTracing traceEvent:message:script:from: valueWithEvent:)('initialize' trace:in:)!!ScriptEventTraceEntry class reorganize!('as yet unclassified')!!ScriptEventTraceEntry reorganize!('accessing' event message parent script)('initialize' event:message:script:parent:)!!ScriptEventObserver class reorganize!('as yet unclassified')!!ScriptEventObserver reorganize!('accessing' buffer buffer: bufferSize bufferSize: nextHandler nextHandler: noticeEvent: selector selector: semaphore semaphore: signaler signaler: suspendedHandler)('initialize-release' release releaseTo: resume resumeSuspending: suspend suspend:)('streaming' next nextEvent nextPut: size valueWithEvent:)('experimental' passEvent:)('testing' isSuspended)!!ScriptEventBuffer class reorganize!('instance creation' new)!!ScriptEventBuffer reorganize!('accessing' bufferSize bufferSize: size)('streaming' next nextPut:)('initialize' flush initialize)!!ScriptChangeEvent class reorganize!('as yet unclassified')!!ScriptEvent class reorganize!('as yet unclassified')!!ScriptChangeEvent reorganize!('accessing' arguments newValue oldValue value)!!ScriptEvent reorganize!('accessing' arguments droppedEvent firstEvent selector sender withDroppedEvents withDroppedEventsDo:)('private' droppedEventStreamOfSize: priorEvent priorEvent: setArguments: setSender: setSender:selector: setSender:selector:arguments:)('experimental' handler pass)!ProcessorScheduler initialize!