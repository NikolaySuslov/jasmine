'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 7 February 2004 at 4:45:23 pm'!"Change Set:		CompilerHacks3.6Date:			6 February 2004Author:			Andreas Raab<your descriptive text goes here>"ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries properties sourceText '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries sourceText properties '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!Scanner subclass: #Parser	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!Notification subclass: #UndeclaredVariableReference	instanceVariableNames: 'parser varName varStart varEnd '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler-Exceptions'!VariableNode subclass: #LiteralVariableNode	instanceVariableNames: 'splNode readNode writeNode '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!ParseNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!isMessageNode	^false! !!ParseNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!isVariableNode	^false! !!BlockNode methodsFor: 'accessing' stamp: 'ar 11/17/2002 19:57'!returnNilIfNoOther	self returns		ifFalse: 			[statements last == NodeNil ifFalse: [statements add: NodeNil].			self returnLast]! !!BlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2003 16:50'!returnSelfIfNoOther: encoder	self returns ifTrue:[^self].	statements last == NodeSelf ifFalse: [		statements add: (encoder encodeVariable: 'self').	].	self returnLast.! !!Encoder methodsFor: 'encoding' stamp: 'ar 8/11/2003 00:19'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode _ scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode _ self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [^action value]].	range ifNotNil: [		name first isUppercase ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !!Encoder methodsFor: 'temps' stamp: 'ar 7/28/2003 20:43'!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node _ scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [Transcript cr; show: '(', name,' is shadowed)'].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'ar 7/28/2003 20:44'!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp)			ifTrue:[^self notify:'Name is already defined']			ifFalse:[Transcript show: '(', name, ' is shadowed)']].	^self reallyBind: name! !!Encoder methodsFor: 'source mapping' stamp: 'ar 11/19/2002 14:41'!sourceRangeFor: node	^sourceRanges at: node! !!Encoder methodsFor: 'private' stamp: 'ar 1/2/2002 14:53'!possibleNamesFor: proposedName	| results |	results _ class possibleVariablesFor: proposedName continuedFrom: nil.	^ proposedName correctAgainst: nil continuedFrom: results.! !!MessageNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:59'!isMessageNode	^true! !!MethodNode methodsFor: 'initialize-release' stamp: 'ar 1/4/2002 00:23'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict	"Initialize the receiver with respect to the arguments given."	encoder _ anEncoder.	selectorOrFalse _ selOrFalse.	precedence _ p.	arguments _ args.	temporaries _ temps.	block _ blk.	primitive _ prim.	properties _ propDict.! !!MethodNode methodsFor: 'code generation' stamp: 'ar 1/4/2002 00:33'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method cacheTempNames: self tempNames.		method properties: properties.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method cacheTempNames: self tempNames.	method properties: properties.	^ method! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 11/12/2003 21:35'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type == #xColon and: [aheadChar ~= $=]])		ifTrue: 			[buffer nextPut: self step.			["Allow any number of embedded colons in literal symbols"			(typeTable at: hereChar asciiValue) == #xColon]				whileTrue: [buffer nextPut: self step].			tokenType _ #keyword]		ifFalse: 			[type == #leftParenthesis 				ifTrue:[buffer nextPut: self step; nextPut: $).						tokenType _ #positionalMessage]				ifFalse:[tokenType _ #word]].	token _ buffer contents! !!Parser methodsFor: 'expression types' stamp: 'ar 2/6/2004 21:06'!expression	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	(hereType == #word and: [tokenType == #leftBracket])		ifTrue:[^self matrixExpression: false].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!Parser methodsFor: 'expression types' stamp: 'ar 2/6/2004 21:06'!matrixExpression: primary	"primaryExpression [ ... ] -> index node"	| start rcvrNode selector args msgStart msgStop |	self primaryExpression ifFalse:[^false].	(hereType == #leftBracket) ifFalse:[^primary].	start _ self startOfNextToken.	rcvrNode _ parseNode.	selector _ WriteStream on: (String new: 32).	args _ OrderedCollection new.	[	self advance.		parseNode _ nil.		self primaryExpression ifFalse:[^self expected:'expression'].		args size = 0 			ifTrue:[selector nextPutAll:'matrixAt:']			ifFalse:[selector nextPutAll:'at:'].		args add: parseNode.	here == #, ] whileTrue.	(self match: #rightBracket) ifFalse:[^self expected:']'].	msgStart _ start.	msgStop _ self endOfLastToken.	(primary not and:[hereType == #leftArrow]) ifTrue:[		selector nextPutAll:'put:'.		start _ self startOfNextToken.		self advance.		self expression ifFalse: [^self expected: 'Expression'].		(parseNode isKindOf: BlockNode) ifFalse:[			parseNode _ BlockNode new						arguments: #()						statements: (OrderedCollection with: parseNode)						returns: false						from: encoder.		].		args add: parseNode].	parseNode _ MessageNode new				receiver: rcvrNode				selector: selector contents asSymbol				arguments: args				precedence: 1				from: encoder				sourceRange: (msgStart to: msgStop).	primary ifTrue:[^true].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!Parser methodsFor: 'expression types' stamp: 'ar 2/6/2004 21:07'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart type |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					(self matrixExpression: true) ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					(self matrixExpression: true) ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [(hereType == #word or:[hereType == #positionalMessage])						ifTrue: 							[start _ self startOfNextToken.							type := hereType.							selector _ self advance.							type == #word ifTrue:[								args _ #().							] ifFalse:[								args := self positionalArgs.								selector := selector,'/', args size printString.							].							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'expression types' stamp: 'ar 3/26/2003 16:50'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	encoder _ encoderToUse.	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporaries.	messageComment _ currentComment.	currentComment _ nil.	doit ifFalse:[self properties].	prim _ 0.	properties ifNotNil:[		prim _ properties at: #primitiveIndex ifAbsent:[0].		"don't preserve primitive index"		properties removeKey: #primitiveIndex ifAbsent:[].	].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!Parser methodsFor: 'expression types' stamp: 'ar 12/4/2003 18:33'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword] whileTrue:[				selector nextPutAll: self advance.				args addLast: (encoder bindArg: self argumentName).			].			^ {selector contents asSymbol. args. 3}].	hereType == #positionalMessage ifTrue:[		args _ OrderedCollection new.		selector := self advance.		hereType == #rightParenthesis ifTrue:[self advance. ^{(selector,'/0') asSymbol. args. 1}].		[			args addLast: (encoder bindArg: self argumentName).			hereType == #rightParenthesis ifTrue:[				self advance. 				selector := (selector,'/', args size printString) asSymbol.				^{selector. args. 1}].			here == #, ifFalse:[self expected: 'comma'].			self advance.		] repeat.	].	^ self expected: 'Message pattern'! !!Parser methodsFor: 'expression types' stamp: 'ar 1/4/2002 00:23'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [self interactive				ifFalse: [tempsMark _ 1]				ifTrue: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ (prevEnd ifNil: [0]) + 1.		tempsMark _ hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'ar 2/7/2004 16:38'!variable	| varName varStart varEnd result |	varStart _ self startOfNextToken + requestorOffset.	varName _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	[result := encoder encodeVariable: varName		sourceRange: (varStart to: varEnd)		ifUnknown: [nil].	result ifNil:[		result := (UndeclaredVariableReference new)				parser: self;				varName: varName;				varStart: varStart;				varEnd: varEnd;				signal	].	result isString] whileTrue:[varName := result].	^result! !!Parser methodsFor: 'private' stamp: 'ar 8/5/2003 17:35'!addProperty: propName value: value	| aSymbol |	properties ifNil:[properties _ IdentityDictionary new].	aSymbol _ propName asSymbol.	(properties includesKey: aSymbol) ifTrue:[self notify: '<- duplicate property'].	properties at: aSymbol put: value.	^true! !!Parser methodsFor: 'primitives' stamp: 'ar 8/5/2003 17:36'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass _ Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType _ descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType _ self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName _ here.	(self match: #string) 		ifTrue:[externalName _ externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken:'(' asSymbol) ifFalse:[^self expected:'argument list'].	args _ WriteStream on: Array new.	[here == #)] whileFalse:[		argType _ self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:')' asSymbol) ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn _ xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	^self addProperty: #primitiveIndex value: 120! !!Parser methodsFor: 'primitives' stamp: 'ar 8/5/2003 17:36'!primitiveDeclaration	| prim module |	(self matchToken: 'primitive:') ifFalse:[^false].	prim _ here.	(self match: #number) ifTrue:[ "Indexed primitives"		^self addProperty: #primitiveIndex value: prim].	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	^self addProperty: #primitiveIndex value: 117.! !!Parser methodsFor: '*PositionalMessage' stamp: 'ar 12/4/2003 18:36'!positionalArgs	"Parse a series of positional arguments, separated by comma."	| args |	(hereType == #rightParenthesis) ifTrue:[self advance. ^#()].	args := WriteStream on: (Array new: 3).	[		self positionalArgsExpression ifFalse:[^self expected: 'argument'].		args nextPut: parseNode.		hereType == #rightParenthesis ifTrue:[self advance. ^args contents].		here == #, ifFalse:[^self expected: 'comma'].		self advance.	] repeat.! !!Parser methodsFor: '*PositionalMessage' stamp: 'ar 12/3/2003 19:09'!positionalArgsExpression	"Just like #expression just keep track of commas"	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(here == #, or:[hereType == #rightParenthesis]) ifTrue:[^true].	^self positionalMessagePart: 3 repeat: true! !!Parser methodsFor: '*PositionalMessage' stamp: 'ar 12/3/2003 19:27'!positionalMessagePart: level repeat: repeat	"Just like #messagePart but keep track of comma"	| start receiver selector args precedence words keywordStart type |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2 and:[here ~= #,]])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [(hereType == #word or:[hereType == #positionalMessage])						ifTrue: 							[start _ self startOfNextToken.							type := hereType.							selector _ self advance.							type == #word ifTrue:[								args _ #().							] ifFalse:[								args := self positionalArgs.								selector := selector,'/', args size printString.							].							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'properties' stamp: 'ar 1/4/2002 00:19'!correctProperty: proposedName interval: spot	"Correct the proposedName to a known type.	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection |	"If we can't ask the user for correction, make it undefined"	self interactive ifFalse: [^nil].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleNamesFor: proposedName.	aStream _ WriteStream on: (String new: 200).	alternatives do:[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: (alternatives size)))		startUpWithCaption:(('Unknown global: ', proposedName, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + proposedName size).	(choice = 0) | (choice > (alternatives size))		ifTrue: [self fail. ^nil].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	"Spelling correction"	self substituteWord: (alternatives at: choice)			wordInterval: spot			offset: 0.	^(alternatives at: choice)! !!Parser methodsFor: 'properties' stamp: 'ar 2/7/2004 16:39'!eventSignaler	self notify: 'unsupported property'! !!Parser methodsFor: 'properties' stamp: 'ar 2/7/2004 16:39'!eventTrigger	self notify: 'unsupported property'! !!Parser methodsFor: 'properties' stamp: 'ar 1/4/2002 00:02'!hasProperty: propName	properties ifNil:[^false].	^properties includesKey: propName! !!Parser methodsFor: 'properties' stamp: 'ar 1/3/2002 23:55'!properties	"Parse method properties"	[true] whileTrue:[		(self matchToken: #<) ifFalse:[^self].		self property.		(self matchToken: #>) ifFalse: [^ self expected: '>'].	].! !!Parser methodsFor: 'properties' stamp: 'ar 8/12/2003 09:57'!property	"Read a single property. Primitives and others may have fixed spec.	Parse all generic properties in the form of:		<propKey: propValue>	and remember them as method properties."	| propName propValue varStart varEnd |	(self hasProperty: #primitiveIndex) ifFalse:[		"Only one primitive specification is allowed"		self externalFunctionDeclaration ifTrue:[^true].		self primitiveDeclaration ifTrue:[^true].	].	hereType == #keyword ifFalse:[^false].	propName _ self advance allButLast. "remove last colon"	propName = 'on' ifTrue:[^self eventTrigger].	propName = 'signals' ifTrue:[^self eventSignaler].	(hereType == #number or:[hereType == #literal or:[hereType == #string]]) ifTrue:[		^self addProperty: propName value: self advance].	"We shouldn't have any but #word hereTypes at this point"	hereType == #word ifFalse:[^self error:'*** FIX THIS ***'].	varStart _ self startOfNextToken + requestorOffset.	propValue _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	propValue = 'true' ifTrue:[^self addProperty: propName value: true].	propValue = 'false' ifTrue:[^self addProperty: propName value: false].	[true] whileTrue:[		Symbol hasInterned: propValue ifTrue:[:aSymbol|			(encoder classEncoding bindingOf: aSymbol) ifNotNilDo:[:assoc|				^self addProperty: propName value: assoc value.			].		].		propValue _ self correctProperty: propValue interval: (varStart to: varEnd).		propValue ifNil:[^nil].	].	^true! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!parser	^parser! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!parser: aParser	parser := aParser! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varEnd	^varEnd! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varEnd: aNumber	varEnd := aNumber! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!varName	^varName! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!varName: aString	varName := aString! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varStart	^varStart! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varStart: aNumber	varStart := aNumber! !!UndeclaredVariableReference methodsFor: 'exceptionDescription' stamp: 'ar 12/8/2002 13:13'!defaultAction	^parser correctVariable: varName interval: (varStart to: varEnd)! !!VariableNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!isVariableNode	^true! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:01'!emitForValue: stack on: strm	super emitForValue: stack on: strm.	readNode ifNotNil:[readNode emit: stack args: 0 on: strm super: false].! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 01:59'!emitLoad: stack on: strm	writeNode ifNil:[^super emitLoad: stack on: strm].	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!emitStore: stack on: strm	writeNode ifNil:[^super emitStore: stack on: strm].	writeNode			emit: stack			args: 1			on: strm			super: false.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!emitStorePop: stack on: strm	writeNode ifNil:[^super emitStorePop: stack on: strm].	self emitStore: stack on: strm.	strm nextPut: Pop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!sizeForStore: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStore: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	writeNode _ encoder encodeSelector: #value:.	^(writeNode size: encoder args: 1 super: false) + (super sizeForValue: encoder)! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!sizeForStorePop: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStorePop: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	writeNode _ encoder encodeSelector: #value:.	^(writeNode size: encoder args: 1 super: false) + (super sizeForValue: encoder) + 1! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:02'!sizeForValue: encoder	| index |	(key isVariableBinding and:[key isSpecialReadBinding]) 		ifFalse:[^super sizeForValue: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	readNode _ encoder encodeSelector: #value.	^(readNode size: encoder args: 0 super: false) + (super sizeForValue: encoder)! !LiteralVariableNode removeSelector: #name:key:index:type:!ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries properties sourceText '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!