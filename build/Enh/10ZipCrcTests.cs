'From TeaSqueak3.6 of 8 February 2004 [latest update: #563] on 29 February 2004 at 4:48:02 am'!"Change Set:		ZipCrcTestsDate:			29 February 2004Author:			Andreas RaabIntegrates CRC validation at the level of InflateStream thereby avoiding some of the problems when dealing with it in subclasses. With these changes CRC validation is implicit - when we hit the end of a stream (such as upon #contents, #upToEnd or similar) the CRC will be validated automatically. If a missing or wrong crc is encountered a CRCError will be raised. Some tests are provided to show what is expected if a missing/wrong CRC is encountered."!Error subclass: #CRCError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!ReadStream subclass: #InflateStream	instanceVariableNames: 'state bitBuf bitPos source sourcePos sourceLimit litTable distTable sourceStream crc '	classVariableNames: 'BlockProceedBit BlockTypes FixedDistCodes FixedLitCodes MaxBits StateNewBlock StateNoMoreData '	poolDictionaries: ''	category: 'System-Compression'!FastInflateStream subclass: #ZLibReadStream	instanceVariableNames: 'adler32 '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!TestCase subclass: #ZipCrcTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!!InflateStream methodsFor: 'private' stamp: 'ar 2/29/2004 04:18'!pastEndRead	"A client has attempted to read beyond the read limit.	Check in what state we currently are and perform	the appropriate action"	| blockType bp oldLimit |	state = StateNoMoreData ifTrue:[^nil]. "Get out early if possible"	"Check if we can move decoded data to front"	self moveContentsToFront.	"Check if we can fetch more source data"	self moveSourceToFront.	state = StateNewBlock ifTrue:[state _ self getNextBlock].	blockType _ state bitShift: -1.	bp _ self bitPosition.	oldLimit := readLimit.	self perform: (BlockTypes at: blockType+1).	"Note: if bit position hasn't advanced then nothing has been decoded."	bp = self bitPosition 		ifTrue:[^self primitiveFailed].	"Update crc for the decoded contents"	readLimit > oldLimit 		ifTrue:[crc _ self updateCrc: crc from: oldLimit+1 to: readLimit in: collection].	state = StateNoMoreData ifTrue:[self verifyCrc].	^self next! !!InflateStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:04'!crcError: aString	^CRCError signal: aString! !!InflateStream methodsFor: 'crc' stamp: 'ar 2/29/2004 03:49'!updateCrc: oldCrc from: start to: stop in: aCollection	"Answer an updated CRC for the range of bytes in aCollection.	Subclasses can implement the appropriate means for the check sum they wish to use."	^oldCrc! !!InflateStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:22'!verifyCrc	"Verify the crc checksum in the input"! !!GZipReadStream methodsFor: 'initialize' stamp: 'ar 2/29/2004 03:32'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the GZIP stream."	| method magic flags length |	super on: aCollection from: firstIndex to: lastIndex.	crc _ 16rFFFFFFFF.	magic _ self nextBits: 16.	(magic = GZipMagic) 		ifFalse:[^self error:'Not a GZipped stream'].	method _ self nextBits: 8.	(method = GZipDeflated)		ifFalse:[^self error:'Bad compression method'].	flags _ self nextBits: 8.	(flags anyMask: GZipEncryptFlag) 		ifTrue:[^self error:'Cannot decompress encrypted stream'].	(flags anyMask: GZipReservedFlags)		ifTrue:[^self error:'Cannot decompress stream with unknown flags'].	"Ignore stamp, extra flags, OS type"	self nextBits: 16; nextBits: 16. "stamp"	self nextBits: 8. "extra flags"	self nextBits: 8. "OS type"	(flags anyMask: GZipContinueFlag) "Number of multi-part archive - ignored"		ifTrue:[self nextBits: 16]. 	(flags anyMask: GZipExtraField) "Extra fields - ignored"		ifTrue:[	length _ self nextBits: 16.				1 to: length do:[:i| self nextBits: 8]].	(flags anyMask: GZipNameFlag) "Original file name - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].	(flags anyMask: GZipCommentFlag) "Comment - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].! !!GZipReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 03:30'!updateCrc: oldCrc from: start to: stop in: aCollection	"Answer an updated CRC for the range of bytes in aCollection"	^ZipWriteStream updateCrc: oldCrc from: start to: stop in: aCollection.! !!GZipReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:20'!verifyCrc	| stored |	stored := 0.	0 to: 24 by: 8 do: [ :i |		sourcePos >= sourceLimit ifTrue: [ ^ self crcError: 'No checksum (proceed to ignore)' ].		stored := stored + (self nextByte bitShift: i) ].	stored := stored bitXor: 16rFFFFFFFF.	stored = crc ifFalse: [ ^ self crcError: 'Wrong checksum (proceed to ignore)' ].	^stored! !!PNGReadWriter methodsFor: 'accessing' stamp: 'ar 2/29/2004 03:59'!nextImage	bigEndian := Smalltalk isBigEndian.	filtersSeen _ Bag new.	globalDataChunk _ nil.	transparentPixelValue _ nil.	unknownChunks _ Set new.	stream reset.	(stream respondsTo: #binary) ifTrue: [ stream binary] .	stream skip: 8.	[stream atEnd] whileFalse: [self processNextChunk].	"Set up our form"	palette ifNotNil:[		"Dump the palette if it's the same as our standard palette"		palette = (StandardColors copyFrom: 1 to: palette size) 			ifTrue:[palette := nil]].	(depth <= 8 and:[palette notNil]) ifTrue:[		form := ColorForm extent: width@height depth: depth.		form colors: palette.	] ifFalse:[		form := Form extent: width@height depth: depth.	].	backColor ifNotNil:[form fillColor: backColor].	chunk _ globalDataChunk ifNil:[self error: 'image data is missing'].	chunk ifNotNil: [self processIDATChunk].	unknownChunks isEmpty ifFalse: [		"Transcript show: ' ',unknownChunks asSortedCollection asArray printString."	].	self debugging ifTrue: [		Transcript cr; show: 'form = ',form printString.		Transcript cr; show: 'colorType = ',colorType printString.		Transcript cr; show: 'interlaceMethod = ',interlaceMethod printString.		Transcript cr; show: 'filters = ',filtersSeen sortedCounts asArray printString.	].	^ form! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/29/2004 04:19'!processInterlaced	| z filter bytesPerPass startingCol colIncrement rowIncrement startingRow cx sc temp |	startingCol _ #(0 4 0 2 0 1 0 ).	colIncrement _ #(8 8 4 4 2 2 1 ).	rowIncrement _ #(8 8 8 4 4 2 2 ).	startingRow _ #(0 0 4 0 2 0 1 ).	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	1 to: 7 do: [:pass |		(self doPass: pass)			ifTrue:				[cx _ colIncrement at: pass.				sc _ startingCol at: pass.				bytesPerPass _ width - sc + cx - 1 // cx * bitsPerPixel + 7 // 8.				prevScanline _ ByteArray new: bytesPerPass.				thisScanline _ ByteArray new: bytesPerScanline.				(startingRow at: pass)					to: height - 1					by: (rowIncrement at: pass)					do: [:y |						filter _ z next.						filtersSeen add: filter.						(filter isNil or: [(filter between: 0 and: 4) not])							ifTrue: [^ self].						thisScanline _ z next: bytesPerPass into: thisScanline startingAt: 1.						self filterScanline: filter count: bytesPerPass.						self copyPixels: y at: sc by: cx.						temp := prevScanline.						prevScanline := thisScanline.						thisScanline := temp.					]				]	].	z atEnd ifFalse:[self error:'Unexpected data'].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/29/2004 04:19'!processNonInterlaced	| z filter temp copyMethod debug |	debug := self debugging.	copyMethod _ #(copyPixelsGray: nil copyPixelsRGB: copyPixelsIndexed:		  copyPixelsGrayAlpha: nil copyPixelsRGBA:) at: colorType+1.	debug ifTrue: [ Transcript cr; nextPutAll: 'NI chunk size='; print: chunk size ].	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	prevScanline _ ByteArray new: bytesPerScanline.	thisScanline := ByteArray new: bytesPerScanline.	0 to: height-1 do: [ :y |		filter _ (z next: 1) first.		debug ifTrue:[filtersSeen add: filter].		thisScanline _ z next: bytesPerScanline into: thisScanline startingAt: 1.		(debug and: [ thisScanline size < bytesPerScanline ]) ifTrue: [ Transcript nextPutAll: ('wanted {1} but only got {2}' format: { bytesPerScanline. thisScanline size }); cr ].		filter = 0 ifFalse:[self filterScanline: filter count: bytesPerScanline].		self perform: copyMethod with: y.		temp := prevScanline.		prevScanline := thisScanline.		thisScanline := temp.		].	z atEnd ifFalse:[self error:'Unexpected data'].	debug ifTrue: [Transcript  nextPutAll: ' compressed size='; print: z position  ].! !!PNGReadWriterTest methodsFor: 'tests' stamp: 'ar 2/29/2004 03:55'!testPngSuite	"Requires the suite from 		ftp://swrinde.nde.swri.edu/pub/png/images/suite/PngSuite.zip	to be present as PngSuite.zip"	| file zip entries |	[file := FileStream readOnlyFileNamed: 'PngSuite.zip'] on: Error do:[:ex| ex return].	file ifNil:[^self].	[zip := ZipArchive new readFrom: file.	entries := zip members select:[:mbr| mbr fileName asLowercase endsWith: '.png'].	entries do:[:mbr| 		(mbr fileName asLowercase first = $x)			ifTrue: [self encodeAndDecodeWithError: mbr contentStream ]			ifFalse: [self encodeAndDecodeStream: mbr contentStream ] ].	] ensure:[file close].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/29/2004 03:55'!encodeAndDecodeWithError: aStream	self should:[self encodeAndDecodeStream: aStream] raise: Error! !!ZLibReadStream methodsFor: 'initialize' stamp: 'ar 2/29/2004 03:31'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the ZLib stream."	| method byte |	super on: aCollection from: firstIndex to: lastIndex.	crc _ 1.	method _ self nextBits: 8.	(method bitAnd: 15) = 8 ifFalse:[^self error:'Unknown compression method'].	(method bitShift: -4) + 8 > 15 ifTrue:[^self error:'Invalid window size'].	byte _ self nextBits: 8.	(method bitShift: 8) + byte \\ 31 = 0 ifFalse:[^self error:'Incorrect header'].	(byte anyMask: 32) ifTrue:[^self error:'Need preset dictionary'].! !!ZLibReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 03:30'!updateCrc: oldCrc from: start to: stop in: aCollection	"Answer an updated CRC for the range of bytes in aCollection"	^ZLibWriteStream updateAdler32: oldCrc from: start to: stop in: aCollection.! !!ZLibReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:21'!verifyCrc	| stored |	stored := 0.	24 to: 0 by: -8 do: [ :i |		sourcePos >= sourceLimit ifTrue: [ ^ self crcError: 'No checksum (proceed to ignore)' ].		stored := stored + (self nextByte bitShift: i) ].	stored = crc ifFalse: [ ^ self crcError: 'Wrong checksum (proceed to ignore)' ].	^stored! !!ZLibWriteStream methodsFor: 'initialize-release' stamp: 'ar 2/29/2004 04:40'!writeFooter	"Store the Adler32 checksum as the last 4 bytes."	3 to: 0 by: -1 do:[:i| encoder nextBytePut: (crc >> (i*8) bitAnd: 255)].! !!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 2/29/2004 04:40'!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection byteAt: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !!ZipCrcTests methodsFor: 'tests' stamp: 'ar 2/29/2004 04:43'!testInvalidGZipCrc	"See that a wrong CRC raises an appropriate error"	| reader writer bytes crcByte |	writer := GZipWriteStream on: String new.	writer nextPutAll: 'Hello World'.	writer close.	bytes := writer encodedStream contents.	crcByte := bytes byteAt: bytes size-5. "before the length"	bytes byteAt: bytes size-5 put: (crcByte + 1 bitAnd: 255).	reader := GZipReadStream on: bytes.	self should:[reader upToEnd] raise: CRCError.	reader := GZipReadStream on: bytes.	self should:[reader contents] raise: CRCError.	reader := GZipReadStream on: bytes.	self should:[reader next: 100] raise: CRCError.! !!ZipCrcTests methodsFor: 'tests' stamp: 'ar 2/29/2004 04:43'!testInvalidZLibCrc	"See that a wrong CRC raises an appropriate error"	| reader writer bytes crcByte |	writer := ZLibWriteStream on: String new.	writer nextPutAll: 'Hello World'.	writer close.	bytes := writer encodedStream contents.	crcByte := bytes byteAt: bytes size-2.	bytes byteAt: bytes size-2 put: (crcByte + 1 bitAnd: 255).	reader := ZLibReadStream on: bytes.	self should:[reader upToEnd] raise: CRCError.	reader := ZLibReadStream on: bytes.	self should:[reader contents] raise: CRCError.	reader := ZLibReadStream on: bytes.	self should:[reader next: 100] raise: CRCError.! !!ZipCrcTests methodsFor: 'tests' stamp: 'ar 2/29/2004 04:42'!testMissingGZipCrc	"See that the lack of a CRC raises an appropriate error"	| reader writer bytes |	writer := GZipWriteStream on: String new.	writer nextPutAll: 'Hello World'.	writer close.	bytes := writer encodedStream contents.	bytes := bytes copyFrom: 1 to: bytes size-6.	reader := GZipReadStream on: bytes.	self should:[reader upToEnd] raise: CRCError.	reader := GZipReadStream on: bytes.	self should:[reader contents] raise: CRCError.	reader := GZipReadStream on: bytes.	self should:[reader next: 100] raise: CRCError.! !!ZipCrcTests methodsFor: 'tests' stamp: 'ar 2/29/2004 04:42'!testMissingZLibCrc	"See that the lack of a CRC raises an appropriate error"	| reader writer bytes |	writer := ZLibWriteStream on: String new.	writer nextPutAll: 'Hello World'.	writer close.	bytes := writer encodedStream contents.	bytes := bytes copyFrom: 1 to: bytes size-2.	reader := ZLibReadStream on: bytes.	self should:[reader upToEnd] raise: CRCError.	reader := ZLibReadStream on: bytes.	self should:[reader contents] raise: CRCError.	reader := ZLibReadStream on: bytes.	self should:[reader next: 100] raise: CRCError.! !!ZipCrcTests methodsFor: 'tests' stamp: 'ar 2/29/2004 04:42'!testValidGZipCrc	| reader writer bytes |	writer := GZipWriteStream on: String new.	writer nextPutAll: 'Hello World'.	writer close.	bytes := writer encodedStream contents.	reader := GZipReadStream on: bytes.	self assert: reader upToEnd = 'Hello World'.! !!ZipCrcTests methodsFor: 'tests' stamp: 'ar 2/29/2004 04:42'!testValidZLibCrc	| reader writer bytes |	writer := ZLibWriteStream on: String new.	writer nextPutAll: 'Hello World'.	writer close.	bytes := writer encodedStream contents.	reader := ZLibReadStream on: bytes.	self assert: reader upToEnd = 'Hello World'.! !ZipCrcTests removeSelector: #testInvalidGZipCrcContents!ZipCrcTests removeSelector: #testInvalidGZipCrcUpToEnd!ZipCrcTests removeSelector: #testValidAdler32!ZipCrcTests removeSelector: #testValidCrc32!ZLibReadStream removeSelector: #pastEndRead!ZLibReadStream removeSelector: #verifyAdler32!FastInflateStream subclass: #ZLibReadStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compression'!