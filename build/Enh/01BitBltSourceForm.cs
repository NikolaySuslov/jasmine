'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 7 February 2004 at 6:17:01 pm'!!BitBlt methodsFor: 'accessing' stamp: 'ar 12/1/2003 12:50'!sourceForm: aForm 	"Set the receiver's source form to be the argument, aForm."	sourceForm _ aForm.	sourceForm ifNotNil:[sourceForm := sourceForm asSourceForm].! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:52'!copy: destRectangle from: sourcePt in: srcForm	| destOrigin |	self sourceForm: srcForm.	halftoneForm _ nil.	combinationRule _ 3.  "store"	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:52'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	self sourceForm: srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	srcForm == nil ifFalse:		[colorMap _ srcForm colormapIfNeededFor: destForm].	^ self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copy: destRectangle from: sourcePt in: srcForm halftoneForm: hf rule: rule 	| destOrigin |	self sourceForm: srcForm.	self fillColor: hf.		"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:52'!copyForm: srcForm to: destPt rule: rule color: color	self sourceForm: srcForm.	halftoneForm _ color.	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copyForm: srcForm to: destPt rule: rule colorMap: map	self sourceForm: srcForm.	halftoneForm _ nil.	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	colorMap _ map.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copyForm: srcForm to: destPt rule: rule fillColor: color	self sourceForm: srcForm.	self fillColor: color.	"sets halftoneForm"	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copyFrom: sourceRectangle in: srcForm to: destPt	| sourceOrigin |	self sourceForm: srcForm.	halftoneForm _ nil.	combinationRule _ 3.  "store"	destX _ destPt x.	destY _ destPt y.	sourceOrigin _ sourceRectangle origin.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ sourceRectangle width.	height _ sourceRectangle height.	colorMap _ srcForm colormapIfNeededFor: destForm.	self copyBits! !!BitBlt methodsFor: 'private' stamp: 'ar 3/15/2003 02:29'!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	| sx sy dx dy bbW bbH |	"fill in the lazy state if needed"	destX ifNil:[destX := 0].	destY ifNil:[destY := 0].	width ifNil:[width := destForm width].	height ifNil:[height := destForm height].	sourceX ifNil:[sourceX := 0].	sourceY ifNil:[sourceY := 0].	clipX ifNil:[clipX := 0].	clipY ifNil:[clipY := 0].	clipWidth ifNil:[clipWidth := destForm width].	clipHeight ifNil:[clipHeight := destForm height].	destX >= clipX		ifTrue: [sx _ sourceX.				dx _ destX.				bbW _ width]		ifFalse: [sx _ sourceX + (clipX - destX).				bbW _ width - (clipX - destX).				dx _ clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy _ sourceY.				dy _ destY.				bbH _ height]		ifFalse: [sy _ sourceY + clipY - destY.				bbH _ height - (clipY - destY).				dy _ clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].	sourceForm ifNotNil:[		sx < 0			ifTrue: [dx _ dx - sx.					bbW _ bbW + sx.					sx _ 0].		sx + bbW > sourceForm width			ifTrue: [bbW _ bbW - (sx + bbW - sourceForm width)].		sy < 0			ifTrue: [dy _ dy - sy.					bbH _ bbH + sy.					sy _ 0].		sy + bbH > sourceForm height			ifTrue: [bbH _ bbH - (sy + bbH - sourceForm height)].	].	(bbW <= 0 or:[bbH <= 0]) ifTrue:[		sourceX := sourceY := destX := destY := clipX := clipY := width := height := clipWidth := clipHeight := 0.		^true].	(sx = sourceX 		and:[sy = sourceY 		and:[dx = destX 		and:[dy = destY 		and:[bbW = width 		and:[bbH = height]]]]]) ifTrue:[^false].	sourceX := sx.	sourceY := sy.	destX := dx.	destY := dy.	width := bbW.	height := bbH.	^true! !!BitBlt methodsFor: 'private' stamp: 'ar 12/1/2003 12:50'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth |	sourceForm ifNotNil:[lastSourceDepth _ sourceForm depth].	self sourceForm: aStrikeFont glyphs.	(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse:		["Set up color map for a different source depth (color font)"		"Uses caching for reasonable efficiency"		colorMap _ self cachedFontColormapFrom: sourceForm depth to: destForm depth.		colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].	sourceForm depth = 1 ifTrue:		[colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).		"Ignore any halftone pattern since we use a color map approach here"		halftoneForm _ nil].	sourceY _ 0.	height _ aStrikeFont height.! !!BitBlt methodsFor: 'private' stamp: 'ar 12/1/2003 12:52'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	self sourceForm: sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap _ sourceForm colormapIfNeededFor: destForm]! !!Form methodsFor: 'converting' stamp: 'ar 2/7/2004 18:16'!asSourceForm	^self! !!WarpBlt methodsFor: 'primitives' stamp: 'ar 12/1/2003 12:52'!sourceForm: srcForm destRect: dstRectangle	"Set up a WarpBlt from the entire source Form to the given destination rectangle."	| w h |	self sourceForm: srcForm.	sourceX _ sourceY _ 0.	destX _ dstRectangle left.	destY _ dstRectangle top.	width _ dstRectangle width.	height _ dstRectangle height.	w _ 16384 * (srcForm width - 1).	h _ 16384 * (srcForm height - 1).	p1x _ 0.	p2x _ 0.	p3x _ w.	p4x _ w.	p1y _ 0.	p2y _ h.	p3y _ h.	p4y _ 0.	p1z _ p2z _ p3z _ p4z _ 16384.  "z-warp ignored for now"! !!WarpBlt class methodsFor: 'form rotation' stamp: 'ar 12/1/2003 12:57'!rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |	srcRect _ srcForm boundingBox.	center _ srcRect center.	radians _ angleInDegrees degreesToRadians.	dstOrigin _ dstCorner _ center.	srcRect corners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p _ ((corner - center) scaleBy: scalePoint) + center.		p _ (p rotateBy: radians about: center) rounded.		dstOrigin _ dstOrigin min: p.		dstCorner _ dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect _ dstOrigin corner: dstCorner.	inverseScale _ (1.0 / scalePoint x)@(1.0 / scalePoint y).	quad _ dstRect innerCorners collect: [:corner |		p _ corner rotateBy: radians negated about: center.		((p - center) scaleBy: inverseScale) + center].	"make a Form to hold the result and do the rotation"	warpSrc _ srcForm.	(srcForm isKindOf: ColorForm)		ifTrue: [			cellSize > 1 | true "ar 12/27/2001: Always enable - else sketches won't work"				ifTrue: [					warpSrc _ Form extent: srcForm extent depth: 16.					srcForm displayOn: warpSrc.					dstForm _ Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"				ifFalse: [					dstForm _ srcForm species extent: dstRect extent depth: srcForm depth]]		ifFalse: [			dstForm _ srcForm species extent: dstRect extent depth: srcForm depth].	(WarpBlt toForm: dstForm)		sourceForm: warpSrc;		colorMap: (warpSrc colormapIfNeededFor: dstForm);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint;		copyQuad: quad toRect: dstForm boundingBox.	(dstForm isKindOf: ColorForm) ifTrue: [dstForm colors: srcForm colors copy].	newCenter _ (center rotateBy: radians about: aPoint) truncated.	^ Array with: dstForm with: dstRect origin + (newCenter - center)! !