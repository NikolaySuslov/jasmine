'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 4 October 2004 at 9:14:32 pm'!!Object methodsFor: 'user interface' stamp: 'md 5/3/2004 13:55'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	(self ifTweak: [CInspector] ifNot: [Inspector]) openOn: self withEvalPane: true.! !!ArrayedCollection methodsFor: 'printing' stamp: 'tk 6/18/2004 21:45'!storeOn: aStream	(self size between: 1 and: 6) ifTrue: [^ self storeWithOn: aStream].	"(Array with: element)"	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new: '.	aStream store: self size.	aStream nextPut: $).	(self storeElementsFrom: 1 to: self size on: aStream)		ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!ArrayedCollection methodsFor: 'printing' stamp: 'tk 6/18/2004 21:47'!storeWithOn: aStream	"Use (Array with: x with: x) if possible.  Sizes 1 to 6."	aStream nextPutAll: '('.	aStream nextPutAll: self class name.	self do: [:ele |		aStream nextPutAll: ' with: '.		ele storeOn: aStream].	aStream nextPut: $).! !!BalloonEngine methodsFor: 'drawing' stamp: 'bf 4/3/2004 01:36'!registerFill: aFillStyle	"Register the given fill style."	| theForm |	aFillStyle ifNil:[^0].	aFillStyle isSolidFill 		ifTrue:[^aFillStyle scaledPixelValue32].	aFillStyle isGradientFill ifTrue:[		^self primAddGradientFill: aFillStyle pixelRamp			from: aFillStyle origin			along: aFillStyle direction			normal: aFillStyle normal			radial: aFillStyle isRadialFill		].	aFillStyle isBitmapFill ifTrue:[		theForm _ aFillStyle form asSourceForm.		theForm unhibernate.		forms _ forms copyWith: theForm.		^self primAddBitmapFill: theForm				colormap: (theForm colormapIfNeededForDepth: 32)				tile: aFillStyle isTiled				from: aFillStyle origin				along: aFillStyle direction				normal: aFillStyle normal				xIndex: forms size].	^0! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'md 4/25/2004 17:31'!changeSorterClass	^ActiveHand isPlayer ifTrue:[CChangeSorter] ifFalse:[ChangeSorter]! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'md 4/25/2004 17:31'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers _ self changeSorterClass allChangeSets select:		[:aChangeSet | self changeSorterClass perform: membershipSelector with: aChangeSet].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet] ! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'tk 7/22/2004 19:43'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found."	AllChangeSets do: [:aChangeSet | aChangeSet name = aName ifTrue: [^ aChangeSet]].	ChangeSorter gatherChangeSets.	"mismatch -- some added from inside Tweak"	^ AllChangeSets			detect: [:aChangeSet | aChangeSet name = aName]			ifNone: [nil].! !!CompiledMethod methodsFor: 'literals' stamp: 'bf 3/29/2004 17:43'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	| lit |	self properties ifNotNilDo:[:dict|		dict keysAndValuesDo: [:key :value |			key == literal ifTrue: [^true].			value == literal ifTrue:[^true].			(value class == Array and: [value hasLiteral: literal]) ifTrue: [^ true]]].	2 to: self numLiterals + 1 do: 		[:index | 		(lit _ self objectAt: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false ! !!Integer methodsFor: 'printing' stamp: 'tk 7/1/2004 15:46'!ordinalSuffix	"return the string that comes after a number 'st' for 1, 'nd' for 2 for English"	| lowDigit |	(self \\ 100 between: 4 and: 21) ifTrue: [^ 'th'].  "eleventh, etc."	lowDigit _ self \\ 10.	lowDigit = 1 ifTrue: [^ 'st'].	lowDigit = 2 ifTrue: [^ 'nd'].	lowDigit = 3 ifTrue: [^ 'rd'].	^ 'th'"  1 ordinalSuffix2 ordinalSuffix3 ordinalSuffix4 ordinalSuffix12 ordinalSuffix22 ordinalSuffix31 ordinalSuffix"! !!Process methodsFor: 'debugging' stamp: 'md 5/3/2004 13:57'!debug: context title: title full: bool	"Open debugger on self with context shown on top"	| topCtxt |	topCtxt _ self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].		(self ifTweak: [CDebugger] ifNot: [Debugger])				openOn: self context: context label: title contents: nil fullView: bool.! !!RunArray methodsFor: 'adding' stamp: 'BG 6/12/2003 11:07'!rangeOf: attr startingAt: startPos	"Answer an interval that gives the range of attr at index position  startPos. An empty interval with start value startPos is returned when the attribute attr is not present at position startPos.  self size > 0 is assumed, it is the responsibility of the caller to test for emptiness of self.Note that an attribute may span several adjancent runs. "	self at: startPos 		setRunOffsetAndValue:             [:run :offset :value |                ^(value includes: attr)                  ifFalse: [startPos to: startPos - 1]                  ifTrue:                    [ | firstRelevantPosition lastRelevantPosition idxOfCandidateRun |                     lastRelevantPosition := startPos - offset + (runs at: run) - 1.                     firstRelevantPosition := startPos - offset.                     idxOfCandidateRun := run + 1.                     [idxOfCandidateRun <= runs size                              and: [(values at: idxOfCandidateRun) includes: attr]]                        whileTrue:                          [lastRelevantPosition := lastRelevantPosition + (runs at: idxOfCandidateRun).                           idxOfCandidateRun := idxOfCandidateRun + 1].                      idxOfCandidateRun := run - 1.                     [idxOfCandidateRun >= 1                              and: [(values at: idxOfCandidateRun) includes: attr]]                        whileTrue:                          [firstRelevantPosition := firstRelevantPosition - (runs at: idxOfCandidateRun).                           idxOfCandidateRun := idxOfCandidateRun - 1].                      firstRelevantPosition to: lastRelevantPosition]		  ]! !!RunArray methodsFor: 'converting' stamp: 'BG 6/8/2003 15:17'!reversed  ^self class runs: runs reversed values: values reversed! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/6/2004 14:01'!widthOfString: aString from: firstIndex to: lastIndex	"Measure the length of the given string between start and stop index"	| baseWidth kern |	DefaultStringScanner 		ifNil:[DefaultStringScanner _ CharacterScanner new initializeStringMeasurer].	baseWidth := DefaultStringScanner measureString: aString inFont: self from: firstIndex to: lastIndex.	(kern := self baseKern) = 0 ifTrue:[^baseWidth].	^baseWidth - (lastIndex - firstIndex + 1 * kern) + self ascentKern! !!Text methodsFor: 'accessing' stamp: 'BG 6/8/2003 16:18'!rangeOf: attribute startingAt: index"Answer an interval that gives the range of attribute at index position  index. An empty interval with start value index is returned when the attribute is not present at position index.  "   ^string size = 0      ifTrue: [index to: index - 1]	 ifFalse: [runs rangeOf: attribute startingAt: index]! !!Text methodsFor: 'accessing' stamp: 'md 12/12/2003 17:03'!rangeOf: attribute startingAt: index forStyle: aTextStyle"aTextStyle is not really needed, it is kept for compatibility with an earlier method version "	self deprecated: 'Use Text>>rangeOf:startingAt: instead.'.	^self rangeOf: attribute startingAt: index! !!Text methodsFor: 'converting' stamp: 'dvf 10/1/2003 02:58'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. Do it to both the string and the runs."	| rep newRepRuns |	rep _ replacement asText.	"might be a string"	string replaceFrom: start to: stop with: rep string startingAt: repStart.	newRepRuns _ rep runs copyFrom: repStart to: repStart + stop - start.	runs _ runs copyReplaceFrom: start to: stop with: newRepRuns! !!Text methodsFor: 'converting' stamp: 'BG 6/8/2003 16:38'!reversed	"Answer a copy of the receiver with element order reversed."	^ self class string: string reversed runs: runs reversed.  "  It is assumed that  self size = runs size  holds. "! !!Text methodsFor: 'emphasis' stamp: 'tk 7/13/2004 14:22'!allItalic	"Force this whole text to be italic."	string size = 0 ifTrue: [^self].	self makeItalicFrom: 1 to: string size! !!Text methodsFor: 'emphasis' stamp: 'tk 7/13/2004 14:23'!makeItalicFrom: start to: stop	^ self addAttribute: TextEmphasis italic from: start to: stop! !!TimeStamp class methodsFor: 'instance creation' stamp: 'tk 6/17/2004 10:08'!noonOn: aDate	"Answer a new instance that represents aDate at noon."	^self date: aDate time: (Time new hours: 12)! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/26/2003 08:01'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	| newEnd |	collection class == aCollection class ifFalse:		[^ super next: anInteger putAll: aCollection startingAt: startIndex].	newEnd _ position + anInteger.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: startIndex.	position _ newEnd.	^aCollection! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/24/2003 20:41'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position _ newEnd.! !!WriteStream methodsFor: 'private' stamp: 'BG 5/24/2003 22:49'!growTo: anInteger   " anInteger is the required minimal new size of the collection "	| oldSize grownCollection newSize |	oldSize _ collection size.     newSize := anInteger + (oldSize // 4 max: 20).	grownCollection _ collection class new: newSize.	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit _ collection size.! !!TextStream methodsFor: 'as yet unclassified' stamp: 'dvf 10/1/2003 02:51'!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.     position + n > writeLimit       ifTrue:        [self growTo: position + n + 10].	collection 		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n! !