'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 4 October 2004 at 10:02:17 pm'!Object subclass: #CCompiler	instanceVariableNames: 'sourceStream requestor class context parserClass cacheDoItNode '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!InstructionStream subclass: #CDecompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit lastJumpPc lastReturnPc limit hasValue blockStackBase '	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag '	poolDictionaries: ''	category: 'Tweak-Compiler'!Exception subclass: #CDeprecatedFeature	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!TextStream subclass: #CDialectStream	instanceVariableNames: 'dialect colorTable '	classVariableNames: 'ST80ColorTable Sq00ColorTable '	poolDictionaries: ''	category: 'Tweak-Compiler'!Dictionary subclass: #CLiteralDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!Object subclass: #CParseNode	instanceVariableNames: 'comment pc '	classVariableNames: 'Bfp BtpLong CodeBases CodeLimits DblExtDoAll Dup EndMethod EndRemote Jmp JmpLimit JmpLong LdFalse LdInstLong LdInstType LdLitIndType LdLitType LdMinus1 LdNil LdSelf LdSuper LdTempType LdThisContext LdTrue LoadLong LongLongDoAll NodeFalse NodeNil NodeSelf NodeSuper NodeThisContext NodeTrue Pop Send SendLimit SendLong SendLong2 SendPlus SendType ShortStoP StdLiterals StdSelectors StdVariables Store StorePop '	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CAssignmentNode	instanceVariableNames: 'variable value '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CBlockNode	instanceVariableNames: 'arguments statements returns nArgsNode size remoteCopyNode temporaries '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CBraceNode	instanceVariableNames: 'elements sourceLocations emitNode '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CCascadeNode	instanceVariableNames: 'receiver messages '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CCommentNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CDecompilerConstructor	instanceVariableNames: 'method instVars nArgs literalValues tempVars '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CEncoder	instanceVariableNames: 'scopeTable nTemps supered requestor class literalStream selectorSet litIndSet litSet sourceRanges globalSourceRanges parser '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CLeafNode	instanceVariableNames: 'key code '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CLeafNode subclass: #CLiteralNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CMessageNode	instanceVariableNames: 'receiver selector precedence special arguments sizes equalNode caseErrorNode '	classVariableNames: 'MacroEmitters MacroPrinters MacroSelectors MacroSizers MacroTransformers StdTypers ThenFlag '	poolDictionaries: ''	category: 'Tweak-Compiler'!CMessageNode subclass: #CMessageAsTempNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CMethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries properties sourceText '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CMethodTempsNode	instanceVariableNames: 'temporaries '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CParseNode subclass: #CReturnNode	instanceVariableNames: 'expr '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!Object subclass: #CScanner	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable '	classVariableNames: 'TypeTable '	poolDictionaries: ''	category: 'Tweak-Compiler'!CScanner subclass: #CParser	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties methodSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CLeafNode subclass: #CSelectorNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!Error subclass: #CSyntaxError	instanceVariableNames: 'parser location doitFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!Notification subclass: #CUndeclaredVariableReference	instanceVariableNames: 'parser varName varStart varEnd '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CLeafNode subclass: #CVariableNode	instanceVariableNames: 'name '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CVariableNode subclass: #CFieldNode	instanceVariableNames: 'fieldDef rcvrNode readNode writeNode '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CVariableNode subclass: #CInstanceVariableNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CVariableNode subclass: #CLiteralVariableNode	instanceVariableNames: 'splNode readNode writeNode '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CVariableNode subclass: #CTempVariableNode	instanceVariableNames: 'isAnArg hasRefs hasDefs scope '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Compiler'!CCompiler class	instanceVariableNames: ''!CDecompiler class	instanceVariableNames: ''!CDeprecatedFeature class	instanceVariableNames: ''!CDialectStream class	instanceVariableNames: ''!CLiteralDictionary class	instanceVariableNames: ''!CParseNode class	instanceVariableNames: ''!CAssignmentNode class	instanceVariableNames: ''!CBlockNode class	instanceVariableNames: ''!CBraceNode class	instanceVariableNames: ''!CCascadeNode class	instanceVariableNames: ''!CCommentNode class	instanceVariableNames: ''!CDecompilerConstructor class	instanceVariableNames: ''!CEncoder class	instanceVariableNames: ''!CLeafNode class	instanceVariableNames: ''!CLiteralNode class	instanceVariableNames: ''!CMessageNode class	instanceVariableNames: ''!CMessageAsTempNode class	instanceVariableNames: ''!CMethodNode class	instanceVariableNames: ''!CMethodTempsNode class	instanceVariableNames: ''!CReturnNode class	instanceVariableNames: ''!CScanner class	instanceVariableNames: ''!CParser class	instanceVariableNames: ''!CSelectorNode class	instanceVariableNames: ''!CSyntaxError class	instanceVariableNames: ''!CUndeclaredVariableReference class	instanceVariableNames: ''!CVariableNode class	instanceVariableNames: ''!CFieldNode class	instanceVariableNames: ''!CInstanceVariableNode class	instanceVariableNames: ''!CLiteralVariableNode class	instanceVariableNames: ''!CTempVariableNode class	instanceVariableNames: ''!!Behavior methodsFor: '*Tweak-Compiler' stamp: 'ar 3/26/2004 16:15'!variableNodes	"Answer the variable nodes for the compiler"	^self allInstVarNames collectWithIndex:[:each :index|		CInstanceVariableNode new name: each index: index	].! !!CCompiler methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:43'!interactive 	"Answer whether there is a requestor of the compiler who should be 	informed that an error occurred."	^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!CCompiler methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:43'!notify: aString 	"Refer to the comment in Object|notify:."	^self notify: aString at: sourceStream position + 1! !!CCompiler methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:43'!notify: aString at: location	"Refer to the comment in Object|notify:."	requestor == nil		ifTrue: [^SyntaxError 					errorInClass: class					withCode: 						(sourceStream contents							copyReplaceFrom: location							to: location - 1							with: aString)					doitFlag: false]		ifFalse: [^requestor					notify: aString					at: location					in: sourceStream]! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:43'!compile: textOrStream in: aClass notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	^self		translate: sourceStream		noPattern: false		ifFail: failBlock! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:43'!compileNoPattern: textOrStream in: aClass context: aContext notifying: aRequestor ifFail: failBlock	"Similar to #compile:in:notifying:ifFail:, but the compiled code is	expected to be a do-it expression, with no message pattern."	self from: textOrStream		class: aClass		context: aContext		notifying: aRequestor.	^self		translate: sourceStream		noPattern: true		ifFail: failBlock! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 16:23'!doIt: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].	^method! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:43'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].	context == nil		ifTrue: [class addSelector: #DoIt withMethod: method.				value _ receiver DoIt.				InMidstOfFileinNotification signal ifFalse: [					class removeSelectorSimply: #DoIt.				].				^value]		ifFalse: [class addSelector: #DoItIn: withMethod: method.				value _ receiver DoItIn: context.				InMidstOfFileinNotification signal ifFalse: [					class removeSelectorSimply: #DoItIn:.				].				^value]! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/27/2004 05:50'!evaluate: textOrString notifying: aRequestor in: scope	| methodNode method value |	class _ scope.	self from: textOrString class: class context: nil notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:[^nil].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:[method _ method copyWithTempNames: methodNode tempNames].	[class addSelector: #DoIt withMethod: method.	value _ scope uniqueInstance DoIt.	] ensure:[		InMidstOfFileinNotification signal ifFalse: [class removeSelectorSimply: #DoIt].	].	^value! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:54'!format: textOrStream in: aClass notifying: aRequestor contentsSymbol: aSymbol	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	aSymbol == #colorPrint		ifTrue: [^ aNode asColorizedSmalltalk80Text].	^ aNode decompileString! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:43'!format: textOrStream in: aClass notifying: aRequestor decorated: aBoolean	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	^ aBoolean		ifTrue: [aNode decompileText]		ifFalse: [aNode decompileString]! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:43'!parse: textOrStream in: aClass notifying: req	"Compile the argument, textOrStream, with respect to the class, aClass, 	and answer the MethodNode that is the root of the resulting parse tree. 	Notify the argument, req, if an error occurs. The failBlock is defaulted to 	an empty block."	^ self parse: textOrStream in: aClass notifying: req dialect: false! !!CCompiler methodsFor: 'public access' stamp: 'ar 3/27/2004 04:24'!parse: textOrStream in: aClass notifying: req dialect: useDialect        "Compile the argument, textOrStream, with respect to the class, aClass,         and answer the MethodNode that is the root of the resulting parse tree.         Notify the argument, req, if an error occurs. The failBlock is defaulted to         an empty block."        self from: textOrStream class: aClass context: nil notifying: req.        ^parserClass new                        parse: sourceStream                        class: class                        noPattern: false                        context: context                        notifying: requestor                        ifFail: []! !!CCompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!cacheDoItNode: boolean	cacheDoItNode _ boolean! !!CCompiler methodsFor: 'private' stamp: 'ar 3/27/2004 04:24'!format: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !!CCompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!from: textOrStream class: aClass context: aContext notifying: req	(textOrStream isKindOf: PositionableStream)		ifTrue: [sourceStream _ textOrStream]		ifFalse: [sourceStream _ ReadStream on: textOrStream asString].	class _ aClass.	context _ aContext.	requestor _ req! !!CCompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!parserClass	^ parserClass! !!CCompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!parserClass: aParserClass	parserClass _ aParserClass.	cacheDoItNode _ true.! !!CCompiler methodsFor: 'private' stamp: 'ar 3/27/2004 04:24'!translate: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !!CDecompiler methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!initSymbols: aClass	| nTemps namedTemps |	constructor method: method class: aClass literals: method literals.	constTable _ constructor codeConstants.	instVars _ Array new: aClass instSize.	nTemps _ method numTemps.	namedTemps _ tempVars ifNil: [method tempNames].	tempVars _ (1 to: nTemps) collect:				[:i | i <= namedTemps size					ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]					ifFalse: [constructor codeTemp: i - 1]]! !!CDecompiler methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!withTempNames: tempNameArray	tempVars _ tempNameArray! !!CDecompiler methodsFor: 'control' stamp: 'ar 3/26/2004 15:43'!blockForCaseTo: end	"Decompile a range of code as in statementsForCaseTo:, but return a block node."	| exprs block oldBase |	oldBase _ blockStackBase.	blockStackBase _ stack size.	exprs _ self statementsForCaseTo: end.	block _ constructor codeBlock: exprs returns: lastReturnPc = lastPc.	blockStackBase _ oldBase.	lastReturnPc _ -1.  "So as not to mislead outer calls"	^block! !!CDecompiler methodsFor: 'control' stamp: 'ar 3/26/2004 15:43'!blockTo: end	"Decompile a range of code as in statementsTo:, but return a block node."	| exprs block oldBase |	oldBase _ blockStackBase.	blockStackBase _ stack size.	exprs _ self statementsTo: end.	block _ constructor codeBlock: exprs returns: lastReturnPc = lastPc.	blockStackBase _ oldBase.	lastReturnPc _ -1.  "So as not to mislead outer calls"	^block! !!CDecompiler methodsFor: 'control' stamp: 'ar 3/26/2004 15:43'!checkForBlock: receiver	"We just saw a blockCopy: message. Check for a following block."	| savePc jump args argPos block |	receiver == constructor codeThisContext ifFalse: [^false].	savePc _ pc.	(jump _ self interpretJump) notNil		ifFalse:			[pc _ savePc.  ^nil].	"Definitely a block"	jump _ jump + pc.	argPos _ statements size.	[self willStorePop]		whileTrue:			[stack addLast: ArgumentFlag.  "Flag for doStore:"			self interpretNextInstructionFor: self].	args _ Array new: statements size - argPos.	1 to: args size do:  "Retrieve args"		[:i | args at: i put: statements removeLast.		(args at: i) scope: -1  "flag args as block temps"].	block _ self blockTo: jump.	stack addLast: (constructor codeArguments: args block: block).	^true! !!CDecompiler methodsFor: 'control' stamp: 'ar 3/26/2004 15:43'!statementsForCaseTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end.	Note that stack initially contains a CaseFlag which will be removed by	a subsequent Pop instruction, so adjust the StackPos accordingly."	| blockPos stackPos t |	blockPos _ statements size.	stackPos _ stack size - 1. "Adjust for CaseFlag"	[pc < end]		whileTrue:			[lastPc _ pc.  limit _ end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue _ stack size > stackPos)		ifTrue:			[statements addLast: stack removeLast].	lastJumpPc = lastPc ifFalse: [exit _ pc].	^self popTo: blockPos! !!CDecompiler methodsFor: 'control' stamp: 'ar 3/26/2004 15:43'!statementsTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end."	| blockPos stackPos t |	blockPos _ statements size.	stackPos _ stack size.	[pc < end]		whileTrue:			[lastPc _ pc.  limit _ end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue _ stack size > stackPos)		ifTrue:			[statements addLast: stack removeLast].	lastJumpPc = lastPc ifFalse: [exit _ pc].	^self popTo: blockPos! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!blockReturnTop	"No action needed"! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!case: dist	"statements = keyStmts CascadeFlag keyValueBlock ... keyStmts"	| nextCase end thenJump stmtStream elements b node cases otherBlock |	nextCase _ pc + dist.	end _ limit.	"Now add CascadeFlag & keyValueBlock to statements"	statements addLast: stack removeLast.	stack addLast: CaseFlag. "set for next pop"	statements addLast: (self blockForCaseTo: nextCase).	stack last == CaseFlag		ifTrue: "Last case"			["ensure jump is within block (in case thenExpr returns wierdly I guess)"			stack removeLast. "get rid of CaseFlag".			thenJump _ exit <= end ifTrue: [exit] ifFalse: [nextCase].			stmtStream _ ReadStream on: (self popTo: stack removeLast).			elements _ OrderedCollection new.			b _ OrderedCollection new.			[stmtStream atEnd] whileFalse:				[(node _ stmtStream next) == CascadeFlag					ifTrue:						[elements addLast: (constructor							codeMessage: (constructor codeBlock: b returns: false)							selector: (constructor codeSelector: #-> code: #macro)							arguments: (Array with: stmtStream next)).						 b _ OrderedCollection new]					ifFalse: [b addLast: node]].			b size > 0 ifTrue: [self error: 'Bad cases'].			cases _ constructor codeBrace: elements.			otherBlock _ self blockTo: thenJump.			stack addLast:				(constructor					codeMessage: stack removeLast					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)					arguments: (Array with: cases with: otherBlock))]! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!doDup	stack last == CascadeFlag		ifFalse:			["Save position and mark cascade"			stack addLast: statements size.			stack addLast: CascadeFlag].	stack addLast: CascadeFlag! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!doPop	stack isEmpty ifTrue:		["Ignore pop in first leg of ifNil for value"		^ self].	stack last == CaseFlag		ifTrue: [stack removeLast]		ifFalse: [statements addLast: stack removeLast].! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!doStore: stackOrBlock	"Only called internally, not from InstructionStream. StackOrBlock is stack	for store, statements for storePop."	| var expr |	var _ stack removeLast.	expr _ stack removeLast.	stackOrBlock addLast: (expr == ArgumentFlag		ifTrue: [var]		ifFalse: [constructor codeAssignTo: var value: expr])! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!jump: dist	exit _ pc + dist.	lastJumpPc _ lastPc! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!jump: dist if: condition	| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump		elseJump condHasValue b isIfNil saveStack |	stack last == CascadeFlag ifTrue: [^ self case: dist].	elsePc _ lastPc.	elseStart _ pc + dist.	end _ limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign _ condition.	savePc _ pc.	((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])		ifTrue: [sign _ sign not.  elseStart _ pc + elseDist].	pc _ savePc.	ifExpr _ stack removeLast.	(stack size > 0 and: [stack last == IfNilFlag])		ifTrue: [stack removeLast.  isIfNil _ true]		ifFalse: [isIfNil _ false].	saveStack _ stack.	stack _ OrderedCollection new.	thenBlock _ self blockTo: elseStart.	condHasValue _ hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			thenJump will jump to the beginning of the while expr.  In the case of			while's with a block in the condition, the while expr			should include more than just the last expression: find all the			statements needed by re-decompiling."			stack _ saveStack.			pc _ thenJump.			b _ self statementsTo: elsePc.			"discard unwanted statements from block"			b size - 1 timesRepeat: [statements removeLast].			statements addLast: (constructor					codeMessage: (constructor codeBlock: b returns: false)					selector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)					arguments: (Array with: thenBlock)).			pc _ elseStart.			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock _ self blockTo: thenJump.			elseJump _ exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc				ifTrue: [pc _ lastPc].			isIfNil			ifTrue: [cond _ constructor						codeMessage: ifExpr ifNilReceiver						selector: (sign							ifTrue: [constructor codeSelector: #ifNotNil: code: #macro]							ifFalse: [constructor codeSelector: #ifNil: code: #macro])						arguments: (Array with: thenBlock)]			ifFalse: [cond _ constructor						codeMessage: ifExpr						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)						arguments:							(sign								ifTrue: [Array with: elseBlock with: thenBlock]								ifFalse: [Array with: thenBlock with: elseBlock])].			stack _ saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!methodReturnConstant: value	self pushConstant: value; methodReturnTop! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!methodReturnReceiver	self pushReceiver; methodReturnTop! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!methodReturnTop	| last |	last _ stack removeLast "test test" asReturnNode.	stack size > blockStackBase  "get effect of elided pop before return"		ifTrue: [statements addLast: stack removeLast].	exit _ method size + 1.	lastJumpPc _ lastReturnPc _ lastPc.	statements addLast: last! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!popIntoLiteralVariable: value	self pushLiteralVariable: value; doStore: statements! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!popIntoReceiverVariable: offset	self pushReceiverVariable: offset; doStore: statements! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!popIntoTemporaryVariable: offset	self pushTemporaryVariable: offset; doStore: statements! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!pushActiveContext	stack addLast: constructor codeThisContext! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!pushConstant: value	| node |	node _ value == true ifTrue: [constTable at: 2]		ifFalse: [value == false ifTrue: [constTable at: 3]		ifFalse: [value == nil ifTrue: [constTable at: 4]		ifFalse: [constructor codeAnyLiteral: value]]].	stack addLast: node! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!pushLiteralVariable: assoc	stack addLast: (constructor codeAnyLitInd: assoc)! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!pushReceiver	stack addLast: (constTable at: 1)! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!pushReceiverVariable: offset	| var |	(var _ instVars at: offset + 1) == nil		ifTrue:			["Not set up yet"			instVars at: offset + 1 put: (var _ constructor codeInst: offset)].	stack addLast: var! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!pushTemporaryVariable: offset	stack addLast: (tempVars at: offset + 1)! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!send: selector super: superFlag numArgs: numArgs	| args rcvr selNode msgNode messages |	args _ Array new: numArgs.	(numArgs to: 1 by: -1) do:		[:i | args at: i put: stack removeLast].	rcvr _ stack removeLast.	superFlag ifTrue: [rcvr _ constructor codeSuper].	(selector == #blockCopy: and: [self checkForBlock: rcvr])		ifFalse:			[selNode _ constructor codeAnySelector: selector.			rcvr == CascadeFlag				ifTrue:					["May actually be a cascade or an ifNil: for value."					self willJumpIfFalse						ifTrue: "= generated by a case macro"							[selector == #= ifTrue:								[" = signals a case statement..."								statements addLast: args first.								stack addLast: rcvr. "restore CascadeFlag"								^ self].							selector == #== ifTrue:								[" == signals an ifNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							self error: 'bad case: ', selector]						ifFalse:							[(self willJumpIfTrue and: [selector == #==]) ifTrue:								[" == signals an ifNotNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							msgNode _ constructor codeCascadedMessage: selNode											arguments: args].					stack last == CascadeFlag						ifFalse:							["Last message of a cascade"							statements addLast: msgNode.							messages _ self popTo: stack removeLast.  "Depth saved by first dup"							msgNode _ constructor								codeCascade: stack removeLast								messages: messages]]				ifFalse:					[msgNode _ constructor								codeMessage: rcvr								selector: selNode								arguments: args].			stack addLast: msgNode]! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!storeIntoLiteralVariable: assoc	self pushLiteralVariable: assoc; doStore: stack! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!storeIntoReceiverVariable: offset	self pushReceiverVariable: offset; doStore: stack! !!CDecompiler methodsFor: 'instruction decoding' stamp: 'ar 3/26/2004 15:43'!storeIntoTemporaryVariable: offset	self pushTemporaryVariable: offset; doStore: stack! !!CDecompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:43'!decompile: aSelector in: aClass 	"See Decompiler|decompile:in:method:. The method is found by looking up 	the message, aSelector, in the method dictionary of the class, aClass."	^self		decompile: aSelector		in: aClass		method: (aClass compiledMethodAt: aSelector)! !!CDecompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:52'!decompile: aSelector in: aClass method: aMethod	"Answer a MethodNode that is the root of the parse tree for the 	argument, aMethod, which is the CompiledMethod associated with the 	message, aSelector. Variables are determined with respect to the 	argument, aClass."	^self		decompile: aSelector		in: aClass		method: aMethod		using: CDecompilerConstructor new! !!CDecompiler methodsFor: 'public access' stamp: 'ar 3/26/2004 15:43'!tempAt: offset	"Needed by BraceConstructor<PopIntoTemporaryVariable"	^tempVars at: offset + 1! !!CDecompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:48'!convertToDoLoop	"If statements contains the pattern		var _ startExpr.		[var <= limit] whileTrue: [...statements... var _ var + incConst]	then replace this by		startExpr to: limit by: incConst do: [:var | ...statements...]"	| initStmt toDoStmt limitStmt |	statements size < 2 ifTrue: [^ self].	initStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoFromWhileWithInit: initStmt)		== nil ifTrue: [^ self].	initStmt variable scope: -1.  "Flag arg as block temp"	statements removeLast; removeLast; addLast: toDoStmt.	"Attempt further conversion of the pattern		limitVar _ limitExpr.		startExpr to: limitVar by: incConst do: [:var | ...statements...]	to		startExpr to: limitExpr by: incConst do: [:var | ...statements...]"	statements size < 2 ifTrue: [^ self].	limitStmt _ statements at: statements size-1.	((limitStmt isMemberOf: CAssignmentNode)		and: [limitStmt variable isTemp		and: [limitStmt variable == toDoStmt arguments first		and: [self methodRefersOnlyOnceToTemp: limitStmt variable fieldOffset]]])		ifFalse: [^ self].	toDoStmt arguments at: 1 put: limitStmt value.	limitStmt variable scope: -2.  "Flag limit var so it won't print"	statements removeLast; removeLast; addLast: toDoStmt.! !!CDecompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block |	constructor _ aConstructor.	method _ aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block _ self quickMethod]		ifFalse: 			[stack _ OrderedCollection new: method frameSize.			statements _ OrderedCollection new: 20.			super method: method pc: method initialPC.			block _ self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	^constructor		codeMethod: aSelector		block: block		tempVars: (tempVars select: [:t | t scope >=0])		primitive: method primitive		class: aClass! !!CDecompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:52'!interpretNextInstructionFor: client	| code varNames |"Change false here will trace all state in Transcript."true ifTrue: [^ super interpretNextInstructionFor: client].	varNames _ CDecompiler allInstVarNames.	code _ (self method at: pc) radix: 16.	Transcript cr; cr; print: pc; space;		nextPutAll: '<' , (code copyFrom: 4 to: code size) , '>'.	8 to: varNames size do:		[:i | i <= 10 ifTrue: [Transcript cr]				ifFalse: [Transcript space; space].		Transcript nextPutAll: (varNames at: i);				nextPutAll: ': '; print: (self instVarAt: i)].	Transcript endEntry.	^ super interpretNextInstructionFor: client! !!CDecompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!methodRefersOnlyOnceToTemp: offset	| nRefs byteCode extension scanner |	nRefs _ 0.	offset <= 15		ifTrue:			[byteCode _ 16 + offset.			(InstructionStream on: method) scanFor:				[:instr | instr = byteCode ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]]		ifFalse:			[extension _ 64 + offset.			scanner _ InstructionStream on: method.			scanner scanFor:				[:instr | (instr = 128 and: [scanner followingByte = extension])							ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]].	^ nRefs = 1! !!CDecompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!popTo: oldPos	| t |	t _ Array new: statements size - oldPos.	(t size to: 1 by: -1) do:		[:i | t at: i put: statements removeLast].	^t! !!CDecompiler methodsFor: 'private' stamp: 'ar 3/26/2004 15:43'!quickMethod	| |	method isReturnSpecial		ifTrue: [^ constructor codeBlock:				(Array with: (constTable at: method primitive - 255)) returns: true].	method isReturnField		ifTrue: [^ constructor codeBlock:				(Array with: (constructor codeInst: method returnField)) returns: true].	self error: 'improper short method'! !!CDeprecatedFeature methodsFor: 'as yet unclassified' stamp: 'ar 8/10/2003 20:31'!defaultAction	"By default, allow using deprecated features"	^true! !!CDeprecatedFeature methodsFor: 'as yet unclassified' stamp: 'ar 8/10/2003 20:34'!isResumable	^true! !!CDialectStream methodsFor: 'color/style' stamp: 'ar 3/26/2004 15:54'!colorTable	"Answer the table to use to determine colors"	^ colorTable ifNil:		[colorTable _ dialect == #SQ00			ifTrue:				[Sq00ColorTable]			ifFalse:				[ST80ColorTable]]! !!CDialectStream methodsFor: 'color/style' stamp: 'ar 3/26/2004 15:54'!withColor: colorSymbol emphasis: emphasisSymbol do: aBlock	"Evaluate the given block with the given color and style text attribute"	^ self withAttributes: {TextColor color: (Color perform: colorSymbol).							TextEmphasis perform: emphasisSymbol}		do: aBlock! !!CDialectStream methodsFor: 'color/style' stamp: 'ar 3/26/2004 15:54'!withStyleFor: elementType do: aBlock	"Evaluate aBlock with appropriate emphasis and color for the given elementType"	| colorAndStyle |	colorAndStyle _ self colorTable at: elementType.	^ self withColor: colorAndStyle first emphasis: colorAndStyle second do: aBlock! !!CDialectStream methodsFor: 'access' stamp: 'ar 3/26/2004 15:54'!dialect	^ dialect! !!CDialectStream methodsFor: 'access' stamp: 'ar 3/26/2004 15:54'!setDialect: dialectSymbol	dialect _ dialectSymbol! !!CLiteralDictionary methodsFor: 'as yet unclassified' stamp: 'ar 3/26/2004 15:44'!arrayEquality: x and: y	x size = y size ifFalse: [^ false].	x with: y do: [:e1 :e2 | 		(self literalEquality: e1 and: e2) ifFalse: [^ false]	].	^true.! !!CLiteralDictionary methodsFor: 'as yet unclassified' stamp: 'ar 3/26/2004 15:44'!literalEquality: x and: y	^ (x class = Array and: [y class = Array]) ifTrue: [		self arrayEquality: x and: y.	] ifFalse: [		(x class == y class) and: [x = y]	].! !!CLiteralDictionary methodsFor: 'as yet unclassified' stamp: 'ar 3/26/2004 15:44'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!assignmentCheck: encoder at: location	"For messageNodes masquerading as variables for the debugger.	For now we let this through - ie we allow stores ev	into args.  Should check against numArgs, though."	^ -1! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!canCascade	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isArg	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isComplex	"Used for pretty printing to determine whether to start a new line"	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isConstantNumber  "Overridden in LiteralNode"	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isLiteral	^ false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"See comment in MessageNode."	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isMessageNode	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isReturnSelf	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isReturningIf	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isSelfPseudoVariable		"Overridden in VariableNode."	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isSpecialConstant	^ false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isTemp	^ false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isUndefTemp	^ false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isUnusedTemp	^ false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isVariableNode	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isVariableReference	^false! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!nowHasDef  "Ignored in all but VariableNode"! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!nowHasRef  "Ignored in all but VariableNode"! !!CParseNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!toDoIncrement: ignored	"Only meant for Messages or Assignments - else return nil"	^ nil! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitBranchOn:condition dist: dist pop: stack on: strm	stack pop: 1.	dist = 0 ifTrue: [^ strm nextPut: Pop].	condition		ifTrue: [self emitLong: dist code: BtpLong on: strm]		ifFalse: [self emitShortOrLong: dist code: Bfp on: strm]! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitForEffect: stack on: strm	self emitForValue: stack on: strm.	strm nextPut: Pop.	stack pop: 1! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitForReturn: stack on: strm	self emitForValue: stack on: strm.	strm nextPut: EndMethod! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitJump: dist on: strm	dist = 0 ifFalse: [self emitShortOrLong: dist code: Jmp on: strm]! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitLong: dist code: longCode on: aStream 	"Force a two-byte jump."	| code distance |	code _ longCode.	distance _ dist.	distance < 0		ifTrue: 			[distance _ distance + 1024.			code _ code - 4]		ifFalse: 			[distance > 1023 ifTrue: [distance _ -1]].	distance < 0		ifTrue: 			[self error: 'A block compiles more than 1K bytes of code']		ifFalse: 			[aStream nextPut: distance // 256 + code.			aStream nextPut: distance \\ 256]! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitShortOrLong: dist code: shortCode on: strm	(1 <= dist and: [dist <= JmpLimit])		ifTrue: [strm nextPut: shortCode + dist - 1]		ifFalse: [self emitLong: dist code: shortCode + (JmpLong-Jmp) on: strm]! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!pc	"Used by encoder source mapping."	pc==nil ifTrue: [^0] ifFalse: [^pc]! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeBranchOn: condition dist: dist	dist = 0 ifTrue: [^1].	^ condition		ifTrue: [2]  "Branch on true is always 2 bytes"		ifFalse: [self sizeShortOrLong: dist]! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeForEffect: encoder	^(self sizeForValue: encoder) + 1! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeForReturn: encoder	^(self sizeForValue: encoder) + 1! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeJump: dist	dist = 0 ifTrue: [^0].	^self sizeShortOrLong: dist! !!CParseNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeShortOrLong: dist	(1 <= dist and: [dist <= JmpLimit])		ifTrue: [^1].	^2! !!CParseNode methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:45'!encodeSelector: selector	^nil! !!CParseNode methodsFor: 'comment' stamp: 'ar 3/26/2004 15:45'!comment	^comment! !!CParseNode methodsFor: 'comment' stamp: 'ar 3/26/2004 15:45'!comment: newComment	comment _ newComment! !!CParseNode methodsFor: 'converting' stamp: 'ar 3/26/2004 16:00'!asReturnNode	^CReturnNode new expr: self! !!CParseNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!nodePrintOn: aStrm indent: nn	| var aaStrm myLine |	"Show just the sub nodes and the code."	(aaStrm _ aStrm) ifNil: [aaStrm _ WriteStream on: (String new: 500)].	nn timesRepeat: [aaStrm tab].	aaStrm nextPutAll: self class name; space.	myLine _ self printString copyWithout: Character cr.	myLine _ myLine copyFrom: 1 to: (myLine size min: 70).	aaStrm nextPutAll: myLine; cr.	1 to: self class instSize do: [:ii | 		var _ self instVarAt: ii.		(var respondsTo: #asReturnNode) ifTrue: [var nodePrintOn: aaStrm indent: nn+1]].	1 to: self class instSize do: [:ii | 		var _ self instVarAt: ii.		(var isKindOf: SequenceableCollection) ifTrue: [				var do: [:aNode | 					(aNode respondsTo: #asReturnNode) ifTrue: [						aNode nodePrintOn: aaStrm indent: nn+1]]]].	^ aaStrm! !!CParseNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^ self].	aStream withStyleFor: #comment		do: [1 to: comment size do: 				[:index | 				index > 1 ifTrue: [aStream crtab: indent].				aStream nextPut: $".				thisComment _ comment at: index.				self printSingleComment: thisComment					on: aStream					indent: indent.				aStream nextPut: $"]].	comment _ nil! !!CParseNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:54'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: '{'.	aStream nextPutAll: ((CDialectStream dialect: #ST80								contents: [:strm | self printOn: strm indent: 0])							asString).	aStream nextPutAll: '}'! !!CParseNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printOn: aStream indent: anInteger 	"If control gets here, avoid recursion loop."	super printOn: aStream! !!CParseNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printOn: aStream indent: level precedence: p	self printOn: aStream indent: level! !!CParseNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!nextWordFrom: aStream setCharacter: aBlock	| outStream char |	outStream _ WriteStream on: (String new: 16).	[(aStream peekFor: Character space) 		or: [aStream peekFor: Character tab]] whileTrue.	[aStream atEnd		or:			[char _ aStream next.			char = Character cr or: [char = Character space]]]		whileFalse: [outStream nextPut: char].	aBlock value: char.	^ outStream contents! !!CParseNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.	Break the string at word breaks, given the widths in the default	font, at 450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth lastChar |	readStream _ ReadStream on: aString.	font _ TextStyle default defaultFont.	tabWidth _ TextConstants at: #DefaultTab.	spaceWidth _ font widthOf: Character space.	position _ indent * tabWidth.	lineBreak _ 450.	[readStream atEnd]		whileFalse: 			[word _ self nextWordFrom: readStream setCharacter: [:lc | lastChar _ lc].			wordWidth _ word inject: 0 into: [:width :char | width + (font widthOf: char)].			position _ position + wordWidth.			position > lineBreak				ifTrue: 					[aStream crtab: indent.					position _ indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					word isEmpty ifFalse: [aStream nextPutAll: word; space]]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position _ position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream crtab: indent.							position _ indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !!CAssignmentNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:57'!toDoIncrement: var	var = variable ifFalse: [^ nil].	(value isMemberOf: CMessageNode) 		ifTrue: [^ value toDoIncrement: var]		ifFalse: [^ nil]! !!CAssignmentNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:42'!value	^ value! !!CAssignmentNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:42'!variable: aVariable value: expression	variable _ aVariable.	value _ expression! !!CAssignmentNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:57'!variable: aVariable value: expression from: encoder	(aVariable isMemberOf: CMessageAsTempNode)		ifTrue: ["Case of remote temp vars"				^ aVariable store: expression from: encoder].	variable _ aVariable.	value _ expression! !!CAssignmentNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:42'!variable: aVariable value: expression from: encoder sourceRange: range	encoder noteSourceRange: range forNode: self.	^self		variable: aVariable		value: expression		from: encoder! !!CAssignmentNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!emitForEffect: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	variable emitStorePop: stack on: aStream.	pc _ aStream position! !!CAssignmentNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!emitForValue: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	variable emitStore: stack on: aStream.	pc _ aStream position! !!CAssignmentNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!sizeForEffect: encoder	^(value sizeForValue: encoder)		+ (variable sizeForStorePop: encoder)! !!CAssignmentNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!sizeForValue: encoder	^(value sizeForValue: encoder)		+ (variable sizeForStore: encoder)! !!CAssignmentNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:28'!printOn: aStream indent: level	variable printOn: aStream indent: level.	aStream nextPutAll: ' _ '.	value printOn: aStream indent: level + 2! !!CAssignmentNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:28'!printOn: aStream indent: level precedence: p	(p < 4)		ifTrue: [aStream nextPutAll: '('.				self printOn: aStream indent: level.				aStream nextPutAll: ')']		ifFalse: [self printOn: aStream indent: level]! !!CAssignmentNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:42'!variable	^variable! !!CBlockNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:42'!arguments: argNodes statements: statementsCollection returns: returnBool from: encoder	"Compile."	arguments _ argNodes.	statements _ statementsCollection size > 0				ifTrue: [statementsCollection]				ifFalse: [argNodes size > 0						ifTrue: [statementsCollection copyWith: arguments last]						ifFalse: [Array with: NodeNil]].	returns _ returnBool! !!CBlockNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:42'!arguments: argNodes statements: statementsCollection returns: returnBool from: encoder sourceRange: range	"Compile."	encoder noteSourceRange: range forNode: self.	^self		arguments: argNodes		statements: statementsCollection		returns: returnBool		from: encoder! !!CBlockNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:42'!statements: statementsCollection returns: returnBool 	"Decompile."	| returnLast |	returnLast _ returnBool.	returns _ false.	statements _ 		(statementsCollection size > 1 			and: [(statementsCollection at: statementsCollection size - 1) 					isReturningIf])				ifTrue: 					[returnLast _ false.					statementsCollection allButLast]				ifFalse: [statementsCollection size = 0						ifTrue: [Array with: NodeNil]						ifFalse: [statementsCollection]].	arguments _ #().	temporaries _ #().	returnLast ifTrue: [self returnLast]! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!arguments: argNodes 	"Decompile."	arguments _ argNodes! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!block	^ self! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!firstArgument	^ arguments first! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!numberOfArguments	^arguments size! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!returnLast	self returns		ifFalse: 			[returns _ true.			statements at: statements size put: statements last asReturnNode]! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!returnNilIfNoOther	self returns		ifFalse: 			[statements last == NodeNil ifFalse: [statements add: NodeNil].			self returnLast]! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!returnSelfIfNoOther	self returns		ifFalse: 			[statements last == NodeSelf ifFalse: [statements add: NodeSelf].			self returnLast]! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!returnSelfIfNoOther: encoder	self returns ifTrue:[^self].	statements last == NodeSelf ifFalse: [		statements add: (encoder encodeVariable: 'self').	].	self returnLast.! !!CBlockNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:42'!temporaries: aCollection	temporaries _ aCollection! !!CBlockNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:42'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^arguments size = 0! !!CBlockNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:42'!isComplex	^statements size > 1 or: [statements size = 1 and: [statements first isComplex]]! !!CBlockNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:42'!isJust: node	returns ifTrue: [^false].	^statements size = 1 and: [statements first == node]! !!CBlockNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:42'!isJustCaseError	^ statements size = 1 and:		[statements first			isMessage: #caseError			receiver: [:r | r==NodeSelf]			arguments: nil]! !!CBlockNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:42'!isQuick	^ statements size = 1		and: [statements first isVariableReference				or: [statements first isSpecialConstant]]! !!CBlockNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:42'!returns	^returns or: [statements last isReturningIf]! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!code	^statements first code! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!emitExceptLast: stack on: aStream	| nextToLast |	nextToLast _ statements size - 1.	nextToLast < 1 ifTrue: [^ self].  "Only one statement"	1 to: nextToLast do:		[:i | (statements at: i) emitForEffect: stack on: aStream].! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!emitForEvaluatedEffect: stack on: aStream	self returns		ifTrue: 			[self emitForEvaluatedValue: stack on: aStream.			stack pop: 1]		ifFalse: 			[self emitExceptLast: stack on: aStream.			statements last emitForEffect: stack on: aStream]! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!emitForEvaluatedValue: stack on: aStream	self emitExceptLast: stack on: aStream.	statements last emitForValue: stack on: aStream.! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!emitForValue: stack on: aStream	aStream nextPut: LdThisContext.	stack push: 1.	nArgsNode emitForValue: stack on: aStream.	remoteCopyNode		emit: stack		args: 1		on: aStream.	"Force a two byte jump."	self emitLong: size code: JmpLong on: aStream.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitStorePop: stack on: aStream].	self emitForEvaluatedValue: stack on: aStream.	self returns ifFalse: [		aStream nextPut: EndRemote.		pc _ aStream position.	].	stack pop: 1! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!sizeExceptLast: encoder	| codeSize nextToLast |	nextToLast _ statements size - 1.	nextToLast < 1 ifTrue: [^ 0]. "Only one statement"	codeSize _ 0.	1 to: nextToLast do: 		[:i | codeSize _ codeSize + ((statements at: i) sizeForEffect: encoder)].	^ codeSize! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!sizeForEvaluatedEffect: encoder	self returns ifTrue: [^self sizeForEvaluatedValue: encoder].	^(self sizeExceptLast: encoder)		+ (statements last sizeForEffect: encoder)! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!sizeForEvaluatedValue: encoder	^(self sizeExceptLast: encoder)		+ (statements last sizeForValue: encoder)! !!CBlockNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:42'!sizeForValue: encoder	nArgsNode _ encoder encodeLiteral: arguments size.	remoteCopyNode _ encoder encodeSelector: #blockCopy:.	size _ (self sizeForEvaluatedValue: encoder)				+ (self returns ifTrue: [0] ifFalse: [1]). "endBlock"	arguments _ arguments collect:  "Chance to prepare debugger remote temps"				[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size _ size + (arg sizeForStorePop: encoder)].	^1 + (nArgsNode sizeForValue: encoder) 		+ (remoteCopyNode size: encoder args: 1 super: false) + 2 + size! !!CBlockNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:28'!printArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^ self].	arguments do: [:arg | 		aStream			withStyleFor: #blockArgument			do: [aStream nextPutAll: ':'; nextPutAll: arg key; space]	].	aStream nextPutAll: '| '.	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue: [aStream crtab: level]! !!CBlockNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:42'!printOn: aStream indent: level	"statements size <= 1 ifFalse: [aStream crtab: level]."	aStream nextPut: $[.	self printArgumentsOn: aStream indent: level.	self printTemporariesOn: aStream indent: level.	self printStatementsOn: aStream indent: level.	aStream nextPut: $]! !!CBlockNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:42'!printStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level _ 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printCommentOn: aStream indent: level.			aStream crtab: level].	len _ shown _ statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown _ 1 max: shown - 1]		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])					ifTrue: [shown _ shown - 1]].	1 to: shown do: 		[:i | 		thisStatement _ statements at: i.		thisStatement printOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!CBlockNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:42'!printTemporariesOn: aStream indent: level	(temporaries == nil or: [temporaries size = 0])		ifFalse: 			[aStream nextPut: $|.			temporaries do: 				[:arg | 				aStream					space;					withStyleFor: #temporaryVariable						do: [aStream nextPutAll: arg key]].			aStream nextPutAll: ' | '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !!CBlockNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:42'!statements	^statements! !!CBlockNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:42'!statements: val	statements _ val! !!CBraceNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!elements: collection	"Decompile."	elements _ collection! !!CBraceNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!elements: collection sourceLocations: locations	"Compile."	elements _ collection.	sourceLocations _ locations! !!CBraceNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!matchBraceStreamReceiver: receiver messages: messages	((receiver isMessage: #braceStream: receiver: nil arguments: [:arg | arg isConstantNumber])		and: [messages last isMessage: #braceArray receiver: nil arguments: nil])		ifFalse: [^ nil "no match"].	"Appears to be a long form brace construct"	self elements: (messages allButLast collect:		[:msg | (msg isMessage: #nextPut: receiver: nil arguments: nil)					ifFalse: [^ nil "not a brace element"].		msg arguments first])! !!CBraceNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!matchBraceWithReceiver: receiver selector: selector arguments: arguments	selector = (self selectorForShortForm: arguments size)		ifFalse: [^ nil "no match"].	"Appears to be a short form brace construct"	self elements: arguments! !!CBraceNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:49'!blockAssociationCheck: encoder	"If all elements are MessageNodes of the form [block]->[block], and there is at	 least one element, answer true.	 Otherwise, notify encoder of an error."	elements size = 0		ifTrue: [^encoder notify: 'At least one case required'].	elements with: sourceLocations do:			[:x :loc |			(x 	isMessage: #->				receiver:					[:rcvr |					(rcvr isKindOf: CBlockNode) and: [rcvr numberOfArguments = 0]]				arguments:					[:arg |					(arg isKindOf: CBlockNode) and: [arg numberOfArguments = 0]])			  ifFalse:				[^encoder notify: 'Association between 0-argument blocks required' at: loc]].	^true! !!CBraceNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:43'!numElements	^ elements size! !!CBraceNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:43'!emitForValue: stack on: aStream	^ emitNode emitForValue: stack on: aStream! !!CBraceNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:43'!selectorForShortForm: nElements	nElements > 4 ifTrue: [^ nil].	^ #(braceWithNone braceWith: braceWith:with:			braceWith:with:with: braceWith:with:with:with:) at: nElements + 1! !!CBraceNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:57'!sizeForValue: encoder	emitNode _ elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				CMessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CCascadeNode new					receiver: (CMessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | CMessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (CMessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^ emitNode sizeForValue: encoder! !!CBraceNode methodsFor: 'enumerating' stamp: 'ar 3/26/2004 15:43'!casesForwardDo: aBlock	"For each case in forward order, evaluate aBlock with three arguments:	 the key block, the value block, and whether it is the last case."	| numCases case |	1 to: (numCases _ elements size) do:		[:i |		case _ elements at: i.		aBlock value: case receiver value: case arguments first value: i=numCases]! !!CBraceNode methodsFor: 'enumerating' stamp: 'ar 3/26/2004 15:43'!casesReverseDo: aBlock	"For each case in reverse order, evaluate aBlock with three arguments:	 the key block, the value block, and whether it is the last case."	| numCases case |	(numCases _ elements size) to: 1 by: -1 do:		[:i |		case _ elements at: i.		aBlock value: case receiver value: case arguments first value: i=numCases]! !!CBraceNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:43'!printOn: aStream indent: level	aStream nextPut: ${.	1 to: elements size do: 		[:i | (elements at: i) printOn: aStream indent: level.		i < elements size ifTrue: [aStream nextPutAll: '. ']].	aStream nextPut: $}! !!CCascadeNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!receiver: receivingObject messages: msgs	" Transcript show: 'abc'; cr; show: 'def' "	receiver _ receivingObject.	messages _ msgs! !!CCascadeNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:43'!emitForValue: stack on: aStream	receiver emitForValue: stack on: aStream.	1 to: messages size - 1 do: 		[:i | 		aStream nextPut: Dup.		stack push: 1.		(messages at: i) emitForValue: stack on: aStream.		aStream nextPut: Pop.		stack pop: 1].	messages last emitForValue: stack on: aStream! !!CCascadeNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:43'!sizeForValue: encoder	| size |	size _ (receiver sizeForValue: encoder) + (messages size - 1 * 2).	messages do: [:aMessage | size _ size + (aMessage sizeForValue: encoder)].	^size! !!CCascadeNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:43'!printOn: aStream indent: level	self printOn: aStream indent: level precedence: 0! !!CCascadeNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:43'!printOn: aStream indent: level precedence: p 	p > 0 ifTrue: [aStream nextPut: $(].	messages first printReceiver: receiver on: aStream indent: level.	1 to: messages size do: 		[:i | (messages at: i) printOn: aStream indent: level.		i < messages size ifTrue: 				[aStream nextPut: $;.				messages first precedence >= 2 ifTrue: [aStream crtab: level + 1]]].	p > 0 ifTrue: [aStream nextPut: $)]! !!CCascadeNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:43'!receiver	^receiver! !!CDecompilerConstructor methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!method: aMethod class: aClass literals: literals	method _ aMethod.	instVars _ aClass allInstVarNames.	nArgs _ method numArgs.	literalValues _ literals! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 16:02'!codeAnyLitInd: association	^CVariableNode new		name: association key		key: association		index: 0		type: LdLitIndType! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:56'!codeAnyLiteral: value	^CLiteralNode new		key: value		index: 0		type: LdLitType! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 16:00'!codeAnySelector: selector	^CSelectorNode new		key: selector		index: 0		type: SendType! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:43'!codeArguments: args block: block	^block arguments: args! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:48'!codeAssignTo: variable value: expression	^CAssignmentNode new variable: variable value: expression! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:49'!codeBlock: statements returns: returns	^ CBlockNode statements: statements returns: returns! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:50'!codeBrace: elements	^CBraceNode new elements: elements! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:50'!codeCascade: receiver messages: messages	^ (CBraceNode new matchBraceStreamReceiver: receiver messages: messages)		ifNil: [CCascadeNode new receiver: receiver messages: messages]! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:43'!codeCascadedMessage: selector arguments: arguments	^self		codeMessage: nil		selector: selector		arguments: arguments! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:56'!codeConstants	"Answer with an array of the objects representing self, true, false, nil,	-1, 0, 1, 2."	^(Array with: NodeSelf with: NodeTrue with: NodeFalse with: NodeNil)		, ((-1 to: 2) collect: [:i | CLiteralNode new key: i code: LdMinus1 + i + 1])! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:49'!codeEmptyBlock	^ CBlockNode withJust: NodeNil! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 16:02'!codeInst: index	^CVariableNode new		name: (instVars at: index + 1)		index: index		type: LdInstType! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:57'!codeMessage: receiver selector: selector arguments: arguments	| symbol node |	symbol _ selector key.	(node _ CBraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node _ self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ CMessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: symbol precedence! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 5/6/2004 03:05'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| node |	node _ self codeSelector: selector code: nil.	tempVars _ vars.	^CMethodNode new		selector: node		arguments: (tempVars copyFrom: 1 to: nArgs)		precedence: selector precedence		temporaries: (tempVars copyFrom: nArgs + 1 to: tempVars size)		block: block		encoder: (CEncoder new initScopeAndLiteralTables					temps: tempVars					literals: literalValues					class: class)		primitive: primitive		properties: method properties! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 16:00'!codeSelector: sel code: code	^CSelectorNode new key: sel code: code! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:43'!codeSuper	^NodeSuper! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 16:01'!codeTemp: index	^ CTempVariableNode new		name: 't' , (index + 1) printString		index: index		type: LdTempType		scope: 0! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 16:01'!codeTemp: index named: tempName	^ CTempVariableNode new		name: tempName		index: index		type: LdTempType		scope: 0! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 15:43'!codeThisContext	^NodeThisContext! !!CDecompilerConstructor methodsFor: 'constructor' stamp: 'ar 3/26/2004 16:00'!decodeIfNilWithReceiver: receiver selector: selector arguments: arguments	selector == #ifTrue:ifFalse:		ifFalse: [^ nil].	(receiver isMessage: #==				receiver: nil				arguments: [:argNode | argNode == NodeNil])		ifFalse: [^ nil].	^ (CMessageNode new			receiver: receiver			selector: (CSelectorNode new key: #ifTrue:ifFalse: code: #macro)			arguments: arguments			precedence: 3)		noteSpecialSelector: #ifNil:ifNotNil:! !!CEncoder methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!fillDict: dict with: nodeClass mapping: keys to: codeArray	| codeStream |	codeStream _ ReadStream on: codeArray.	keys do: 		[:key | dict 				at: key				put:  (nodeClass new name: key key: key code: codeStream next)]! !!CEncoder methodsFor: 'initialize-release' stamp: 'ar 3/27/2004 02:13'!init: aClass context: aContext notifying: req	| node n homeNode indexNode |	requestor _ req.	class _ aClass.	nTemps _ 0.	supered _ false.	self initScopeAndLiteralTables.	n _ -1.	class ifNotNil:[		class variableNodes do:[:varNode| scopeTable at: varNode name put: varNode].	].	aContext == nil		ifFalse: 			[homeNode _ self bindTemp: 'homeContext'.			"first temp = aContext passed as arg"			n _ 0.			aContext tempNames do: 				[:variable | 				indexNode _ self encodeLiteral: (n _ n + 1).				node _ CMessageAsTempNode new							receiver: homeNode							selector: #tempAt:							arguments: (Array with: indexNode)							precedence: 3							from: self.				scopeTable at: variable put: node]].	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!CEncoder methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!initScopeAndLiteralTables	scopeTable _ StdVariables copy.	litSet _ StdLiterals copy.	selectorSet _ StdSelectors copy.	litIndSet _ Dictionary new: 16.	literalStream _ WriteStream on: (Array new: 32)! !!CEncoder methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!nTemps: n literals: lits class: cl 	"Decompile."	supered _ false.	class _ cl.	nTemps _ n.	literalStream _ ReadStream on: lits.	literalStream position: lits size.	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!CEncoder methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:43'!noteSuper	supered _ true! !!CEncoder methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!release	requestor _ nil! !!CEncoder methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!temps: tempVars literals: lits class: cl 	"Decompile."	supered _ false.	class _ cl.	nTemps _ tempVars size.	tempVars do: [:node | scopeTable at: node name put: node].	literalStream _ ReadStream on: lits.	literalStream position: lits size.	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:44'!cantStoreInto: varName	^StdVariables includesKey: varName! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/27/2004 00:48'!encodeGlobal: binding sourceRange: range	| varNode |	varNode _ self global: binding name: binding key.	range ifNotNil: [globalSourceRanges addLast: { binding key. range. false }. ].	^ varNode! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:56'!encodeLiteral: object	^self		name: object		key: (class literalScannedAs: object notifying: self)		class: CLiteralNode		type: LdLitType		set: litSet! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 16:00'!encodeSelector: selector	^self		name: selector		key: selector		class: CSelectorNode		type: SendType		set: selectorSet! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:44'!encodeVariable: name	^ self encodeVariable: name sourceRange: nil ifUnknown: [ self undeclared: name ]! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:44'!encodeVariable: name ifUnknown: action	^self encodeVariable: name sourceRange: nil ifUnknown: action! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:44'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode _ scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode _ self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [^action value]].	range ifNotNil: [		name first isUppercase ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:44'!litIndex: literal	| p |	p _ literalStream position.	p = 256 ifTrue:		[self notify: 'More than 256 literals referenced. You must split or otherwise simplify this method.The 257th literal is: ', literal printString. ^nil].		"Would like to show where it is in the source code, 		 but that info is hard to get."	literalStream nextPut: literal.	^ p! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/26/2004 15:44'!sharableLitIndex: literal	"Special access prevents multiple entries for post-allocated super send special selectors"	| p |	p _ literalStream originalContents indexOf: literal.	p = 0 ifFalse: [^ p-1].	^ self litIndex: literal! !!CEncoder methodsFor: 'encoding' stamp: 'ar 3/27/2004 21:03'!undeclared: name	| sym |	requestor interactive ifTrue: [		requestor requestor == #error: ifTrue: [requestor error: 'Undeclared'].		^ self notify: 'Undeclared'].	self warnAboutUndeclared: name.	sym _ name asSymbol.	Undeclared at: sym put: nil.	^self global: (Undeclared associationAt: sym) name: sym! !!CEncoder methodsFor: 'temps' stamp: 'ar 3/27/2004 20:27'!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node _ scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self warnAboutShadowed: name].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node! !!CEncoder methodsFor: 'temps' stamp: 'ar 3/26/2004 15:44'!bindAndJuggle: name	| node nodes first thisCode |	node _ self reallyBind: name.	"Declared temps must precede block temps for decompiler and debugger to work right"	nodes _ self tempNodes.	(first _ nodes findFirst: [:n | n scope > 0]) > 0 ifTrue:		[node == nodes last ifFalse: [self error: 'logic error'].		thisCode _ (nodes at: first) code.		first to: nodes size - 1 do:			[:i | (nodes at: i) key: (nodes at: i) key							code: (nodes at: i+1) code].		nodes last key: nodes last key code: thisCode].		^ node! !!CEncoder methodsFor: 'temps' stamp: 'ar 3/26/2004 15:44'!bindArg: name 	"Declare an argument."	| node |	nTemps >= 15		ifTrue: [^self notify: 'Too many arguments'].	node _ self bindTemp: name.	^ node nowHasDef nowHasRef! !!CEncoder methodsFor: 'temps' stamp: 'ar 3/26/2004 15:44'!bindBlockTemp: name 	"Declare a temporary block variable; complain if it's not a field or class variable."	| node |	node _ scopeTable at: name ifAbsent: [^self reallyBind: name].	node isTemp		ifTrue: [			node scope >= 0 ifTrue: [^ self notify: 'Name already used in this method'].			node scope: 0]		ifFalse: [^self notify: 'Name already used in this class'].	^node! !!CEncoder methodsFor: 'temps' stamp: 'ar 3/27/2004 21:06'!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp or:[requestor interactive])			ifTrue:[^self notify:'Name is already defined']			ifFalse:[self warnAboutShadowed: name]].	^self reallyBind: name! !!CEncoder methodsFor: 'temps' stamp: 'ar 3/26/2004 15:44'!maxTemp	^nTemps! !!CEncoder methodsFor: 'temps' stamp: 'ar 3/26/2004 16:01'!newTemp: name	nTemps _ nTemps + 1.	^ CTempVariableNode new		name: name		index: nTemps - 1		type: LdTempType		scope: 0! !!CEncoder methodsFor: 'results' stamp: 'ar 3/26/2004 15:44'!allLiterals	supered ifTrue: [self litIndex: (self associationFor: class)].	^ literalStream contents! !!CEncoder methodsFor: 'results' stamp: 'ar 3/26/2004 15:44'!associationFor: aClass	| name |	name _ Smalltalk keyAtIdentityValue: aClass ifAbsent: [^Association new value: aClass].	^Smalltalk associationAt: name! !!CEncoder methodsFor: 'results' stamp: 'ar 3/26/2004 15:44'!literals	"Should only be used for decompiling primitives"	^ literalStream contents! !!CEncoder methodsFor: 'results' stamp: 'ar 3/26/2004 15:57'!tempNames 	^ self tempNodes collect:		[:node | (node isMemberOf: CMessageAsTempNode)					ifTrue: [scopeTable keyAtValue: node]					ifFalse: [node key]]! !!CEncoder methodsFor: 'results' stamp: 'ar 3/26/2004 15:44'!tempNodes 	| tempNodes |	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].	scopeTable associationsDo:		[:assn | assn value isTemp ifTrue: [tempNodes add: assn value]].	^ tempNodes! !!CEncoder methodsFor: 'results' stamp: 'ar 3/26/2004 15:44'!tempsAndBlockArgs	| tempNodes var |	tempNodes _ OrderedCollection new.	scopeTable associationsDo:		[:assn | var _ assn value.		((var isTemp and: [var isArg not])					and: [var scope = 0 or: [var scope = -1]])			ifTrue: [tempNodes add: var]].	^ tempNodes! !!CEncoder methodsFor: 'results' stamp: 'ar 3/26/2004 15:44'!unusedTempNames 	| unused name |	unused _ OrderedCollection new.	scopeTable associationsDo:		[:assn | (assn value isUnusedTemp)			ifTrue: [name _ assn value key.					name ~= 'homeContext' ifTrue: [unused add: name]]].	^ unused! !!CEncoder methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:44'!notify: string	"Put a separate notifier on top of the requestor's window"	| req |	requestor == nil		ifFalse: 			[req _ requestor.			self release.			req notify: string].	^false! !!CEncoder methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:44'!notify: string at: location	| req |	requestor == nil		ifFalse: 			[req _ requestor.			self release.			req notify: string at: location].	^false! !!CEncoder methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:44'!requestor: req	"Often the requestor is a BrowserCodeController"	requestor _ req! !!CEncoder methodsFor: 'source mapping' stamp: 'ar 3/26/2004 15:44'!globalSourceRanges	^ globalSourceRanges! !!CEncoder methodsFor: 'source mapping' stamp: 'ar 3/26/2004 15:44'!noteSourceRange: range forNode: node	sourceRanges at: node put: range! !!CEncoder methodsFor: 'source mapping' stamp: 'ar 3/26/2004 15:44'!rawSourceRanges	^ sourceRanges ! !!CEncoder methodsFor: 'source mapping' stamp: 'ar 3/26/2004 15:44'!sourceMap	"Answer with a sorted set of associations (pc range)."	^ (sourceRanges keys collect: 		[:key |  Association key: key pc value: (sourceRanges at: key)])			asSortedCollection! !!CEncoder methodsFor: 'source mapping' stamp: 'ar 3/26/2004 15:44'!sourceRangeFor: node	^sourceRanges at: node! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!classEncoding	"This is a hack so that the parser may findout what class it was parsing for when it wants to create a syntax error view."	^ class! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:56'!global: ref name: name	^self		name: name		key: ref		class: CLiteralVariableNode		type: LdLitIndType		set: litIndSet! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!interactive	^requestor interactive! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!lookupInPools: varName ifFound: assocBlock	Symbol hasInterned: varName ifTrue:[:sym|		(class bindingOf: sym) ifNotNilDo:[:assoc| 			assocBlock value: assoc.			^true].		(Preferences valueOfFlag: #lenientScopeForGlobals)  "**Temporary**"			ifTrue: [^ Smalltalk lenientScopeHas: sym ifTrue: assocBlock]			ifFalse: [^ false]].	(class bindingOf: varName) ifNotNilDo:[:assoc|		assocBlock value: assoc.		^true].	^false! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!name: name key: key class: leafNodeClass type: type set: dict	| node |	^dict 		at: key		ifAbsent: 			[node _ leafNodeClass new						name: name						key: key						index: nil						type: type.			dict at: key put: node.			^node]! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!possibleNamesFor: proposedName	| results |	results _ class possibleVariablesFor: proposedName continuedFrom: nil.	^ proposedName correctAgainst: nil continuedFrom: results.! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!possibleVariablesFor: proposedVariable	| results |	results _ proposedVariable correctAgainstDictionary: scopeTable								continuedFrom: nil.	proposedVariable first isUppercase ifTrue:		[ results _ class possibleVariablesFor: proposedVariable						continuedFrom: results ].	^ proposedVariable correctAgainst: nil continuedFrom: results.! !!CEncoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!reallyBind: name	| node |	node _ self newTemp: name.	scopeTable at: name put: node.	^node! !!CEncoder methodsFor: 'private' stamp: 'ar 4/5/2004 02:15'!warnAboutShadowed: name	Transcript cr; show: class name,'>>', requestor methodSelector, '(', name,' is shadowed)'! !!CEncoder methodsFor: 'private' stamp: 'ar 3/27/2004 21:01'!warnAboutUndeclared: name	Transcript cr; show: class name,'>>', requestor methodSelector, '(', name,' is Undeclared)'! !!CLeafNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!key: object code: byte	key _ object.	code _ byte! !!CLeafNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!key: object index: i type: type	self key: object code: (self code: i type: type)! !!CLeafNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!name: ignored key: object code: byte	key _ object.	code _ byte! !!CLeafNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!name: literal key: object index: i type: type	self key: object		index: i		type: type! !!CLeafNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:44'!key	^key! !!CLeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!code	^code! !!CLeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitForEffect: stack on: strm	^self! !!CLeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitLong: mode on: aStream 	"Emit extended variable access."	| type index |	code < 256		ifTrue:			[code < 16			ifTrue: [type _ 0.					index _ code]			ifFalse: [code < 32					ifTrue: [type _ 1.							index _ code - 16]					ifFalse: [code < 96							ifTrue: [type _ code // 32 + 1.									index _ code \\ 32]							ifFalse: [self error: 									'Sends should be handled in SelectorNode']]]]		ifFalse: 			[index _ code \\ 256.			type _ code // 256 - 1].	index <= 63 ifTrue:		[aStream nextPut: mode.		^ aStream nextPut: type * 64 + index].	"Compile for Double-exetended Do-anything instruction..."	mode = LoadLong ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(64 0 96 128) at: type+1).  "Cant be temp (type=1)"		^ aStream nextPut: index].	mode = Store ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(160 0 0 224) at: type+1).  "Cant be temp or const (type=1 or 2)"		^ aStream nextPut: index].	mode = StorePop ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(192 0 0 0) at: type+1).  "Can only be inst"		^ aStream nextPut: index].! !!CLeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!reserve: encoder 	"If this is a yet unused literal of type -code, reserve it."	code < 0 ifTrue: [code _ self code: (encoder litIndex: key) type: 0 - code]! !!CLeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!sizeForEffect: encoder	^0! !!CLeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!sizeForValue: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 1].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!CLeafNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!code: index type: type	index isNil 		ifTrue: [^type negated].	(CodeLimits at: type) > index 		ifTrue: [^(CodeBases at: type) + index].	^type * 256 + index! !!CLeafNode methodsFor: 'copying' stamp: 'ar 3/26/2004 15:44'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.key _ deepCopier references at: key ifAbsent: [key].! !!CLeafNode methodsFor: 'copying' stamp: 'ar 3/26/2004 15:44'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."key _ key.		Weakly copied"code _ code veryDeepCopyWith: deepCopier.! !!CLiteralNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitForValue: stack on: strm	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1! !!CLiteralNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:44'!isConstantNumber	^ key isNumber! !!CLiteralNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:44'!isLiteral	^ true! !!CLiteralNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:44'!isSpecialConstant	^ code between: LdTrue and: LdMinus1+3! !!CLiteralNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:44'!literalValue	^key! !!CLiteralNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:44'!printOn: aStream indent: level	(key isVariableBinding)		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###';					 	nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##';						nextPutAll: key key]]		ifFalse:			[aStream withStyleFor: #literal					do: [key storeOn: aStream]]! !!CLiteralNode methodsFor: 'evaluation' stamp: 'ar 3/26/2004 15:44'!eval	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"	^ key! !!CMessageNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: selNode key.	selector _ selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!CMessageNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 16:01'!receiver: rcvr selector: aSelector arguments: args precedence: p from: encoder 	"Compile."	| theSelector |	self receiver: rcvr		arguments: args		precedence: p.	aSelector = #:Repeat:do:		ifTrue: [theSelector _ #do:]		ifFalse: [theSelector _ aSelector].	self noteSpecialSelector: theSelector.	(self transform: encoder)		ifTrue: 			[selector isNil				ifTrue: [selector _ CSelectorNode new 							key: (MacroSelectors at: special)							code: #macro]]		ifFalse: 			[selector _ encoder encodeSelector: theSelector.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!CMessageNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!receiver: rcvr selector: selName arguments: args precedence: p from: encoder sourceRange: range 	"Compile."	encoder noteSourceRange: range forNode: self.	^self		receiver: rcvr		selector: selName		arguments: args		precedence: p		from: encoder! !!CMessageNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!selector: sel	selector _ sel! !!CMessageNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!canCascade	^(receiver == NodeSuper or: [special > 0]) not! !!CMessageNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isComplex		^(special between: 1 and: 10) or: [arguments size > 2 or: [receiver isComplex]]! !!CMessageNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"Answer whether selector is selSymbol, and the predicates rcvrPred and argsPred	 evaluate to true with respect to receiver and the list of arguments.  If selSymbol or	 either predicate is nil, it means 'don't care'.  Note that argsPred takes numArgs	 arguments.  All block arguments are ParseNodes."	^(selSymbol isNil or: [selSymbol==selector key]) and:		[(rcvrPred isNil or: [rcvrPred value: receiver]) and:			[(argsPred isNil or: [argsPred valueWithArguments: arguments])]]! !!CMessageNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isMessageNode	^true! !!CMessageNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isReturningIf	^(special between: 3 and: 4)		and: [arguments first returns and: [arguments last returns]]! !!CMessageNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!toDoIncrement: variable	(receiver = variable and: [selector key = #+]) 		ifFalse: [^ nil].	arguments first isConstantNumber		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!CMessageNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!toDoLimit: variable	(receiver = variable and: [selector key = #<= or: [selector key = #>=]]) 		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!CMessageNode methodsFor: 'cascading' stamp: 'ar 3/26/2004 15:45'!cascadeReceiver	"Nil out rcvr (to indicate cascade) and return what it had been."	| rcvr |	rcvr _ receiver.	receiver _ nil.	^rcvr! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:45'!noteSpecialSelector: selectorSymbol	" special > 0 denotes specially treated messages. "	"Deconvert initial keywords from SQ2K"	special _ #(:Test:Yes: :Test:No: :Test:Yes:No: :Test:No:Yes:				and: or:				:Until:do: :While:do: whileFalse whileTrue				:Repeat:to:do: :Repeat:to:by:do:				) indexOf: selectorSymbol.	special > 0 ifTrue: [^ self].	special _ MacroSelectors indexOf: selectorSymbol.! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 16:01'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:		and: [(initStmt isMemberOf: CAssignmentNode) and:				[initStmt variable isTemp]])		ifFalse: [^ nil].	body _ arguments last statements.	variable _ initStmt variable.	increment _ body last toDoIncrement: variable.	(increment == nil or: [receiver statements size ~= 1])		ifTrue: [^ nil].	test _ receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	((test isMemberOf: CMessageNode)		and: [(limit _ test toDoLimit: variable) notNil])		ifFalse: [^ nil].	toDoBlock _ CBlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	^ CMessageNode new		receiver: initStmt value		selector: (CSelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:45'!transform: encoder	special = 0 ifTrue: [^false].	(self perform: (MacroTransformers at: special) with: encoder)		ifTrue: 			[^true]		ifFalse: 			[special _ 0. ^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:49'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (arguments at: 1)					with: (CBlockNode withJust: NodeFalse).			^true]		ifFalse: 			[^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:45'!transformBoolean: encoder	^self		checkBlock: (arguments at: 1)		as: 'argument'		from: encoder! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:49'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (CBlockNode withJust: NodeNil)					with: (arguments at: 1).			^true]		ifFalse:			[^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:45'!transformIfFalseIfTrue: encoder	((self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'True arg' from: encoder])		ifTrue: 			[selector _ #ifTrue:ifFalse:.			arguments swap: 1 with: 2.			^true]		ifFalse: 			[^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 16:01'!transformIfNil: encoder	(self transformBoolean: encoder) ifFalse: [^ false].	(MacroSelectors at: special) = #ifNotNil:	ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder) ifFalse: [^ false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector _ CSelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments _ {CBlockNode withJust: NodeNil. arguments first}.		(self transform: encoder) ifFalse: [self error: 'compiler logic error'].		^ true]	ifFalse:		[^ self checkBlock: arguments first as: 'ifNil arg' from: encoder]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 16:01'!transformIfNilIfNotNil: encoder	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'NotNil arg' from: encoder])		ifTrue: 			[selector _ CSelectorNode new key: #ifTrue:ifFalse: code: #macro.			receiver _ CMessageNode new				receiver: receiver				selector: #==				arguments: (Array with: NodeNil)				precedence: 2				from: encoder.			^true]		ifFalse: 			[^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 16:01'!transformIfNotNilIfNil: encoder	((self checkBlock: (arguments at: 1) as: 'NotNil arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder])		ifTrue: 			[selector _ CSelectorNode new key: #ifTrue:ifFalse: code: #macro.			receiver _ CMessageNode new				receiver: receiver				selector: #==				arguments: (Array with: NodeNil)				precedence: 2				from: encoder.			arguments swap: 1 with: 2.			^true]		ifFalse: 			[^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:49'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (arguments at: 1)					with: (CBlockNode withJust: NodeNil).			^true]		ifFalse: 			[^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:45'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'False arg' from: encoder]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 15:49'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (CBlockNode withJust: NodeTrue)					with: (arguments at: 1).			^true]		ifFalse: 			[^false]! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 16:01'!transformToDo: encoder	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: CBlockNode)			and: [arguments last numberOfArguments = 1])		ifFalse: [^ false].	arguments last firstArgument isVariableReference		ifFalse: [^ false]. "As with debugger remote vars"	arguments size = 3		ifTrue: [increment _ arguments at: 2.				(increment isConstantNumber and:					[increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment _ encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector _ CSelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange _ encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block _ arguments last.	blockRange _ encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar _ block firstArgument.	initStmt _ CAssignmentNode new variable: blockVar value: receiver.	limit _ arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit _ nil]		ifFalse:  "Need to store limit in a var"			[limit _ encoder autoBind: blockVar key , 'LimiT'.			limit scope: -2.  "Already done parsing block"			limitInit _ CAssignmentNode new					variable: limit					value: (arguments at: 1)].	test _ CMessageNode new receiver: blockVar			selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])			arguments: (Array with: limit)			precedence: precedence from: encoder			sourceRange: (myRange first to: blockRange first).	incStmt _ CAssignmentNode new			variable: blockVar			value: (CMessageNode new				receiver: blockVar selector: #+				arguments: (Array with: increment)				precedence: precedence from: encoder)			from: encoder			sourceRange: (myRange last to: myRange last).	arguments _ (Array with: limit with: increment with: block)		, (Array with: initStmt with: test with: incStmt with: limitInit).	^ true! !!CMessageNode methodsFor: 'macro transformations' stamp: 'ar 3/26/2004 16:01'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder)		ifFalse: [^ false].	arguments size = 0   "transform bodyless form to body form"		ifTrue: [selector _ CSelectorNode new					key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])					code: #macro.				arguments _ Array with: (CBlockNode withJust: NodeNil).				^ true]		ifFalse: [^ self transformBoolean: encoder]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitCase: stack on: strm value: forValue	| braceNode sizeStream thenSize elseSize |	forValue not		ifTrue: [^super emitForEffect: stack on: strm].	braceNode _ arguments first.	sizeStream _ ReadStream on: sizes.	receiver emitForValue: stack on: strm.	braceNode casesForwardDo:		[:keyNode :valueNode :last |		thenSize _ sizeStream next.		elseSize _ sizeStream next.		last ifFalse: [strm nextPut: Dup. stack push: 1].		keyNode emitForEvaluatedValue: stack on: strm.		equalNode emit: stack args: 1 on: strm.		self emitBranchOn: false dist: thenSize pop: stack on: strm.		last ifFalse: [strm nextPut: Pop. stack pop: 1].		valueNode emitForEvaluatedValue: stack on: strm.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse: [self emitJump: elseSize on: strm]].	arguments size = 2		ifTrue:			[arguments last emitForEvaluatedValue: stack on: strm] "otherwise: [...]"		ifFalse:			[NodeSelf emitForValue: stack on: strm.			caseErrorNode emit: stack args: 0 on: strm]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitForEffect: stack on: strm	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc _ 0.			self perform: (MacroEmitters at: special) with: stack with: strm with: false]		ifFalse: 			[super emitForEffect: stack on: strm]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitForValue: stack on: strm	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc _ 0.			self perform: (MacroEmitters at: special) with: stack with: strm with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].			arguments do: [:argument | argument emitForValue: stack on: strm].			selector				emit: stack				args: arguments size				on: strm				super: receiver == NodeSuper.			pc _ strm position]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitIf: stack on: strm value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize _ sizes at: 1.	elseSize _ sizes at: 2.	(forValue not and: [(elseSize*thenSize) > 0])		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super emitForEffect: stack on: strm].	thenExpr _ arguments at: 1.	elseExpr _ arguments at: 2.	receiver emitForValue: stack on: strm.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitBranchOn: false dist: thenSize pop: stack on: strm.			pc _ strm position.			thenExpr emitForEvaluatedValue: stack on: strm.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not				ifTrue:  "Elide jump over else after a return"					[self emitJump: elseSize on: strm].			elseExpr emitForEvaluatedValue: stack on: strm]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitBranchOn: false dist: thenSize pop: stack on: strm.					pc _ strm position.					thenExpr emitForEvaluatedEffect: stack on: strm]				ifFalse:					[self emitBranchOn: true dist: elseSize pop: stack on: strm.					pc _ strm position.					elseExpr emitForEvaluatedEffect: stack on: strm]]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitIfNil: stack on: strm value: forValue	| theNode theSize theSelector |	theNode _ arguments first.	theSize _ sizes at: 1.	theSelector _ #ifNotNil:.	receiver emitForValue: stack on: strm.	forValue ifTrue: [strm nextPut: Dup. stack push: 1].	strm nextPut: LdNil. stack push: 1.	equalNode emit: stack args: 1 on: strm.	self 		emitBranchOn: (selector key == theSelector)		dist: theSize 		pop: stack 		on: strm.	pc _ strm position.	forValue 		ifTrue: 			[strm nextPut: Pop. stack pop: 1.			theNode emitForEvaluatedValue: stack on: strm]			ifFalse: [theNode emitForEvaluatedEffect: stack on: strm].! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitToDo: stack on: strm value: forValue 	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt _ arguments at: 4.	limitInit _ arguments at: 7.	test _ arguments at: 5.	block _ arguments at: 3.	incStmt _ arguments at: 6.	blockSize _ sizes at: 1.	loopSize _ sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitForEffect: stack on: strm].	initStmt emitForEffect: stack on: strm.	test emitForValue: stack on: strm.	self emitBranchOn: false dist: blockSize pop: stack on: strm.	pc _ strm position.	block emitForEvaluatedEffect: stack on: strm.	incStmt emitForEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitWhile: stack on: strm value: forValue 	" L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond _ receiver.	stmt _ arguments at: 1.	stmtSize _ sizes at: 1.	loopSize _ sizes at: 2.	cond emitForEvaluatedValue: stack on: strm.	self emitBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack on: strm.   "Btp for whileFalse"	pc _ strm position.	stmt emitForEvaluatedEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!pc	"Used by encoder source mapping."	pc==nil ifTrue: [^0] ifFalse: [^pc]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeCase: encoder value: forValue	| braceNode sizeIndex thenSize elseSize |	forValue not		ifTrue: [^super sizeForEffect: encoder].	equalNode _ encoder encodeSelector: #=.	braceNode _ arguments first.	sizes _ Array new: 2 * braceNode numElements.	sizeIndex _ sizes size.	elseSize _ arguments size = 2		ifTrue:			[arguments last sizeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode _ encoder encodeSelector: #caseError.			 1 + (caseErrorNode size: encoder args: 0 super: false)]. "self caseError"	braceNode casesReverseDo:		[:keyNode :valueNode :last |		sizes at: sizeIndex put: elseSize.		thenSize _ valueNode sizeForEvaluatedValue: encoder.		last ifFalse: [thenSize _ thenSize + 1]. "Pop"		valueNode returns ifFalse: [thenSize _ thenSize + (self sizeJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize _ elseSize + 1]. "Dup"		elseSize _ elseSize + (keyNode sizeForEvaluatedValue: encoder) +			(equalNode size: encoder args: 1 super: false) +			(self sizeBranchOn: false dist: thenSize) + thenSize.		sizeIndex _ sizeIndex - 2].	^(receiver sizeForValue: encoder) + elseSize! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeForEffect: encoder	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeForEffect: encoder! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeForValue: encoder	| total argSize |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector _ selector copy "only necess for splOops"].	total _ selector size: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total _ total + (receiver sizeForValue: encoder)].	sizes _ arguments collect: 					[:arg | 					argSize _ arg sizeForValue: encoder.					total _ total + argSize.					argSize].	^total! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr _ arguments at: 1.	elseExpr _ arguments at: 2.	(forValue		or: [(thenExpr isJust: NodeNil)		or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super sizeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize _ elseExpr sizeForEvaluatedValue: encoder.			thenSize _ (thenExpr sizeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeJump: elseSize]).			branchSize _ self sizeBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize _ 0.					thenSize _ thenExpr sizeForEvaluatedEffect: encoder.					branchSize _ self sizeBranchOn: false dist: thenSize]				ifFalse:					[thenSize _ 0.					elseSize _ elseExpr sizeForEvaluatedEffect: encoder.					branchSize _ self sizeBranchOn: true dist: elseSize]].	sizes _ Array with: thenSize with: elseSize.	^ (receiver sizeForValue: encoder) + branchSize			+ thenSize + elseSize! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode _ encoder encodeSelector: #==.	sizes _ Array new: 1.	theNode _ arguments first.	theSelector _ #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize _ (1 "pop" + (theNode sizeForEvaluatedValue: encoder))).			 ^(receiver sizeForValue: encoder) +				2 "Dup. LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]		ifFalse:			[sizes at: 1 put: (theSize _ (theNode sizeForEvaluatedEffect: encoder)).			 ^(receiver sizeForValue: encoder) +				1 "LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeToDo: encoder value: forValue 	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize blockVar initSize limitInit |	block _ arguments at: 3.	blockVar _ block firstArgument.	initStmt _ arguments at: 4.	test _ arguments at: 5.	incStmt _ arguments at: 6.	limitInit _ arguments at: 7.	initSize _ initStmt sizeForEffect: encoder.	limitInit == nil		ifFalse: [initSize _ initSize + (limitInit sizeForEffect: encoder)].	blockSize _ (block sizeForEvaluatedEffect: encoder)			+ (incStmt sizeForEffect: encoder) + 2.  "+2 for Jmp backward"	loopSize _ (test sizeForValue: encoder)			+ (self sizeBranchOn: false dist: blockSize)			+ blockSize.	sizes _ Array with: blockSize with: loopSize.	^ initSize + loopSize			+ (forValue ifTrue: [1] ifFalse: [0])    " +1 for value (push nil) "! !!CMessageNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond _ receiver.	stmt _ arguments at: 1.	stmtSize _ (stmt sizeForEvaluatedEffect: encoder) + 2.	branchSize _ self sizeBranchOn: (selector key == #whileFalse:)  "Btp for whileFalse"					dist: stmtSize.	loopSize _ (cond sizeForEvaluatedValue: encoder)			+ branchSize + stmtSize.	sizes _ Array with: stmtSize with: loopSize.	^ loopSize    " +1 for value (push nil) "		+ (forValue ifTrue: [1] ifFalse: [0])! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!asMorphicCaseOn: parent indent: ignored	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise |	braceNode _ arguments first.	otherwise _ arguments last.	((arguments size = 1) or: [otherwise isJustCaseError]) ifTrue: [		self morphFromKeywords: #caseOf: arguments: {braceNode} on: parent indent: nil.		^parent	].	self morphFromKeywords: #caseOf:otherwise: arguments: arguments on: parent indent: nil.	^parent! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!macroPrinter	special > 0 ifTrue: [^MacroPrinters at: special].	^nil! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!precedence	^precedence! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:30'!printCaseOn: aStream indent: level 	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode _ arguments first.	otherwise _ arguments last.	(arguments size = 1 or: [otherwise isJustCaseError])		ifTrue: [otherwise _ nil].	receiver		printOn: aStream		indent: level		precedence: 3.	aStream nextPutAll: ' caseOf: '.	braceNode isVariableReference ifTrue: [braceNode printOn: aStream indent: level]		ifFalse: 			[aStream nextPutAll: '{';				 crtab: level + 1.			braceNode				casesForwardDo: 					[:keyNode :valueNode :last | 					keyNode printOn: aStream indent: level + 1.					aStream nextPutAll: ' -> '.					valueNode isComplex						ifTrue: 							[aStream crtab: level + 2.							extra _ 1]						ifFalse: [extra _ 0].					valueNode printOn: aStream indent: level + 1 + extra.					last ifTrue: [aStream nextPut: $}]						ifFalse: [aStream nextPut: $.;								 crtab: level + 1]]].	otherwise isNil		ifFalse: 			[aStream crtab: level + 1; nextPutAll: ' otherwise: '.			otherwise isComplex ifTrue:[					aStream crtab: level + 2.					extra _ 1]				ifFalse: [extra _ 0].			otherwise printOn: aStream indent: level + 1 + extra.	 ]! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printIfNil: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector key		arguments: (Array with: arguments first)		on: aStream indent: level! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printIfNilNotNil: aStream indent: level	self printReceiver: receiver ifNilReceiver on: aStream indent: level.	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNotNil:				arguments: { arguments second }				on: aStream indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNil:				arguments: { arguments first }				on: aStream indent: level].	^ self printKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aStream indent: level! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:30'!printIfOn: aStream indent: level	receiver ifNotNil: [		receiver printOn: aStream indent: level + 1 precedence: precedence.	].	(arguments last isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^ self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^ self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printKeywords: key arguments: args on: aStream indent: level	^ self printKeywords: key arguments: args on: aStream indent: level prefix: false! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:30'!printKeywords: key arguments: args on: aStream indent: level prefix: isPrefix	| keywords indent noColons arg kwd hasBrackets doCrTab |	args size = 0 ifTrue: [aStream space; nextPutAll: key. ^ self].	keywords _ key keywords.	noColons _ false.	doCrTab _ args size > 2 or:		[{receiver} , args			inject: false			into: [:was :thisArg |				was or: [(thisArg isKindOf: CBlockNode)					or: [(thisArg isKindOf: CMessageNode) and: [thisArg precedence >= 3]]]]].	1 to: (args size min: keywords size) do:		[:i | arg _ args at: i.  kwd _ keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		noColons			ifTrue: [aStream withStyleFor: (isPrefix ifTrue: [#prefixKeyword] ifFalse: [#keyword])						do: [aStream nextPutAll: kwd allButLast; space].					hasBrackets _ (arg isKindOf: CBlockNode) or: [arg isKindOf: CBlockNode].					hasBrackets ifFalse: [aStream nextPutAll: '(']]			ifFalse: [aStream nextPutAll: kwd; space].		arg printOn: aStream indent: level + 1 + indent			 	precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		noColons			ifTrue: [hasBrackets ifFalse: [aStream nextPutAll: ')']]]! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:31'!printOn: aStream indent: level	| leadingKeyword |"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	(special > 0)		ifTrue: [self perform: self macroPrinter with: aStream with: level]		ifFalse: [selector key first = $:				ifTrue: [leadingKeyword _ selector key keywords first.						aStream nextPutAll: leadingKeyword; space.						self printReceiver: receiver on: aStream indent: level.						self printKeywords: (selector key allButFirst: leadingKeyword size + 1) arguments: arguments							on: aStream indent: level]				ifFalse: [self printReceiver: receiver on: aStream indent: level.						self printKeywords: selector key arguments: arguments									on: aStream indent: level]]! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printOn: strm indent: level precedence: outerPrecedence	| parenthesize |	parenthesize _ precedence > outerPrecedence		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].	parenthesize		ifTrue: [strm nextPutAll: '('.				self printOn: strm indent: level.				strm nextPutAll: ')']		ifFalse: [self printOn: strm indent: level]! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:49'!printParenReceiver: rcvr on: aStream indent: level						(rcvr isKindOf: CBlockNode) ifTrue:		[^ rcvr printOn: aStream indent: level].	aStream nextPutAll: '('.	rcvr printOn: aStream indent: level.	aStream nextPutAll: ')'! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:31'!printReceiver: rcvr on: aStream indent: level						rcvr ifNil: [^ self].	"Force parens around keyword receiver of kwd message"	rcvr printOn: aStream indent: level precedence: precedence! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:31'!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: CAssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level prefix: true]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level prefix: true]! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:31'!printWhileOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.				(arguments first isJust: NodeNil) ifTrue:						[selector _ CSelectorNode new								key: (selector key == #whileTrue:									ifTrue: [#whileTrue] ifFalse: [#whileFalse])								code: #macro.						arguments _ Array new].				self printKeywords: selector key arguments: arguments					on: aStream indent: level! !!CMessageNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!test	3 > 4 ifTrue: [4+5 between: 6 and: 7]			ifFalse: [4 between: 6+5 and: 7-2]! !!CMessageNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:49'!checkBlock: node as: nodeName from: encoder	node canBeSpecialArgument ifTrue: [^node isMemberOf: CBlockNode].	((node isKindOf: CBlockNode) and: [node numberOfArguments > 0])		ifTrue:	[^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a 0-argument block']		ifFalse: [^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a block or variable']! !!CMessageNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!ifNilReceiver	^receiver! !!CMessageNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!pvtCheckForPvtSelector: encoder	"If the code being compiled is trying to send a private message (e.g. 'pvtCheckForPvtSelector:') to anyone other than self, then complain to encoder."	selector isPvtSelector ifTrue:		[receiver isSelfPseudoVariable ifFalse:			[encoder notify: 'Private messages may only be sent to self']].! !!CMessageNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!receiver: rcvr arguments: args precedence: p	receiver _ rcvr.	arguments _ args.	sizes _ Array new: arguments size.	precedence _ p! !!CMessageNode methodsFor: 'private' stamp: 'ar 3/26/2004 15:50'!transformCase: encoder	| caseNode |	caseNode _ arguments first.	(caseNode isKindOf: CBraceNode)		ifTrue:			[^(caseNode blockAssociationCheck: encoder) and:			 	[arguments size = 1 or:					[self checkBlock: arguments last as: 'otherwise arg' from: encoder]]].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: CBlockNode) not])		ifTrue:			[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!CMessageNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:45'!arguments	^arguments! !!CMessageNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:45'!arguments: list	arguments _ list! !!CMessageNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 16:02'!eval	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"	| rec args |	(receiver isKindOf: CVariableNode) ifFalse: [^ #illegal].	rec _ receiver key value.	args _ arguments collect: [:each | each eval].	^ rec perform: selector key withArguments: args! !!CMessageNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:45'!receiver	^receiver! !!CMessageNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:45'!receiver: val	"14 feb 2001 - removed return arrow"	receiver _ val! !!CMessageNode methodsFor: 'equation translation' stamp: 'ar 3/26/2004 15:45'!selector	^selector! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:57'!asStorableNode: encoder	"This node is a message masquerading as a temporary variable.	It currently has the form {homeContext tempAt: offset}.	We need to generate code for {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack.	This, in turn will get turned into {homeContext tempAt: offset put: expr}	at runtime if nobody disturbs storeAt:inTempFrame: in Object (not clean)"	^ CMessageAsTempNode new		receiver: nil  "suppress code generation for reciever already on stack"		selector: #storeAt:inTempFrame:		arguments: (arguments copyWith: receiver)		precedence: precedence		from: encoder! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!code	"Allow synthetic temp nodes to be sorted by code"	^ arguments first literalValue! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!emitStorePop: stack on: codeStream	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self emitForEffect: stack on: codeStream! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!isTemp	"Masquerading for debugger access to temps."	^ true! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!nowHasDef	"For compatibility with temp scope protocol"! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!nowHasRef	"For compatibility with temp scope protocol"! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!scope	"For compatibility with temp scope protocol"	^ -1! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!scope: ignored	"For compatibility with temp scope protocol"! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:45'!sizeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self sizeForEffect: encoder! !!CMessageAsTempNode methodsFor: 'access to remote temps' stamp: 'ar 3/26/2004 15:57'!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector key ~= #tempAt: 		ifTrue: [^self error: 'cant transform this message'].	^ CMessageAsTempNode new		receiver: receiver		selector: #tempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !!CMethodNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!block	^ block! !!CMethodNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!selector: symbol	selectorOrFalse _ symbol! !!CMethodNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 	"Initialize the receiver with respect to the arguments given."	encoder _ anEncoder.	selectorOrFalse _ selOrFalse.	precedence _ p.	arguments _ args.	temporaries _ temps.	block _ blk.	primitive _ prim! !!CMethodNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict	"Initialize the receiver with respect to the arguments given."	encoder _ anEncoder.	selectorOrFalse _ selOrFalse.	precedence _ p.	arguments _ args.	temporaries _ temps.	block _ blk.	primitive _ prim.	properties _ propDict.! !!CMethodNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!sourceText: stringOrText	sourceText _ stringOrText! !!CMethodNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!encoder	^ encoder! !!CMethodNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method cacheTempNames: self tempNames.		method properties: properties.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method cacheTempNames: self tempNames.	method properties: properties.	^ method! !!CMethodNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!generate: trailer ifQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]])		ifFalse: [^ self].	v _ block code.	v < 0		ifTrue: [^ self].	v = LdSelf		ifTrue: [^ methodBlock value: (CompiledMethod toReturnSelfTrailerBytes: trailer)].	(v between: LdTrue and: LdMinus1 + 3)		ifTrue: [^ methodBlock value: (CompiledMethod toReturnConstant: v - LdSelf trailerBytes: trailer)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v trailerBytes: trailer)].	v // 256 = 1		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v \\ 256 trailerBytes: trailer)]! !!CMethodNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!generateNative: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method cacheTempNames: self tempNames.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method cacheTempNames: self tempNames.	^ method! !!CMethodNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:59'!parserClass	"Which parser produces this class of parse node"	^ CParser! !!CMethodNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!selector 	"Answer the message selector for the method represented by the receiver."	(selectorOrFalse isMemberOf: Symbol)		ifTrue: [^selectorOrFalse].	^selectorOrFalse key! !!CMethodNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sourceMap	"Answer a SortedCollection of associations of the form: pc (byte offset in me) -> sourceRange (an Interval) in source text."	| methNode |	methNode _ self.	sourceText ifNil: [		"No source, use decompile string as source to map from"		methNode _ self parserClass new			parse: self decompileString			class: self methodClass	].	methNode generateNative: #(0 0 0 0).  "set bytecodes to map to"	^ methNode encoder sourceMap! !!CMethodNode methodsFor: 'converting' stamp: 'ar 3/26/2004 15:54'!asColorizedSmalltalk80Text	"Answer a colorized Smalltalk-80-syntax string description of the parse tree whose root is the receiver."	^ CDialectStream		dialect: #ST80		contents: [:strm | self printOn: strm]! !!CMethodNode methodsFor: 'converting' stamp: 'ar 3/26/2004 15:54'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ (CDialectStream dialect: #ST80 contents: [:strm | self printOn: strm])		asString! !!CMethodNode methodsFor: 'converting' stamp: 'ar 3/26/2004 16:32'!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^ CDialectStream		dialect: (#ST80)		contents: [:strm | self printOn: strm]! !!CMethodNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!methodClass	^ encoder classEncoding! !!CMethodNode methodsFor: 'printing' stamp: 'ar 5/6/2004 03:07'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream dialect = #SQ00				ifTrue: [aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Use']]				ifFalse: [aStream nextPutAll: '|'].			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].			aStream dialect = #SQ00				ifTrue: [aStream nextPutAll: '.']				ifFalse: [aStream nextPutAll: ' |']].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!CMethodNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!printPrimitiveOn: aStream 	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ primitive.	primIndex = 0		ifTrue: [^ self].	primIndex = 120		ifTrue: ["External call spec"			^ aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primIndex = 117		ifTrue: [primDecl _ encoder literals at: 1.			aStream nextPut: $';								nextPutAll: (primDecl at: 2);				 nextPut: $'.			(primDecl at: 1) notNil				ifTrue: [aStream nextPutAll: ' module:';						 nextPut: $';												nextPutAll: (primDecl at: 1);						 nextPut: $']]		ifFalse: [aStream print: primIndex].	aStream nextPut: $>.	Smalltalk at: #Interpreter ifPresent:[:cls|		aStream nextPutAll: ' "'				, ((cls classPool at: #PrimitiveTable)						at: primIndex + 1) , '" '].! !!CMethodNode methodsFor: 'printing' stamp: 'ar 5/6/2004 03:08'!printPropertiesOn: aStream	properties ifNil:[^self].	properties keysAndValuesDo:[:prop :val|		aStream crtab; nextPutAll:'<'; nextPutAll: prop; nextPutAll:': '; print: val; nextPutAll:'>'.	].! !!CMethodNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!sourceText	^ sourceText ifNil: [self printString]! !!CMethodNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:45'!tempNames	^ encoder tempNames! !!CReturnNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!expr: e	expr _ e! !!CReturnNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!expr: e encoder: encoder sourceRange: range	expr _ e.	encoder noteSourceRange: range forNode: self! !!CReturnNode methodsFor: 'converting' stamp: 'ar 3/26/2004 15:45'!asReturnNode! !!CReturnNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isReturnSelf	^expr == NodeSelf! !!CReturnNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isSpecialConstant	^expr isSpecialConstant! !!CReturnNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isVariableReference	^expr isVariableReference! !!CReturnNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!code	^expr code! !!CReturnNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitForReturn: stack on: strm	expr emitForReturn: stack on: strm.	pc _ strm position! !!CReturnNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!emitForValue: stack on: strm	expr emitForReturn: stack on: strm.	pc _ strm position! !!CReturnNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!pc	"Used by encoder source mapping."	^pc! !!CReturnNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeForReturn: encoder	^expr sizeForReturn: encoder! !!CReturnNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:45'!sizeForValue: encoder	^expr sizeForReturn: encoder! !!CReturnNode methodsFor: 'printing' stamp: 'ar 3/26/2004 16:32'!printOn: aStream indent: level	aStream nextPutAll: '^ '.	expr printOn: aStream indent: level.	expr printCommentOn: aStream indent: level.! !!CScanner methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!initScanner	buffer _ WriteStream on: (String new: 40).	typeTable _ TypeTable! !!CScanner methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:45'!scan: inputStream 	"Bind the input stream, fill the character buffers and first token buffer."	source _ inputStream.	self step.	self step.	self scanToken! !!CScanner methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!scanFieldNames: stringOrArray	"Answer an Array of Strings that are the identifiers in the input string, 	stringOrArray. If passed an Array, just answer with that Array, i.e., 	assume it has already been scanned."	| strm |	(stringOrArray isMemberOf: Array)		ifTrue: [^stringOrArray].	self scan: (ReadStream on: stringOrArray asString).	strm _ WriteStream on: (Array new: 10).	[tokenType = #doIt]		whileFalse: 			[tokenType = #word ifTrue: [strm nextPut: token].			self scanToken].	^strm contents	"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !!CScanner methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!scanMessageParts: sourceString	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"	| coll nonKeywords |	coll _ OrderedCollection new.	self scan: (ReadStream on: sourceString asString).	nonKeywords _ 0.	[tokenType = #doIt] whileFalse:		[(currentComment == nil or: [currentComment isEmpty])			ifTrue: [coll addLast: nil]			ifFalse: [coll addLast: currentComment removeFirst.				[currentComment isEmpty] whileFalse:					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].		(token numArgs < 1 or: [(token = #|) & (coll size > 1)])			ifTrue: [(nonKeywords _ nonKeywords + 1) > 1 ifTrue: [^ coll]]						"done with header"			ifFalse: [nonKeywords _ 0].		coll addLast: token.		self scanToken].	(currentComment == nil or: [currentComment isEmpty])		ifTrue: [coll addLast: nil]		ifFalse: [coll addLast: currentComment removeFirst.			[currentComment isEmpty] whileFalse: [				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].	^ coll! !!CScanner methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!scanStringStruct: textOrString 	"The input is a string whose elements are identifiers and parenthesized	 groups of identifiers.  Answer an array reflecting that structure, representing	 each identifier by an uninterned string."	self scan: (ReadStream on: textOrString asString).	self scanStringStruct.	^token	"Scanner new scanStringStruct: 'a b (c d) (e f g)'"! !!CScanner methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!scanTokens: textOrString 	"Answer an Array that has been tokenized as though the input text, 	textOrString, had appeared between the array delimitors #( and ) in a 	Smalltalk literal expression."	self scan: (ReadStream on: textOrString asString).	self scanLitVec.	^token	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!advance	| prevToken |	prevToken _ token.	self scanToken.	^prevToken! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!checkpoint	"Return a copy of all changeable state.  See revertToCheckpoint:"	^ {self clone. source clone. currentComment copy}! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!nextLiteral	"Same as advance, but -4 comes back as a number instead of two tokens"	| prevToken |	prevToken _ self advance.	(prevToken == #- and: [token isKindOf: Number])		ifTrue: 			[^self advance negated].	^prevToken! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!revertToCheckpoint: checkpoint	"Revert to the state when checkpoint was made."	| myCopy |	myCopy _ checkpoint first.	1 to: self class instSize do:		[:i | self instVarAt: i put: (myCopy instVarAt: i)].	source _ checkpoint second.	currentComment _ checkpoint third! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!scanLitVec	| s |	s _ WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]]		whileFalse: 			[tokenType = #leftParenthesis				ifTrue: 					[self scanToken; scanLitVec]				ifFalse: 					[tokenType = #word | (tokenType = #keyword) | (tokenType = #colon)						ifTrue: 							[self scanLitWord]						ifFalse:							[(token == #- 									and: [(typeTable at: hereChar asciiValue) = #xDigit])								ifTrue: 									[self scanToken.									token _ token negated]]].			s nextPut: token.			self scanToken].	token _ s contents! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!scanLitWord	"Accumulate keywords and asSymbol the result."	| t |	[(typeTable at: hereChar asciiValue) = #xLetter]		whileTrue: 			[t _ token.			self xLetter.			token _ t , token].	token _ token asSymbol! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!scanStringStruct	| s |	s _ WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]]		whileFalse: 			[tokenType = #leftParenthesis				ifTrue: 					[self scanToken; scanStringStruct]				ifFalse: 					[tokenType = #word ifFalse:						[^self error: 'only words and parens allowed']].			s nextPut: token.			self scanToken].	token _ s contents! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!scanToken	[(tokenType _ typeTable at: hereChar asciiValue) == #xDelimiter]		whileTrue: [self step].  "Skip delimiters fast, there almost always is one."	mark _ source position - 1.	(tokenType at: 1) = $x "x as first letter"		ifTrue: [self perform: tokenType "means perform to compute token & type"]		ifFalse: [token _ self step asSymbol "else just unique the first char"].	^token! !!CScanner methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!step	| c |	c _ hereChar.	hereChar _ aheadChar.	source atEnd		ifTrue: [aheadChar _ 30 asCharacter "doit"]		ifFalse: [aheadChar _ source next].	^c! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xBinary	tokenType _ #binary.	token _ self step asSymbol.	[(typeTable at: hereChar asciiValue) = #xBinary and: [hereChar ~= $-]]		whileTrue: [token _ (token , (String with: self step)) asSymbol]! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/27/2004 00:49'!xColon		"Allow := for assignment by converting to #_ "	aheadChar = $= ifTrue:		[self step.		tokenType _ #leftArrow.		self step.		^ token _ #_].	aheadChar = $: ifTrue:		[self step.		tokenType _ #scopeRef.		self step.		^ token _ #'::'].			"Otherwise, just do what normal scan of colon would do"	tokenType _ #colon.	^ token _ self step asSymbol! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xDelimiter	"Ignore blanks, etc."	self scanToken! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xDigit	"Form a number."	tokenType _ #number.	(aheadChar = 30 asCharacter and: [source atEnd			and:  [source skip: -1. source next ~= 30 asCharacter]])		ifTrue: [source skip: -1 "Read off the end last time"]		ifFalse: [source skip: -2].	token _ [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].	self step; step! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xDollar	"Form a Character literal."	self step. "pass over $"	token _ self step.	tokenType _ #number "really should be Char, but rest of compiler doesn't know"! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xDoubleQuote    "Collect a comment."    "wod 1/10/98: Allow 'empty' comments by testing the first characterfor $"" rather than blindly adding it to the comment being collected."    | aStream stopChar |    stopChar _ 30 asCharacter.    aStream _ WriteStream on: (String new: 200).    self step.    [hereChar == $"]        whileFalse:            [(hereChar == stopChar and: [source atEnd])                ifTrue: [^self offEnd: 'Unmatched comment quote'].            aStream nextPut: self step.].    self step.    currentComment == nil        ifTrue: [currentComment _ OrderedCollection with: aStreamcontents]        ifFalse: [currentComment add: aStream contents].    self scanToken! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/27/2004 00:50'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type == #xColon and: [aheadChar ~= $= and:[aheadChar ~= $:]]])		ifTrue: 			[buffer nextPut: self step.			["Allow any number of embedded colons in literal symbols"			(typeTable at: hereChar asciiValue) == #xColon]				whileTrue: [buffer nextPut: self step].			tokenType _ #keyword]		ifFalse: 			[type == #leftParenthesis 				ifTrue:[buffer nextPut: self step; nextPut: $).						tokenType _ #positionalMessage]				ifFalse:[tokenType _ #word]].	token _ buffer contents! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start _ mark.	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanLitVec.			mark _ start+1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(tokenType==#literal)						ifTrue:							[(token isMemberOf: Symbol)								ifTrue: "##word"									[token _ token "May want to move toward ANSI here"]]						ifFalse:							[tokenType==#string ifTrue: [token _ token asSymbol]]]].	mark _ start.	tokenType _ #literal"	#(Pen)	#Pen	#'Pen'	##Pen	###Pen"! !!CScanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xSingleQuote	"String."	self step.	buffer reset.	[hereChar = $' 		and: [aheadChar = $' 				ifTrue: [self step. false]				ifFalse: [true]]]		whileFalse: 			[buffer nextPut: self step.			(hereChar = 30 asCharacter and: [source atEnd])				ifTrue: [^self offEnd: 'Unmatched string quote']].	self step.	token _ buffer contents.	tokenType _ #string! !!CScanner methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:45'!notify: string 	"Refer to the comment in Object|notify:." 	self error: string! !!CScanner methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:45'!offEnd: aString 	"Parser overrides this"	^self notify: aString! !!CParser methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!encoder	^ encoder! !!CParser methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!parse: sourceStreamOrString class: behavior	^ self parse: sourceStreamOrString readStream class: behavior		noPattern: false context: nil notifying: nil ifFail: [self parseError]! !!CParser methodsFor: 'public access' stamp: 'ar 3/26/2004 15:55'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."         | methNode repeatNeeded myStream parser s p |        parser _ self.        myStream _ sourceStream.        [repeatNeeded _ false.	   p _ myStream position.	   s _ myStream upToEnd.	   myStream position: p.        parser init: myStream notifying: req failBlock: [^ aBlock value].        doitFlag _ noPattern.        failBlock_ aBlock.        [methNode _ parser method: noPattern context: ctxt                                encoder: (CEncoder new init: class context: ctxt notifying: parser)]                 on: ParserRemovedUnusedTemps                 do:                         [ :ex | repeatNeeded _ (requestor isKindOf: TextMorphEditor) not.                        myStream _ ReadStream on: requestor text string.                        ex resume].        repeatNeeded] whileTrue.        encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	   methNode sourceText: s.        ^ methNode! !!CParser methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!parseArgs: aString notifying: req  	"Parse the argument, aString, notifying req if an error occurs. Otherwise,  	answer an Array containing the argument names"	aString == nil ifTrue: [^#()].	doitFlag _ false.               "Don't really know if a doit or not!!"	^self initPattern: aString		notifying: req		return: [:pattern | (pattern at: 2)]! !!CParser methodsFor: 'public access' stamp: 'ar 3/26/2004 15:53'!parseArgsAndTemps: aString notifying: req         "Parse the argument, aString, notifying req if an error occurs. Otherwise,         answer a two-element Array containing Arrays of strings (the argument         names and temporary variable names)."        aString == nil ifTrue: [^#()].        doitFlag _ false.               "Don't really know if a doit or not!!"        ^self initPattern: aString                notifying: req                return: [:pattern | (pattern at: 2) , self temporaries]! !!CParser methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!parseMethodComment: aString setPattern: aBlock	"Answer the method comment for the argument, aString. Evaluate aBlock 	with the message pattern in the form #(selector, arguments, precedence)."	self		initPattern: aString		notifying: nil		return: aBlock.	currentComment==nil		ifTrue:	[^OrderedCollection new]		ifFalse:	[^currentComment]! !!CParser methodsFor: 'public access' stamp: 'ar 3/26/2004 15:45'!parseSelector: aString 	"Answer the message selector for the argument, aString, which should 	parse successfully up to the temporary declaration or the end of the 	method header."	^self		initPattern: aString		notifying: nil		return: [:pattern | pattern at: 1]! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!argumentName	hereType == #word		ifFalse: [^self expected: 'Argument name'].	^self advance! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:48'!assignment: varNode	" var '_' expression => CAssignmentNode."	| loc start |	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	start _ self startOfNextToken.	varNode nowHasDef.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode _ CAssignmentNode new				variable: varNode				value: parseNode				from: encoder				sourceRange: (start to: self endOfLastToken).	^true! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| variableNodes temporaryBlockVariables start |	variableNodes _ OrderedCollection new.	start _ prevMark + requestorOffset.	"Gather parameters."	[self match: #colon] whileTrue: [variableNodes addLast: (encoder autoBind: self argumentName)].	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue: [^self expected: 'Vertical bar'].	temporaryBlockVariables _ self temporaryBlockVariables.	self statements: variableNodes innerBlock: true.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].	encoder noteSourceRange: (self endOfLastToken to: self endOfLastToken) forNode: parseNode.	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:50'!braceExpression	" { elements } => CBraceNode."	| elements locations loc more |	elements _ OrderedCollection new.	locations _ OrderedCollection new.	self advance.	more _ hereType ~~ #rightBrace.	[more]		whileTrue: 			[loc _ hereMark + requestorOffset.			self expression				ifTrue: 					[elements addLast: parseNode.					locations addLast: loc]				ifFalse:					[^self expected: 'Variable or expression'].			(self match: #period)				ifTrue: [more _ hereType ~~ #rightBrace]				ifFalse: [more _ false]].	parseNode _ CBraceNode new elements: elements sourceLocations: locations.	(self match: #rightBrace)		ifFalse: [^self expected: 'Period or right brace'].	^true! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:50'!cascade	" {; message} => CCascadeNode."	| rcvr msgs |	parseNode canCascade		ifFalse: [^self expected: 'Cascading not'].	rcvr _ parseNode cascadeReceiver.	msgs _ OrderedCollection with: parseNode.	[self match: #semicolon]		whileTrue: 			[parseNode _ rcvr.			(self messagePart: 3 repeat: false)				ifFalse: [^self expected: 'Cascade'].			parseNode canCascade				ifFalse: [^self expected: '<- No special messages'].			parseNode cascadeReceiver.			msgs addLast: parseNode].	parseNode _ CCascadeNode new receiver: rcvr messages: msgs! !!CParser methodsFor: 'expression types' stamp: 'ar 4/28/2004 16:39'!expression	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	(hereType == #word and: [tokenType == #leftBracket])		ifTrue:[^self matrixExpression: false].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^self remoteAssignment! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!keylessMessagePartTest: level repeat: repeat! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:57'!matrixExpression: primary	"primaryExpression [ ... ] -> index node"	| start rcvrNode selector args msgStart msgStop |	self primaryExpression ifFalse:[^false].	(hereType == #leftBracket) ifFalse:[^primary].	start _ self startOfNextToken.	rcvrNode _ parseNode.	selector _ WriteStream on: (String new: 32).	args _ OrderedCollection new.	[	self advance.		parseNode _ nil.		self primaryExpression ifFalse:[^self expected:'expression'].		args size = 0 			ifTrue:[selector nextPutAll:'matrixAt:']			ifFalse:[selector nextPutAll:'at:'].		args add: parseNode.	here == #, ] whileTrue.	(self match: #rightBracket) ifFalse:[^self expected:']'].	msgStart _ start.	msgStop _ self endOfLastToken.	(primary not and:[hereType == #leftArrow]) ifTrue:[		selector nextPutAll:'put:'.		start _ self startOfNextToken.		self advance.		self expression ifFalse: [^self expected: 'Expression'].		(parseNode isKindOf: CBlockNode) ifFalse:[			parseNode _ CBlockNode new						arguments: #()						statements: (OrderedCollection with: parseNode)						returns: false						from: encoder.		].		args add: parseNode].	parseNode _ CMessageNode new				receiver: rcvrNode				selector: selector contents asSymbol				arguments: args				precedence: 1				from: encoder				sourceRange: (msgStart to: msgStop).	primary ifTrue:[^true].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:58'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart type |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					(self matrixExpression: true) ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					(self matrixExpression: true) ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [(hereType == #word or:[hereType == #positionalMessage])						ifTrue: 							[start _ self startOfNextToken.							type := hereType.							selector _ self advance.							type == #word ifTrue:[								args _ #().							] ifFalse:[								args := self positionalArgs.								selector := selector,'/', args size printString.							].							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ CMessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!CParser methodsFor: 'expression types' stamp: 'ar 3/27/2004 20:28'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	encoder _ encoderToUse.	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	methodSelector := sap at: 1.	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporaries.	messageComment _ currentComment.	currentComment _ nil.	doit ifFalse:[self properties].	prim _ 0.	properties ifNotNil:[		prim _ properties at: #primitiveIndex ifAbsent:[0].		"don't preserve primitive index"		properties removeKey: #primitiveIndex ifAbsent:[].	].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:58'!newMethodNode	^ CMethodNode new! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword] whileTrue:[				selector nextPutAll: self advance.				args addLast: (encoder bindArg: self argumentName).			].			^ {selector contents asSymbol. args. 3}].	hereType == #positionalMessage ifTrue:[		args _ OrderedCollection new.		selector := self advance.		hereType == #rightParenthesis ifTrue:[self advance. ^{(selector,'/0') asSymbol. args. 1}].		[			args addLast: (encoder bindArg: self argumentName).			hereType == #rightParenthesis ifTrue:[				self advance. 				selector := (selector,'/', args size printString) asSymbol.				^{selector. args. 1}].			here == #, ifFalse:[self expected: 'comma'].			self advance.		] repeat.	].	^ self expected: 'Message pattern'! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode _ self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal]])		ifTrue: 			[parseNode _ encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number])		ifTrue: 			[self advance.			parseNode _ encoder encodeLiteral: self advance negated.			^true].	^false! !!CParser methodsFor: 'expression types' stamp: 'ar 4/28/2004 16:50'!remoteAssignment	| leftHandNode selector start |	hereType == #leftArrow ifFalse:[^true].	parseNode isMessageNode ifFalse:[^true].	parseNode arguments size = 0 ifFalse:[^true].	leftHandNode := parseNode.	selector := leftHandNode selector key, ':'.	(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym]) ifFalse:[		"Argh... how would we correct this???"		selector := selector asSymbol.	].	self advance.	self expression ifFalse:[^false].	start := (encoder sourceRangeFor: leftHandNode) first.	parseNode _ CMessageNode new				receiver: leftHandNode receiver				selector: selector				arguments: (Array with: parseNode)				precedence: 3				from: encoder				sourceRange: (start to: self endOfLastToken).	^true! !!CParser methodsFor: 'expression types' stamp: 'ar 3/27/2004 14:03'!scopeVariable	| varName varStart varEnd scope binding |	varStart _ self startOfNextToken + requestorOffset.	scope := encoder classEncoding.	[varName _ self advance.	binding := scope bindingOf: varName asSymbol.	binding == nil ifTrue:[^self expected: 'variable name'].	hereType == #scopeRef] whileTrue:[		self advance. "skip scopeRef"		scope := binding value].	varEnd _ self endOfLastToken + requestorOffset.	^encoder encodeGlobal: binding sourceRange: (varStart to: varEnd)! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 16:00'!statements: argNodes innerBlock: inner	| stmts returns start more blockComment |	stmts _ OrderedCollection new.	"give initial comment to block, since others trail statements"	blockComment _ currentComment.	currentComment _ nil.	returns _ false.	more _ hereType ~~ #rightBracket.	[more]		whileTrue: 		[start _ self startOfNextToken.		(returns _ self matchReturn)			ifTrue: 				[self expression					ifFalse: [^self expected: 'Expression to return'].				self addComment.				stmts addLast: (parseNode isReturningIf					ifTrue: [parseNode]					ifFalse: [CReturnNode new							expr: parseNode							encoder: encoder							sourceRange: (start to: self endOfLastToken)])]			ifFalse: 				[self expression					ifTrue: 						[self addComment.						stmts addLast: parseNode]					ifFalse: 						[self addComment.						stmts size = 0							ifTrue: 								[stmts addLast: 									(encoder encodeVariable:										(inner ifTrue: ['nil'] ifFalse: ['self']))]]].		returns 			ifTrue: 				[self match: #period.				(hereType == #rightBracket or: [hereType == #doIt])					ifFalse: [^self expected: 'End of block']].		more _ returns not and: [self match: #period]].	parseNode _ CBlockNode new				arguments: argNodes				statements: stmts				returns: returns				from: encoder.	parseNode comment: blockComment.	^ true! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [self interactive				ifFalse: [tempsMark _ 1]				ifTrue: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ (prevEnd ifNil: [0]) + 1.		tempsMark _ hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!CParser methodsFor: 'expression types' stamp: 'ar 3/26/2004 15:45'!temporaryBlockVariables	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse: [		"There are't any temporary variables."		^#()].	variables _ OrderedCollection new.	[hereType == #word] whileTrue: [variables addLast: (encoder bindBlockTemp: self advance)].	(self match: #verticalBar) ifTrue: [^variables].	^self expected: 'Vertical bar'! !!CParser methodsFor: 'expression types' stamp: 'ar 3/27/2004 00:48'!variable	| varName varStart varEnd result |	tokenType == #scopeRef ifTrue:[^self scopeVariable].	varStart _ self startOfNextToken + requestorOffset.	varName _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	[result := encoder encodeVariable: varName		sourceRange: (varStart to: varEnd)		ifUnknown: [nil].	result ifNil:[		result := (CUndeclaredVariableReference new)				parser: self;				varName: varName;				varStart: varStart;				varEnd: varEnd;				signal	].	result isString] whileTrue:[varName := result].	^result! !!CParser methodsFor: 'scanning' stamp: 'ar 3/26/2004 15:45'!advance	| this |	prevMark _ hereMark.	prevEnd _ hereEnd.	this _ here.	here _ token.	hereType _ tokenType.	hereMark _ mark.	hereEnd _ source position - (source atEnd ifTrue: [hereChar == 30 asCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]).	self scanToken.	"Transcript show: 'here: ', here printString, ' mark: ', hereMark printString, ' end: ', hereEnd printString; cr."	^this! !!CParser methodsFor: 'scanning' stamp: 'ar 3/26/2004 15:45'!endOfLastToken	^ prevEnd ifNil: [mark]! !!CParser methodsFor: 'scanning' stamp: 'ar 3/26/2004 15:45'!match: type 	"Answer with true if next tokens type matches."	hereType == type		ifTrue: 			[self advance.			^true].	^false! !!CParser methodsFor: 'scanning' stamp: 'ar 3/26/2004 15:45'!matchReturn	^ self match: #upArrow! !!CParser methodsFor: 'scanning' stamp: 'ar 3/26/2004 15:45'!matchToken: thing 	"Matches the token, not its type."	here = thing ifTrue: [self advance. ^true].	^false! !!CParser methodsFor: 'scanning' stamp: 'ar 3/26/2004 15:45'!startOfNextToken	"Return starting position in source of next token."	hereType == #doIt ifTrue: [^source position + 1].	^hereMark! !!CParser methodsFor: 'temps' stamp: 'ar 3/26/2004 15:45'!bindArg: name	^ self bindTemp: name! !!CParser methodsFor: 'temps' stamp: 'ar 3/26/2004 15:45'!bindTemp: name	^name! !!CParser methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:45'!expected: aString 	"Notify a problem at token 'here'."	tokenType == #doIt ifTrue: [hereMark _ hereMark + 1].	hereType == #doIt ifTrue: [hereMark _ hereMark + 1].	^ self notify: aString , ' expected' at: hereMark + requestorOffset! !!CParser methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:45'!fail	| exitBlock |	encoder == nil		ifFalse: [encoder release. encoder _ nil]. "break cycle"	exitBlock _ failBlock.	failBlock _ nil.	^exitBlock value! !!CParser methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:45'!interactive	^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!CParser methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:45'!notify: aString 	"Notify problem at token before 'here'."	^self notify: aString at: prevMark + requestorOffset! !!CParser methodsFor: 'error handling' stamp: 'bf 4/20/2004 15:46'!notify: string at: location	requestor isNil		ifTrue: [(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].				(CSyntaxError new)					parser: self;					messageText: string;					location: location;					doitFlag: doitFlag;				signal]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!CParser methodsFor: 'error handling' stamp: 'ar 3/26/2004 15:45'!offEnd: aString 	"Notify a problem beyond 'here' (in lookAhead token). Don't be offEnded!!"	requestorOffset == nil		ifTrue: [^ self notify: aString at: mark]		ifFalse: [^ self notify: aString at: mark + requestorOffset]! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ Symbol possibleSelectorsFor: proposedKeyword.	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection temp binding globalToo |	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^ encoder undeclared: proposedVariable].	temp _ proposedVariable first isLowercase.	"First check to see if the requestor knows anything about the variable"	(temp and: [(binding _ requestor bindingOf: proposedVariable) notNil])		ifTrue: [^ encoder global: binding name: proposedVariable].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleVariablesFor: proposedVariable.	aStream _ WriteStream on: (String new: 200).	globalToo _ 0.	aStream nextPutAll: 'declare ' ,		(temp ifTrue: ['temp']			ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: ['Global']					ifFalse: [globalToo _ 1.  'Class Variable']]); cr.	globalToo = 1 ifTrue: [aStream nextPutAll: 'declare Global'; cr].	alternatives do:		[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: (globalToo + 1) with: (globalToo + alternatives size + 1)))		startUpWithCaption:(('Unknown variable: ', proposedVariable, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + proposedVariable size).	(choice = 0) | (choice > (globalToo + alternatives size + 1))		ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice =1 ifTrue:			[temp ifTrue: [^ self declareTempAndPaste: proposedVariable]				ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: [^ self declareGlobal: proposedVariable]					ifFalse: [^ self declareClassVar: proposedVariable]]].	(choice = 2) & (globalToo = 1) ifTrue: [^ self declareGlobal: proposedVariable].	"Spelling correction"	self substituteWord: (alternatives at: choice-1-globalToo)			wordInterval: spot			offset: 0.	^ encoder encodeVariable: (alternatives at: choice-1-globalToo)! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!declareClassVar: name	| sym class |	sym _ name asSymbol.	class _ encoder classEncoding.	class _ class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!declareGlobal: name	| sym |	sym _ name asSymbol.	Smalltalk at: sym put: nil.	^ encoder global: (Smalltalk associationAt: sym) name: sym! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!declareTempAndPaste: name	| insertion delta theTextString characterBeforeMark |	theTextString _ requestor text string.	characterBeforeMark _ theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion _ name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion _ ' ', insertion].		delta _ 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion _ '| ' , name , ' |',String cr.		delta _ 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion _ insertion , String tab.			delta _ delta + 1.	"the tab"		].	].	tempsMark _ tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta.	^ encoder bindAndJuggle: name! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!queryUndefined	| varStart varName | 	varName _ parseNode key.	varStart _ self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	((PopUpMenu labels:'yesno') startUpWithCaption:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges _ false.	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:			((temp , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end _ tempsMark.			["Beginning at right temp marker..."			start _ end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)					and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]			whileFalse:				["Search left for the unused temp"				end _ requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start _ start-1].				requestor correctFrom: start to: end with: ''.				str _ str copyReplaceFrom: start to: end with: ''. 				madeChanges _ true.				tempsMark _ tempsMark - (end-start+1)]]			ifFalse:			[self inform:'You''ll first have to remove thestatement where it''s stored into']]].	madeChanges ifTrue: [ParserRemovedUnusedTemps signal]! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!substituteSelector: selectorParts wordIntervals: spots	"Substitute the correctSelector into the (presuamed interactive) receiver."	| offset |	offset _ 0.	selectorParts with: spots do:		[ :word :interval |		offset _ self substituteWord: word wordInterval: interval offset: offset ]! !!CParser methodsFor: 'error correction' stamp: 'ar 3/26/2004 15:45'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presuamed interactive) receiver."	requestor correctFrom: (spot first + o)					to: (spot last + o)					with: correctWord.	requestorOffset _ requestorOffset + correctWord size - spot size.	^ o + correctWord size - spot size! !!CParser methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!addComment	parseNode ~~ nil		ifTrue: 			[parseNode comment: currentComment.			currentComment _ nil]! !!CParser methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!addProperty: propName value: value	| aSymbol |	properties ifNil:[properties _ IdentityDictionary new].	aSymbol _ propName asSymbol.	(properties includesKey: aSymbol) ifTrue:[self notify: '<- duplicate property'].	properties at: aSymbol put: value.	^true! !!CParser methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!init: sourceStream notifying: req failBlock: aBlock	requestor _ req.	failBlock _ aBlock.	super scan: sourceStream.	prevMark _ hereMark _ mark.	requestorOffset _ 0.	self advance! !!CParser methodsFor: 'private' stamp: 'ar 3/26/2004 15:45'!initPattern: aString notifying: req return: aBlock	| result |	self		init: (ReadStream on: aString asString)		notifying: req		failBlock: [^nil].	encoder _ self.	result _ aBlock value: (self pattern: false inContext: nil).	encoder _ failBlock _ nil.  "break cycles"	^result! !!CParser methodsFor: 'private' stamp: 'ar 3/27/2004 20:29'!methodSelector	^methodSelector! !!CParser methodsFor: 'private' stamp: 'bf 4/20/2004 15:39'!sourceString	^ source contents! !!CParser methodsFor: 'primitives' stamp: 'ar 3/26/2004 15:45'!allocateLiteral: lit	encoder litIndex: lit! !!CParser methodsFor: 'primitives' stamp: 'ar 3/26/2004 15:45'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass _ Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType _ descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType _ self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName _ here.	(self match: #string) 		ifTrue:[externalName _ externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken:'(' asSymbol) ifFalse:[^self expected:'argument list'].	args _ WriteStream on: Array new.	[here == #)] whileFalse:[		argType _ self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:')' asSymbol) ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn _ xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	^self addProperty: #primitiveIndex value: 120! !!CParser methodsFor: 'primitives' stamp: 'ar 3/26/2004 15:45'!externalType: descriptorClass	"Parse an return an external type"	| xType |	xType _ descriptorClass atomicTypeNamed: here.	xType == nil ifTrue:["Look up from class scope"		Symbol hasInterned: here ifTrue:[:sym|			xType _ descriptorClass structTypeNamed: sym]].	xType == nil ifTrue:[		"Raise an error if user is there"		self interactive ifTrue:[^nil].		"otherwise go over it silently"		xType _ descriptorClass forceTypeNamed: here].	self advance.	(self matchToken:#*)		ifTrue:[^xType asPointerType]		ifFalse:[^xType]! !!CParser methodsFor: 'primitives' stamp: 'ar 3/26/2004 15:45'!primitive	| n |	(self matchToken: #<) ifFalse: [^ 0].	n _ self primitiveDeclarations.	(self matchToken: #>) ifFalse: [^ self expected: '>'].	^ n! !!CParser methodsFor: 'primitives' stamp: 'ar 3/26/2004 15:45'!primitiveDeclaration	| prim module |	(self matchToken: 'primitive:') ifFalse:[^false].	prim _ here.	(self match: #number) ifTrue:[ "Indexed primitives"		^self addProperty: #primitiveIndex value: prim].	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	^self addProperty: #primitiveIndex value: 117.! !!CParser methodsFor: 'primitives' stamp: 'ar 3/26/2004 15:45'!primitiveDeclarations	| prim module |	(self matchToken: 'primitive:') ifFalse:[^self externalFunctionDeclaration].	prim _ here.	(self match: #number) ifTrue:[^prim].	"Indexed primitives"	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	^117! !!CParser methodsFor: 'positional message' stamp: 'ar 3/26/2004 15:45'!positionalArgs	"Parse a series of positional arguments, separated by comma."	| args |	(hereType == #rightParenthesis) ifTrue:[self advance. ^#()].	args := WriteStream on: (Array new: 3).	[		self positionalArgsExpression ifFalse:[^self expected: 'argument'].		args nextPut: parseNode.		hereType == #rightParenthesis ifTrue:[self advance. ^args contents].		here == #, ifFalse:[^self expected: 'comma'].		self advance.	] repeat.! !!CParser methodsFor: 'positional message' stamp: 'ar 3/26/2004 15:45'!positionalArgsExpression	"Just like #expression just keep track of commas"	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(here == #, or:[hereType == #rightParenthesis]) ifTrue:[^true].	^self positionalMessagePart: 3 repeat: true! !!CParser methodsFor: 'positional message' stamp: 'ar 3/26/2004 15:58'!positionalMessagePart: level repeat: repeat	"Just like #messagePart but keep track of comma"	| start receiver selector args precedence words keywordStart type |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2 and:[here ~= #,]])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [(hereType == #word or:[hereType == #positionalMessage])						ifTrue: 							[start _ self startOfNextToken.							type := hereType.							selector _ self advance.							type == #word ifTrue:[								args _ #().							] ifFalse:[								args := self positionalArgs.								selector := selector,'/', args size printString.							].							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ CMessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!CParser methodsFor: 'properties' stamp: 'ar 3/26/2004 15:45'!correctProperty: proposedName interval: spot	"Correct the proposedName to a known type.	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection |	"If we can't ask the user for correction, make it undefined"	self interactive ifFalse: [		Transcript cr; show: 'Property value ', proposedName, ' is undefined (ignored).'.		^nil].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleNamesFor: proposedName.	aStream _ WriteStream on: (String new: 200).	alternatives do:[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: (alternatives size)))		startUpWithCaption:(('Unknown global: ', proposedName, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + proposedName size).	(choice = 0) | (choice > (alternatives size))		ifTrue: [self fail. ^nil].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	"Spelling correction"	self substituteWord: (alternatives at: choice)			wordInterval: spot			offset: 0.	^(alternatives at: choice)! !!CParser methodsFor: 'properties' stamp: 'ar 3/26/2004 15:45'!hasProperty: propName	properties ifNil:[^false].	^properties includesKey: propName! !!CParser methodsFor: 'properties' stamp: 'ar 3/26/2004 15:45'!properties	"Parse method properties"	[true] whileTrue:[		(self matchToken: #<) ifFalse:[^self].		self property.		(self matchToken: #>) ifFalse: [^ self expected: '>'].	].! !!CParser methodsFor: 'properties' stamp: 'ar 3/26/2004 15:45'!property	"Read a single property. Primitives and others may have fixed spec.	Parse all generic properties in the form of:		<propKey: propValue>	and remember them as method properties."	| propName propValue varStart varEnd |	(self hasProperty: #primitiveIndex) ifFalse:[		"Only one primitive specification is allowed"		self externalFunctionDeclaration ifTrue:[^true].		self primitiveDeclaration ifTrue:[^true].	].	hereType == #keyword ifFalse:[^false].	propName _ self advance allButLast. "remove last colon"	propName = 'on' ifTrue:[^self eventTrigger].	"propName = 'signals' ifTrue:[^self eventSignaler]."	(hereType == #number or:[hereType == #literal or:[hereType == #string]]) ifTrue:[		^self addProperty: propName value: self advance].	"We shouldn't have any but #word hereTypes at this point"	hereType == #word ifFalse:[^self error:'*** FIX THIS ***'].	varStart _ self startOfNextToken + requestorOffset.	propValue _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	propValue = 'true' ifTrue:[^self addProperty: propName value: true].	propValue = 'false' ifTrue:[^self addProperty: propName value: false].	[true] whileTrue:[		Symbol hasInterned: propValue ifTrue:[:aSymbol|			(encoder classEncoding bindingOf: aSymbol) ifNotNilDo:[:assoc|				^self addProperty: propName value: assoc value.			].		].		propValue _ self correctProperty: propValue interval: (varStart to: varEnd).		propValue ifNil:[^nil].	].	^true! !!CParser methodsFor: 'events' stamp: 'ar 3/26/2004 15:45'!blockTrigger	"Parse a block trigger"	| methodNode method |	self advance.	self statements: #() innerBlock: false.	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].	methodNode _ self newMethodNode.	methodNode		selector: #blockTrigger		arguments: #()		precedence: 1		temporaries: #()		block: parseNode		encoder: encoder		primitive: 0		properties: nil.	method := methodNode generate: #(0 0 0 0).	^method! !!CParser methodsFor: 'events' stamp: 'ar 3/26/2004 15:45'!eventSignaler	"Process an event trigger pragma, e.g.,		<signals: #eventName> (deprecated form)		<signals: eventName> (new form)		<signals: eventName in: signaler>	"	"All style event trigger"	| eventName var |	hereType == #literal ifTrue:[		"Deprecated"		(CDeprecatedFeature signal == true) ifFalse:[^false].		^self addProperty: #signals value: self advance].	hereType == #word ifFalse:[^false].	eventName := self advance.	(hereType == #keyword and:[here = 'in:']) 		ifFalse:[^self addProperty: #signals value: eventName asSymbol].	self advance.	hereType == #word ifFalse:[^self expected: 'signaler'].	var := self variable.	^self addProperty: #signals:in: value: {eventName asSymbol. var name asSymbol}! !!CParser methodsFor: 'events' stamp: 'ar 3/26/2004 15:45'!eventTrigger	"Process an event trigger pragma, e.g.,		<on: #eventName> (deprecated form)		<on: eventName> (new form)		<on: eventName in: signaler>	"	"All style event trigger"	| eventName var |	hereType == #literal ifTrue:[		"Deprecated"		(CDeprecatedFeature signal == true) ifFalse:[^false].		^self addProperty: 'on' value: self advance].	hereType == #leftBracket ifTrue:[^self addProperty: 'on' value: self blockTrigger].	hereType == #word ifFalse:[^false].	eventName := self advance.	(hereType == #keyword and:[here = 'in:']) 		ifFalse:[^self addProperty: #on value: eventName asSymbol].	self advance.	hereType == #word ifFalse:[^self expected: 'signaler'].	var := self variable.	^self addProperty: #on:in: value: {eventName asSymbol. var name asSymbol}! !!CParser methodsFor: 'events' stamp: 'ar 3/26/2004 15:45'!parseArgNames: aString        "Parse the argument, aString, notifying req if an error occurs. Otherwise,         answer a two-element Array containing Arrays of strings (the argument         names and temporary variable names)."        aString == nil ifTrue: [^#()].        doitFlag _ false.               "Don't really know if a doit or not!!"        ^self initPattern: aString                notifying: nil                return: [:pattern | (pattern at: 2)]! !!CSelectorNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emit: stack args: nArgs on: strm	self emit: stack		args: nArgs		on: strm		super: false! !!CSelectorNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emit: stack args: nArgs on: aStream super: supered	| index |	stack pop: nArgs.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]]) ifTrue:		["short send"		code < Send			ifTrue: [^ aStream nextPut: code "special"]			ifFalse: [^ aStream nextPut: nArgs * 16 + code]].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7]) ifTrue: 		["extended (2-byte) send [131 and 133]"		aStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).		^ aStream nextPut: nArgs * 32 + index].	(supered not and: [index <= 63 and: [nArgs <= 3]]) ifTrue:		["new extended (2-byte) send [134]"		aStream nextPut: SendLong2.		^ aStream nextPut: nArgs * 64 + index].	"long (3-byte) send"	aStream nextPut: DblExtDoAll.	aStream nextPut: nArgs + (supered ifTrue: [32] ifFalse: [0]).	aStream nextPut: index! !!CSelectorNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!size: encoder args: nArgs super: supered	| index |	self reserve: encoder.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])		ifTrue: [^1]. "short send"	(supered and: [code < Send]) ifTrue: 		["super special:"		code _ self code: (encoder sharableLitIndex: key) type: 5].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7])		ifTrue: [^ 2]. "medium send"	(supered not and: [index <= 63 and: [nArgs <= 3]])		ifTrue: [^ 2]. "new medium send"	^ 3 "long send"! !!CSelectorNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:46'!printOn: aStream indent: level 	aStream withStyleFor: #keyword		do: [key == nil				ifTrue: [aStream nextPutAll: '<key==nil>']				ifFalse: [aStream nextPutAll: key]]! !!CSelectorNode methodsFor: 'inappropriate' stamp: 'ar 3/26/2004 15:46'!emitForEffect: stack on: strm	self shouldNotImplement! !!CSelectorNode methodsFor: 'inappropriate' stamp: 'ar 3/26/2004 15:46'!emitForValue: stack on: strm	self shouldNotImplement! !!CSelectorNode methodsFor: 'inappropriate' stamp: 'ar 3/26/2004 15:46'!sizeForEffect: encoder	self shouldNotImplement! !!CSelectorNode methodsFor: 'inappropriate' stamp: 'ar 3/26/2004 15:46'!sizeForValue: encoder	self shouldNotImplement! !!CSelectorNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isPvtSelector	"Answer if this selector node is a private message selector."	^key isPvtSelector! !!CSyntaxError methodsFor: 'accessing' stamp: 'bf 4/20/2004 15:46'!doitFlag	^doitFlag! !!CSyntaxError methodsFor: 'accessing' stamp: 'bf 4/20/2004 15:45'!doitFlag: aBoolean	doitFlag _ aBoolean! !!CSyntaxError methodsFor: 'accessing' stamp: 'bf 4/20/2004 15:43'!location	^location! !!CSyntaxError methodsFor: 'accessing' stamp: 'bf 4/20/2004 15:42'!location: anInteger	location _ anInteger! !!CSyntaxError methodsFor: 'accessing' stamp: 'ar 3/19/2004 17:30'!parser	^parser! !!CSyntaxError methodsFor: 'accessing' stamp: 'ar 3/19/2004 17:30'!parser: aParser	parser := aParser! !!CSyntaxError methodsFor: 'private' stamp: 'bf 4/20/2004 15:46'!defaultAction	SyntaxError		errorInClass: parser encoder classEncoding		withCode: (parser sourceString			copyReplaceFrom: location			to: location - 1			with: messageText , ' ->')		doitFlag: doitFlag! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!parser	^parser! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!parser: aParser	parser := aParser! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varEnd	^varEnd! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varEnd: aNumber	varEnd := aNumber! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!varName	^varName! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!varName: aString	varName := aString! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varStart	^varStart! !!CUndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varStart: aNumber	varStart := aNumber! !!CUndeclaredVariableReference methodsFor: 'exceptionDescription' stamp: 'ar 12/8/2002 13:13'!defaultAction	^parser correctVariable: varName interval: (varStart to: varEnd)! !!CVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!asStorableNode: encoder	^ self! !!CVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!name: string	"Change name"	name _ string.! !!CVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!name: varName index: i type: type	"Only used for initting instVar refs"	name _ varName.	self key: varName		index: i		type: type! !!CVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!name: string key: object code: byte	"Only used for initting std variables, nil, true, false, self, etc."	name _ string.	key _ object.	code _ byte! !!CVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!name: varName key: objRef index: i type: type	"Only used for initting global (litInd) variables"	name _ varName.	self key: objRef		index: i		type: type! !!CVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!assignmentCheck: encoder at: location	(encoder cantStoreInto: name)		ifTrue: [^ location]		ifFalse: [^ -1]! !!CVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^code < LdNil! !!CVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!index	"This code attempts to reconstruct the index from its encoding in code."	code < 0 ifTrue:[^nil].	code > 256 ifTrue:[^code \\ 256].	^code - self type! !!CVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isSelfPseudoVariable	"Answer if this ParseNode represents the 'self' pseudo-variable."	^ (key = 'self') | (name = '{{self}}')! !!CVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isVariableNode	^true! !!CVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isVariableReference	^true! !!CVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!type	"This code attempts to reconstruct the type from its encoding in code.		This allows one to test, for instance, (aNode type = LdInstType)."	| type |	code < 0 ifTrue: [^ code negated].	code < 256 ifFalse: [^ code // 256].	type _ CodeBases findFirst: [:one | code < one].	type = 0		ifTrue: [^ 5]		ifFalse: [^ type - 1]! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitForReturn: stack on: strm	(code >= LdSelf and: [code <= LdNil])		ifTrue: 			["short returns"			strm nextPut: EndMethod - 4 + (code - LdSelf).			stack push: 1 "doesnt seem right"]		ifFalse: 			[super emitForReturn: stack on: strm]! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitForValue: stack on: strm	code < 256		ifTrue: 			[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).			stack push: 1]		ifFalse: 			[self emitLong: LoadLong on: strm.			stack push: 1]! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitLoad: stack on: strm	"Do nothing"! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitStore: stack on: strm	self emitLong: Store on: strm! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitStorePop: stack on: strm	(code between: 0 and: 7)		ifTrue: 			[strm nextPut: ShortStoP + code "short stopop inst"]		ifFalse:			[(code between: 16 and: 23)				ifTrue: [strm nextPut: ShortStoP + 8 + code - 16 "short stopop temp"]				ifFalse: [(code >= 256 and: [code \\ 256 > 63 and: [code // 256 = 4]])						ifTrue: [self emitLong: Store on: strm. strm nextPut: Pop]						ifFalse: [self emitLong: StorePop on: strm]]].	stack pop: 1! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!fieldOffset  "Return temp or instVar offset for this variable"	code < 256		ifTrue: 			[^ code \\ 16]		ifFalse: 			[^ code \\ 256]! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!sizeForReturn: encoder	(code >= LdSelf and: [code <= LdNil])		ifTrue: ["short returns" ^1].	^super sizeForReturn: encoder! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!sizeForStore: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 2].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!CVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!sizeForStorePop: encoder	self reserve: encoder.	(code < 24 and: [code noMask: 8]) ifTrue: [^ 1].	code < 256 ifTrue: [^ 2].	code \\ 256 <= 63 ifTrue: [^ 2].  "extended StorePop"	code // 256 = 1 ifTrue: [^ 3].  "dbl extended StorePopInst"	code // 256 = 4 ifTrue: [^ 4].  "dbl extended StoreLitVar , Pop"	self halt.  "Shouldn't get here"! !!CVariableNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:46'!printOn: aStream indent: level 	aStream withStyleFor: #variable		do: [aStream nextPutAll: name].! !!CVariableNode methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:46'!name	^ name! !!CFieldNode methodsFor: 'initialize-release' stamp: 'ar 3/12/2004 00:06'!fieldDefinition: fieldDefinition	self name: fieldDefinition name key: fieldDefinition index: nil type: LdLitType! !!CFieldNode methodsFor: 'initialize-release' stamp: 'ar 1/1/2003 20:13'!name: varName key: objRef index: i type: type	fieldDef := objRef.	^super name: varName key: objRef key index: nil type: LdLitType! !!CFieldNode methodsFor: 'accessing' stamp: 'ar 9/4/2003 16:24'!fieldDef	^fieldDef! !!CFieldNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:19'!assignmentCheck: encoder at: location	(encoder cantStoreInto: name) ifTrue: [^location].	fieldDef toSet ifNil:[		encoder interactive ifTrue:[^location].		fieldDef := fieldDef clone assignDefaultSetter.	].	^-1! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 1/1/2003 19:59'!emitForEffect: stack on: strm! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 1/1/2003 20:15'!emitForValue: stack on: aStream	fieldDef accessKey ifNil:[		rcvrNode emitForValue: stack on: aStream.		readNode emit: stack args: 0 on: aStream super: false.	] ifNotNil:[		rcvrNode emitForValue: stack on: aStream.		super emitForValue: stack on: aStream.		readNode emit: stack args: 1 on: aStream super: false.	].! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 1/1/2003 20:16'!emitLoad: stack on: strm	rcvrNode emitForValue: stack on: strm.	fieldDef accessKey ifNotNil:[		super emitForValue: stack on: strm.	].! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 1/1/2003 20:17'!emitStore: stack on: strm	fieldDef accessKey ifNil:[		writeNode emit: stack args: 1 on: strm super: false.	] ifNotNil:[		writeNode emit: stack args: 2 on: strm super: false.	].! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 1/1/2003 19:59'!emitStorePop: stack on: strm	self emitStore: stack on: strm.	strm nextPut: Pop.	stack pop: 1.! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 3/10/2003 11:46'!encodeReceiverOn: encoder	"encode the receiver node"	rcvrNode := encoder encodeVariable: 'self'.! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 1/1/2003 19:59'!sizeForEffect: encoder	^0! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 3/10/2003 09:05'!sizeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeForValue: encoder) + 			(writeNode size: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeForValue: encoder) + 		(super sizeForValue: encoder) +			(writeNode size: encoder args: 2 super: false)! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 1/1/2003 19:59'!sizeForStorePop: encoder	^(self sizeForStore: encoder) + 1! !!CFieldNode methodsFor: 'code generation' stamp: 'ar 3/10/2003 09:05'!sizeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeForValue: encoder) + 			(readNode size: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeForValue: encoder) + 		(super sizeForValue: encoder) + 			(readNode size: encoder args: 1 super: false)! !!CInstanceVariableNode methodsFor: 'initialize' stamp: 'ar 3/26/2004 15:44'!name: varName index: varIndex	^self name: varName index: varIndex-1 type: LdInstType! !!CLiteralVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitForValue: stack on: strm	super emitForValue: stack on: strm.	readNode ifNotNil:[readNode emit: stack args: 0 on: strm super: false].! !!CLiteralVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitLoad: stack on: strm	writeNode ifNil:[^super emitLoad: stack on: strm].	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1.! !!CLiteralVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitStore: stack on: strm	writeNode ifNil:[^super emitStore: stack on: strm].	writeNode			emit: stack			args: 1			on: strm			super: false.! !!CLiteralVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitStorePop: stack on: strm	writeNode ifNil:[^super emitStorePop: stack on: strm].	self emitStore: stack on: strm.	strm nextPut: Pop.	stack pop: 1.! !!CLiteralVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!sizeForStore: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStore: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	writeNode _ encoder encodeSelector: #value:.	^(writeNode size: encoder args: 1 super: false) + (super sizeForValue: encoder)! !!CLiteralVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!sizeForStorePop: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStorePop: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	writeNode _ encoder encodeSelector: #value:.	^(writeNode size: encoder args: 1 super: false) + (super sizeForValue: encoder) + 1! !!CLiteralVariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!sizeForValue: encoder	| index |	(key isVariableBinding and:[key isSpecialReadBinding]) 		ifFalse:[^super sizeForValue: encoder].	code < 0 ifTrue:[		index _ self index.		code _ self code: index type: LdLitType].	readNode _ encoder encodeSelector: #value.	^(readNode size: encoder args: 0 super: false) + (super sizeForValue: encoder)! !!CTempVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!isArg: aBoolean	isAnArg _ aBoolean.	isAnArg ifTrue: [hasDefs _ true]! !!CTempVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!name: varName index: i type: type scope: level	"Only used for initting temporary variables"	name _ varName.	self key: varName		index: i		type: type.	isAnArg _ hasDefs _ hasRefs _ false.	scope _ level! !!CTempVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!nowHasDef	hasDefs _ true! !!CTempVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!nowHasRef	hasRefs _ true! !!CTempVariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!scope: level	"Note scope of temporary variables.	Currently only the following distinctions are made:		0	outer level: args and user-declared temps		1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:"	scope _ level! !!CTempVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!assignmentCheck: encoder at: location	isAnArg ifTrue: [^ location]			ifFalse: [^ -1]! !!CTempVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isArg	^ isAnArg! !!CTempVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isTemp	^ true! !!CTempVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isUndefTemp	^ hasDefs not! !!CTempVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!isUnusedTemp	^ hasRefs not! !!CTempVariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!scope	^ scope! !!CTempVariableNode methodsFor: 'printing' stamp: 'ar 3/26/2004 15:46'!printOn: aStream indent: level 	aStream withStyleFor: #temporaryVariable			do: [aStream nextPutAll: name]! !!Class methodsFor: '*Tweak-Compiler' stamp: 'ar 3/27/2004 14:07'!fullName	^(environment == nil or:[environment == Smalltalk])		ifTrue:[^('Squeak::',name) asSymbol]		ifFalse:[^environment fullNameFor: self localName]! !!Class methodsFor: '*Tweak-Compiler' stamp: 'ar 3/27/2004 14:06'!localName	^(name findTokens:':') last asSymbol! !!CCompiler class methodsFor: 'accessing' stamp: 'ar 3/27/2004 02:10'!new	^ super new parserClass: CParser! !!CCompiler class methodsFor: 'accessing' stamp: 'ar 3/26/2004 15:59'!old	^ self new parserClass: CParser! !!CCompiler class methodsFor: 'evaluating' stamp: 'ar 3/27/2004 20:26'!evaluate: textOrString 	"See Compiler|evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor. 	Compilation is carried out with respect to nil, i.e., no object, and the 	invocation is not logged."	^self evaluate: textOrString for: nil logged: false! !!CCompiler class methodsFor: 'evaluating' stamp: 'ar 3/26/2004 15:43'!evaluate: textOrString for: anObject logged: logFlag 	"See Compiler|evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor."	^self evaluate: textOrString for: anObject notifying: nil logged: logFlag! !!CCompiler class methodsFor: 'evaluating' stamp: 'ar 3/27/2004 02:17'!evaluate: textOrString for: anObject notifying: aController logged: logFlag	"Compile and execute the argument, textOrString with respect to the class 	of anObject. If a compilation error occurs, notify aController. If both 	compilation and execution are successful then, if logFlag is true, log 	(write) the text onto a system changes file so that it can be replayed if 	necessary."	| val |	val _ self new				evaluate: textOrString				in: nil				to: anObject				notifying: aController				ifFail: [^nil].	logFlag ifTrue: [Smalltalk logChange: textOrString].	^val! !!CCompiler class methodsFor: 'evaluating' stamp: 'ar 3/27/2004 20:26'!evaluate: textOrString logged: logFlag 	"See Compiler|evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor. 	Compilation is carried out with respect to nil, i.e., no object."	^self evaluate: textOrString for: nil logged: logFlag! !!CCompiler class methodsFor: 'evaluating' stamp: 'ar 3/27/2004 20:26'!evaluate: textOrString notifying: aController logged: logFlag 	"See Compiler|evaluate:for:notifying:logged:. Compilation is carried out 	with respect to nil, i.e., no object."	^self evaluate: textOrString for: nil notifying: aController logged: logFlag! !!CCompiler class methodsFor: 'evaluating' stamp: 'ar 3/27/2004 04:18'!evaluate: textOrString notifying: aController logged: logFlag in: envt	| val |	val _ self new				evaluate: textOrString				notifying: aController				in: envt.	logFlag ifTrue: [Smalltalk logChange: textOrString].	^val! !!CDecompiler class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 16:33'!initialize	CascadeFlag _ 'cascade'.  "A unique object"	CaseFlag _ 'case'. "Ditto"	ArgumentFlag _ 'argument'.  "Ditto"	IfNilFlag _ 'ifNil'.  "Ditto"	"CDecompiler initialize"! !!CDialectStream class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 16:33'!initialize	"Initialize the color tables"	self initializeST80ColorTable.	self initializeSq00ColorTable."CDialectStream initialize"! !!CDialectStream class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 15:54'!initializeST80ColorTable	"Initiialize the colors that characterize the ST80 dialect"	ST80ColorTable _ IdentityDictionary new.	#(	(temporaryVariable blue italic)		(methodArgument blue normal)		(methodSelector black bold)		(blockArgument red normal)		(comment brown normal)		(variable magenta normal)		(literal	tan normal)		(keyword darkGray bold)		(prefixKeyword veryDarkGray bold)		(setOrReturn black bold)) do:			[:aTriplet |				ST80ColorTable at: aTriplet first put: aTriplet allButFirst]"DialectStream initialize"! !!CDialectStream class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 15:54'!initializeSq00ColorTable	"Initiialize the colors that characterize the Sq00 dialect"	Sq00ColorTable _ IdentityDictionary new.	#(	(temporaryVariable black normal)		(methodArgument black normal)		(methodSelector black bold)		(blockArgument black normal)		(comment brown normal)		(variable black normal)		(literal	 blue normal)		(keyword darkGray bold)		(prefixKeyword veryDarkGray bold)		(setOrReturn black bold)) do:			[:aTriplet |				Sq00ColorTable at: aTriplet first put: aTriplet allButFirst]! !!CDialectStream class methodsFor: 'instance creation' stamp: 'ar 3/26/2004 15:54'!dialect: dialectSymbol contents: blockWithArg 	"Evaluate blockWithArg on a DialectStream of the given description"	| stream |	stream _ self on: (Text new: 400).	stream setDialect: dialectSymbol.	blockWithArg value: stream.	^ stream contents! !!CParseNode class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 15:45'!blockReturnCode	^ EndRemote! !!CParseNode class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 16:34'!initialize	"CParseNode initialize. CVariableNode initialize"	LdInstType _ 1.	LdTempType _ 2.	LdLitType _ 3.	LdLitIndType _ 4.	SendType _ 5.	CodeBases _ #(0 16 32 64 208 ).	CodeLimits _ #(16 16 32 32 16 ).	LdSelf _ 112.	LdTrue _ 113.	LdFalse _ 114.	LdNil _ 115.	LdMinus1 _ 116.	LoadLong _ 128.	Store _ 129.	StorePop _ 130.	ShortStoP _ 96.	SendLong _ 131.	DblExtDoAll _ 132.	SendLong2 _ 134.	LdSuper _ 133.	Pop _ 135.	Dup _ 136.	LdThisContext _ 137.	EndMethod _ 124.	EndRemote _ 125.	Jmp _ 144.	Bfp _ 152.	JmpLimit _ 8.	JmpLong _ 164.  "code for jmp 0"	BtpLong _ 168.	SendPlus _ 176.	Send _ 208.	SendLimit _ 16! !!CParseNode class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 15:45'!popCode	^ Pop! !!CBlockNode class methodsFor: 'instance creation' stamp: 'ar 3/26/2004 15:42'!statements: statements returns: returns	^ self new statements: statements returns: returns! !!CBlockNode class methodsFor: 'instance creation' stamp: 'ar 3/26/2004 15:42'!withJust: aNode	^ self statements: (Array with: aNode) returns: false! !!CBraceNode class methodsFor: 'examples' stamp: 'ar 3/26/2004 15:43'!example	"Test the {a. b. c} syntax."	| x |	x _ {1. {2. 3}. 4}.	^ {x first. x second first. x second last. x last. 5} as: Set"BraceNode example Set (0 1 2 3 4 5 )"! !!CMessageNode class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 16:33'!initialize		"CMessageNode initialize"	MacroSelectors _ 		#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers _ 		#(transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters _ 		#(emitIf:on:value: emitIf:on:value: emitIf:on:value: emitIf:on:value:			emitIf:on:value: emitIf:on:value:			emitWhile:on:value: emitWhile:on:value: emitWhile:on:value: emitWhile:on:value:			emitToDo:on:value: emitToDo:on:value:			emitCase:on:value: emitCase:on:value:			emitIfNil:on:value: emitIfNil:on:value: emitIf:on:value: emitIf:on:value:).	MacroSizers _ 		#(sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value:			sizeIf:value: sizeIf:value:			sizeWhile:value: sizeWhile:value: sizeWhile:value: sizeWhile:value:			sizeToDo:value: sizeToDo:value:			sizeCase:value: sizeCase:value:			sizeIfNil:value: sizeIfNil:value: sizeIf:value: sizeIf:value: ).	MacroPrinters _ 		#(printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !!CScanner class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 16:34'!initialize	| newTable |	newTable _ Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	1 to: 255		do: [:index |			(Character value: index) isLetter				ifTrue: [newTable at: index put: #xLetter]].	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #leftArrow.	newTable at: $| asciiValue put: #verticalBar.	TypeTable _ newTable "bon voyage!!"	"CScanner initialize"! !!CScanner class methodsFor: 'instance creation' stamp: 'ar 3/26/2004 15:45'!new	^super new initScanner! !!CScanner class methodsFor: 'testing' stamp: 'ar 3/26/2004 15:45'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [('$''"()#0123456789' includes: (aSymbol at: 1))		ifTrue: [^ false] ifFalse: [^ true]].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].	type == #xBinary ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].					i _ i - 1].			^ true].	type == #xLetter ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^ false].					i _ i - 1].			^ true].	^ false! !!CVariableNode class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 22:09'!initialize    "CVariableNode initialize.  CDecompiler initialize"	| encoder |	super initialize.	encoder _ CEncoder new.	StdVariables _ Dictionary new: 16.	encoder		fillDict: StdVariables		with: CVariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors _ Dictionary new: 64.	encoder		fillDict: StdSelectors		with: CSelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals _ CLiteralDictionary new: 16.	encoder		fillDict: StdLiterals		with: CLiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil _ encoder encodeVariable: 'nil'.	NodeTrue _ encoder encodeVariable: 'true'.	NodeFalse _ encoder encodeVariable: 'false'.	NodeSelf _ encoder encodeVariable: 'self'.	NodeThisContext _ encoder encodeVariable: 'thisContext'.	NodeSuper _ encoder encodeVariable: 'super'! !!LookupKey methodsFor: '*Tweak-Compiler' stamp: 'ar 3/26/2004 22:12'!isSpecialReadBinding	"Return true if this variable binding is read protected, e.g., should not be accessed primitively but rather by sending #value messages"	^false! !!Metaclass methodsFor: '*Tweak-Compiler' stamp: 'ar 3/27/2004 06:06'!compilerClass	^thisClass compilerClass! !!Metaclass methodsFor: '*Tweak-Compiler' stamp: 'ar 3/27/2004 06:07'!evaluatorClass	^thisClass evaluatorClass! !!Metaclass methodsFor: '*Tweak-Compiler' stamp: 'ar 3/27/2004 06:06'!parserClass	^thisClass parserClass! !!CTempVariableNode class reorganize!('as yet unclassified')!!CLiteralVariableNode class reorganize!('as yet unclassified')!!CInstanceVariableNode class reorganize!('as yet unclassified')!!CFieldNode class reorganize!('as yet unclassified')!CVariableNode initialize!!CVariableNode class reorganize!('class initialization' initialize)!!CUndeclaredVariableReference class reorganize!('as yet unclassified')!!CSyntaxError class reorganize!('as yet unclassified')!!CSelectorNode class reorganize!('as yet unclassified')!!CParser class reorganize!('as yet unclassified')!CScanner initialize!!CScanner class reorganize!('class initialization' initialize)('instance creation' new)('testing' isLiteralSymbol:)!!CReturnNode class reorganize!('as yet unclassified')!!CMethodTempsNode class reorganize!('as yet unclassified')!!CMethodNode class reorganize!('as yet unclassified')!!CMessageAsTempNode class reorganize!('as yet unclassified')!CMessageNode initialize!!CMessageNode class reorganize!('class initialization' initialize)!!CLiteralNode class reorganize!('as yet unclassified')!!CLeafNode class reorganize!('as yet unclassified')!!CEncoder class reorganize!('as yet unclassified')!!CDecompilerConstructor class reorganize!('as yet unclassified')!!CCommentNode class reorganize!('as yet unclassified')!!CCascadeNode class reorganize!('as yet unclassified')!!CBraceNode class reorganize!('examples' example)!!CBlockNode class reorganize!('instance creation' statements:returns: withJust:)!!CAssignmentNode class reorganize!('as yet unclassified')!CParseNode initialize!!CParseNode class reorganize!('class initialization' blockReturnCode initialize popCode)!!CLiteralDictionary class reorganize!('as yet unclassified')!CDialectStream initialize!!CDialectStream class reorganize!('class initialization' initialize initializeST80ColorTable initializeSq00ColorTable)('instance creation' dialect:contents:)!!CDeprecatedFeature class reorganize!('as yet unclassified')!CDecompiler initialize!!CDecompiler class reorganize!('class initialization' initialize)!!CCompiler class reorganize!('accessing' new old)('evaluating' evaluate: evaluate:for:logged: evaluate:for:notifying:logged: evaluate:logged: evaluate:notifying:logged: evaluate:notifying:logged:in:)!!CTempVariableNode reorganize!('initialize-release' isArg: name:index:type:scope: nowHasDef nowHasRef scope:)('testing' assignmentCheck:at: isArg isTemp isUndefTemp isUnusedTemp scope)('printing' printOn:indent:)!!CLiteralVariableNode reorganize!('code generation' emitForValue:on: emitLoad:on: emitStore:on: emitStorePop:on: sizeForStore: sizeForStorePop: sizeForValue:)!!CInstanceVariableNode reorganize!('initialize' name:index:)!!CFieldNode reorganize!('initialize-release' fieldDefinition: name:key:index:type:)('accessing' fieldDef)('testing' assignmentCheck:at:)('code generation' emitForEffect:on: emitForValue:on: emitLoad:on: emitStore:on: emitStorePop:on: encodeReceiverOn: sizeForEffect: sizeForStore: sizeForStorePop: sizeForValue:)!!CVariableNode reorganize!('initialize-release' asStorableNode: name: name:index:type: name:key:code: name:key:index:type:)('testing' assignmentCheck:at: canBeSpecialArgument index isSelfPseudoVariable isVariableNode isVariableReference type)('code generation' emitForReturn:on: emitForValue:on: emitLoad:on: emitStore:on: emitStorePop:on: fieldOffset sizeForReturn: sizeForStore: sizeForStorePop:)('printing' printOn:indent:)('accessing' name)!!CUndeclaredVariableReference reorganize!('accessing' parser parser: varEnd varEnd: varName varName: varStart varStart:)('exceptionDescription' defaultAction)!!CSyntaxError reorganize!('accessing' doitFlag doitFlag: location location: parser parser:)('private' defaultAction)!!CSelectorNode reorganize!('code generation' emit:args:on: emit:args:on:super: size:args:super:)('printing' printOn:indent:)('inappropriate' emitForEffect:on: emitForValue:on: sizeForEffect: sizeForValue:)('testing' isPvtSelector)!!CParser reorganize!('public access' encoder parse:class: parse:class:noPattern:context:notifying:ifFail: parseArgs:notifying: parseArgsAndTemps:notifying: parseMethodComment:setPattern: parseSelector:)('expression types' argumentName assignment: blockExpression braceExpression cascade expression keylessMessagePartTest:repeat: matrixExpression: messagePart:repeat: method:context:encoder: newMethodNode pattern:inContext: primaryExpression remoteAssignment scopeVariable statements:innerBlock: temporaries temporaryBlockVariables variable)('scanning' advance endOfLastToken match: matchReturn matchToken: startOfNextToken)('temps' bindArg: bindTemp:)('error handling' expected: fail interactive notify: notify:at: offEnd:)('error correction' correctSelector:wordIntervals:exprInterval:ifAbort: correctVariable:interval: declareClassVar: declareGlobal: declareTempAndPaste: queryUndefined removeUnusedTemps substituteSelector:wordIntervals: substituteWord:wordInterval:offset:)('private' addComment addProperty:value: init:notifying:failBlock: initPattern:notifying:return: methodSelector sourceString)('primitives' allocateLiteral: externalFunctionDeclaration externalType: primitive primitiveDeclaration primitiveDeclarations)('positional message' positionalArgs positionalArgsExpression positionalMessagePart:repeat:)('properties' correctProperty:interval: hasProperty: properties property)('events' blockTrigger eventSignaler eventTrigger parseArgNames:)!!CScanner reorganize!('initialize-release' initScanner scan:)('public access' scanFieldNames: scanMessageParts: scanStringStruct: scanTokens:)('expression types' advance checkpoint nextLiteral revertToCheckpoint: scanLitVec scanLitWord scanStringStruct scanToken step)('multi-character scans' xBinary xColon xDelimiter xDigit xDollar xDoubleQuote xLetter xLitQuote xSingleQuote)('error handling' notify: offEnd:)!!CReturnNode reorganize!('initialize-release' expr: expr:encoder:sourceRange:)('converting' asReturnNode)('testing' isReturnSelf isSpecialConstant isVariableReference)('code generation' code emitForReturn:on: emitForValue:on: pc sizeForReturn: sizeForValue:)('printing' printOn:indent:)!!CMethodTempsNode reorganize!('as yet unclassified')!!CMethodNode reorganize!('initialize-release' block selector: selector:arguments:precedence:temporaries:block:encoder:primitive: selector:arguments:precedence:temporaries:block:encoder:primitive:properties: sourceText:)('code generation' encoder generate: generate:ifQuick: generateNative: parserClass selector sourceMap)('converting' asColorizedSmalltalk80Text decompileString decompileText)('printing' methodClass printOn: printPrimitiveOn: printPropertiesOn: sourceText tempNames)!!CMessageAsTempNode reorganize!('access to remote temps' asStorableNode: code emitStorePop:on: isTemp nowHasDef nowHasRef scope scope: sizeForStorePop: store:from:)!!CMessageNode reorganize!('initialize-release' receiver:selector:arguments:precedence: receiver:selector:arguments:precedence:from: receiver:selector:arguments:precedence:from:sourceRange: selector:)('testing' canCascade isComplex isMessage:receiver:arguments: isMessageNode isReturningIf toDoIncrement: toDoLimit:)('cascading' cascadeReceiver)('macro transformations' noteSpecialSelector: toDoFromWhileWithInit: transform: transformAnd: transformBoolean: transformIfFalse: transformIfFalseIfTrue: transformIfNil: transformIfNilIfNotNil: transformIfNotNilIfNil: transformIfTrue: transformIfTrueIfFalse: transformOr: transformToDo: transformWhile:)('code generation' emitCase:on:value: emitForEffect:on: emitForValue:on: emitIf:on:value: emitIfNil:on:value: emitToDo:on:value: emitWhile:on:value: pc sizeCase:value: sizeForEffect: sizeForValue: sizeIf:value: sizeIfNil:value: sizeToDo:value: sizeWhile:value:)('printing' asMorphicCaseOn:indent: macroPrinter precedence printCaseOn:indent: printIfNil:indent: printIfNilNotNil:indent: printIfOn:indent: printKeywords:arguments:on:indent: printKeywords:arguments:on:indent:prefix: printOn:indent: printOn:indent:precedence: printParenReceiver:on:indent: printReceiver:on:indent: printToDoOn:indent: printWhileOn:indent: test)('private' checkBlock:as:from: ifNilReceiver pvtCheckForPvtSelector: receiver:arguments:precedence: transformCase:)('equation translation' arguments arguments: eval receiver receiver: selector)!!CLiteralNode reorganize!('code generation' emitForValue:on:)('testing' isConstantNumber isLiteral isSpecialConstant literalValue)('printing' printOn:indent:)('evaluation' eval)!!CLeafNode reorganize!('initialize-release' key:code: key:index:type: name:key:code: name:key:index:type:)('accessing' key)('code generation' code emitForEffect:on: emitLong:on: reserve: sizeForEffect: sizeForValue:)('private' code:type:)('copying' veryDeepFixupWith: veryDeepInner:)!!CEncoder reorganize!('initialize-release' fillDict:with:mapping:to: init:context:notifying: initScopeAndLiteralTables nTemps:literals:class: noteSuper release temps:literals:class:)('encoding' cantStoreInto: encodeGlobal:sourceRange: encodeLiteral: encodeSelector: encodeVariable: encodeVariable:ifUnknown: encodeVariable:sourceRange:ifUnknown: litIndex: sharableLitIndex: undeclared:)('temps' autoBind: bindAndJuggle: bindArg: bindBlockTemp: bindTemp: maxTemp newTemp:)('results' allLiterals associationFor: literals tempNames tempNodes tempsAndBlockArgs unusedTempNames)('error handling' notify: notify:at: requestor:)('source mapping' globalSourceRanges noteSourceRange:forNode: rawSourceRanges sourceMap sourceRangeFor:)('private' classEncoding global:name: interactive lookupInPools:ifFound: name:key:class:type:set: possibleNamesFor: possibleVariablesFor: reallyBind: warnAboutShadowed: warnAboutUndeclared:)!!CDecompilerConstructor reorganize!('initialize-release' method:class:literals:)('constructor' codeAnyLitInd: codeAnyLiteral: codeAnySelector: codeArguments:block: codeAssignTo:value: codeBlock:returns: codeBrace: codeCascade:messages: codeCascadedMessage:arguments: codeConstants codeEmptyBlock codeInst: codeMessage:selector:arguments: codeMethod:block:tempVars:primitive:class: codeSelector:code: codeSuper codeTemp: codeTemp:named: codeThisContext decodeIfNilWithReceiver:selector:arguments:)!!CCommentNode reorganize!('as yet unclassified')!!CCascadeNode reorganize!('initialize-release' receiver:messages:)('code generation' emitForValue:on: sizeForValue:)('printing' printOn:indent: printOn:indent:precedence:)('accessing' receiver)!!CBraceNode reorganize!('initialize-release' elements: elements:sourceLocations: matchBraceStreamReceiver:messages: matchBraceWithReceiver:selector:arguments:)('testing' blockAssociationCheck: numElements)('code generation' emitForValue:on: selectorForShortForm: sizeForValue:)('enumerating' casesForwardDo: casesReverseDo:)('printing' printOn:indent:)!!CBlockNode reorganize!('initialize-release' arguments:statements:returns:from: arguments:statements:returns:from:sourceRange: statements:returns:)('accessing' arguments: block firstArgument numberOfArguments returnLast returnNilIfNoOther returnSelfIfNoOther returnSelfIfNoOther: temporaries:)('testing' canBeSpecialArgument isComplex isJust: isJustCaseError isQuick returns)('code generation' code emitExceptLast:on: emitForEvaluatedEffect:on: emitForEvaluatedValue:on: emitForValue:on: sizeExceptLast: sizeForEvaluatedEffect: sizeForEvaluatedValue: sizeForValue:)('printing' printArgumentsOn:indent: printOn:indent: printStatementsOn:indent: printTemporariesOn:indent:)('equation translation' statements statements:)!!CAssignmentNode reorganize!('initialize-release' toDoIncrement: value variable:value: variable:value:from: variable:value:from:sourceRange:)('code generation' emitForEffect:on: emitForValue:on: sizeForEffect: sizeForValue:)('printing' printOn:indent: printOn:indent:precedence:)('equation translation' variable)!!CParseNode reorganize!('testing' assignmentCheck:at: canBeSpecialArgument canCascade isArg isComplex isConstantNumber isLiteral isMessage:receiver:arguments: isMessageNode isReturnSelf isReturningIf isSelfPseudoVariable isSpecialConstant isTemp isUndefTemp isUnusedTemp isVariableNode isVariableReference nowHasDef nowHasRef toDoIncrement:)('code generation' emitBranchOn:dist:pop:on: emitForEffect:on: emitForReturn:on: emitJump:on: emitLong:code:on: emitShortOrLong:code:on: pc sizeBranchOn:dist: sizeForEffect: sizeForReturn: sizeJump: sizeShortOrLong:)('encoding' encodeSelector:)('comment' comment comment:)('converting' asReturnNode)('printing' nodePrintOn:indent: printCommentOn:indent: printOn: printOn:indent: printOn:indent:precedence:)('private' nextWordFrom:setCharacter: printSingleComment:on:indent:)!!CLiteralDictionary reorganize!('as yet unclassified' arrayEquality:and: literalEquality:and: scanFor:)!!CDialectStream reorganize!('color/style' colorTable withColor:emphasis:do: withStyleFor:do:)('access' dialect setDialect:)!!CDeprecatedFeature reorganize!('as yet unclassified' defaultAction isResumable)!!CDecompiler reorganize!('initialize-release' initSymbols: withTempNames:)('control' blockForCaseTo: blockTo: checkForBlock: statementsForCaseTo: statementsTo:)('instruction decoding' blockReturnTop case: doDup doPop doStore: jump: jump:if: methodReturnConstant: methodReturnReceiver methodReturnTop popIntoLiteralVariable: popIntoReceiverVariable: popIntoTemporaryVariable: pushActiveContext pushConstant: pushLiteralVariable: pushReceiver pushReceiverVariable: pushTemporaryVariable: send:super:numArgs: storeIntoLiteralVariable: storeIntoReceiverVariable: storeIntoTemporaryVariable:)('public access' decompile:in: decompile:in:method: tempAt:)('private' convertToDoLoop decompile:in:method:using: interpretNextInstructionFor: methodRefersOnlyOnceToTemp: popTo: quickMethod)!!CCompiler reorganize!('error handling' interactive notify: notify:at:)('public access' compile:in:notifying:ifFail: compileNoPattern:in:context:notifying:ifFail: doIt:in:to:notifying:ifFail: evaluate:in:to:notifying:ifFail: evaluate:notifying:in: format:in:notifying:contentsSymbol: format:in:notifying:decorated: parse:in:notifying: parse:in:notifying:dialect:)('private' cacheDoItNode: format:noPattern:ifFail: from:class:context:notifying: parserClass parserClass: translate:noPattern:ifFail:)!