'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 4 October 2004 at 10:02:16 pm'!Object subclass: #CFieldDefinition	instanceVariableNames: 'name flags type toGet toSet accessKey changeEvent serializer deserializer color '	classVariableNames: 'FlagInstanceVariable FlagNonSerializable FlagPrivate FlagVirtual '	poolDictionaries: ''	category: 'Tweak-Core'!!CFieldDefinition commentStamp: 'ar 3/27/2004 17:17' prior: 0!CFieldDefinition contains the definition of fields. WARNING: This class is fundamental and I still need to do some cleanup and reformulation. You can look but you can't touch ;-) at least not before discussing the changes.!CFieldDefinition class	instanceVariableNames: ''!TextAttribute subclass: #CFieldDefinitionTextAttribute	instanceVariableNames: 'fieldClass fieldDefinition '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!CFieldDefinitionTextAttribute class	instanceVariableNames: ''!Object subclass: #CFileOutMaker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!!CFileOutMaker commentStamp: 'ar 3/27/2004 15:11' prior: 0!I am just a little tool that allows filing out the parts of Tweak in a well-defined order so they can be loaded again.!CFileOutMaker class	instanceVariableNames: ''!Object subclass: #CMethodTrigger	instanceVariableNames: 'selector '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!!CMethodTrigger commentStamp: 'ar 4/28/2004 02:27' prior: 0!CMethodTrigger is the superclass for all method triggers. Method triggers are specifications to send specific messages (resulting in the evaluation of the corresponding methods, hence the name) when "certain things happen", such as an event being triggered.Instance variables:	selector		<Symbol>	The selector of the method being triggered.!CMethodTrigger subclass: #CEventTrigger	instanceVariableNames: 'eventName fieldName changeEvent '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!!CEventTrigger commentStamp: 'ar 4/28/2004 02:30' prior: 0!CEventTrigger is a method trigger which responds to particular events. The event might be generated in the corresponding object or in one of its fields. Event triggers are typically specified using the annotations <on: eventName> or <on: eventName in: fieldName>.Instance variables:	eventName	<Symbol>	The name of the event triggering the script.	fieldName	<Symbol>	The name of the field generating the event.	changeEvent <Symbol>	The name of the change event associated with the field.!CMethodTrigger class	instanceVariableNames: ''!CEventTrigger class	instanceVariableNames: ''!Object subclass: #CNamespace	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!!CNamespace commentStamp: 'ar 3/27/2004 17:12' prior: 0!WARNING: THIS IS UNFINISHED AS OF YET!! But here's how it's supposed to work anyways:Essentially, we don't want to screw with all of the existing tools in Squeak, so we just define that all classes are in the global namespace "Smalltalk" but that the names of the classes are really fully qualified ones. So, for example, the instance variable name 'name' of class Bar in namespace Foo will contain #'Foo::Bar' and we merely fix the lookup so that the namespace contains an entry under #Bar which is found by the compiler. This allows us to leave all of tools alone working with the name of #Foo::Bar if they aren't namespace-aware and have the tools which *are* namespace aware to use #localName or #fullName as they desire.This scheme has various advantages: a) You can reflect about all classes in the system by enumerating through Smalltalk (useful for system-wide tools). b) When we print an object (or inspect a class or similar) we will see it's full name which is good as it avoids confusion. c) If we want to "import" some class it will know where it was defined so we can track that dependency accordingly. Etc. This seems *hugely* advantageous to approaches which try to keep the "local name" of the class and do all sorts of guessing about "who this guy is" (say, Environment>>scopeFor:from:envtAndPathIfFound:) - after all if a class doesn't know where it is defined, who the hell *would* know?So the basic approach here is: Classes know who they are and where they are defined, and we can ask them for a local name which will be a "shorthand notation" in their namespace.The stuff that really doesn't work right now is to fix the tools to the point that they can deal with namespaces AT ALL. There are so many freaking places in the system that are hardwired it's almost impossible to fix them all at once. For example, there's an interesting issue with respect to defining classes - those class definitions *have* to be executed by the environment that defines the class but unless we want to change the class definition message (which would screw up even more tools) you can't really guess which name is being used. Argh... anyways if you want to see what I'm talking about try to define something like:Squeak::Object subclass: #Object	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Kernel'inside the Tweak namespace. You'll see what I'm talking about...!CNamespace class	instanceVariableNames: 'names uniqueInstance '!Object subclass: #CProtoObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!!CProtoObject commentStamp: 'ar 3/27/2004 15:11' prior: 0!CProtoObject is the proxy for classes defined in the Tweak-universe (using fields, method triggers, uniclasses, namespaces etc.) and the surrounding "raw" Squeak universe. CProtoObject has therefore only methods dealing with compilation aspects (see the class side) and is otherwise empty.!CProtoObject class	instanceVariableNames: 'classFields methodTriggers '!CMethodTrigger subclass: #CTickingTrigger	instanceVariableNames: 'frequency '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!!CTickingTrigger commentStamp: 'ar 4/28/2004 02:31' prior: 0!CTickingTrigger is the specification for a "ticking" script, e.g., a script which is evaluated repeatedly with a certain frequency. Ticking scripts are typically specified with the <ticking: frequency> annotation.Instance variables:	frequency	<Number>	The frequency for the ticking scripts in ticks/sec.!CTickingTrigger class	instanceVariableNames: ''!CNamespace subclass: #Tweak	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Core'!!Tweak commentStamp: 'ar 3/27/2004 15:12' prior: 0!I simply occupy the global name Tweak in the Smalltalk namespace so that there is no confusion about whether that name is used or not. It is - All Rights Reserved ;-)!Tweak class	instanceVariableNames: ''!!CFieldDefinition methodsFor: 'initialize' stamp: 'ar 5/5/2004 21:54'!beInstanceVariable	"Make me into an instance variable"	self isInstanceVariable: true.	self isVirtualField: false.	self serializable: true.	self changeEvent: nil.	self accessKey: nil.	self toGet: name.	self toSet: (name,':') asSymbol.! !!CFieldDefinition methodsFor: 'initialize' stamp: 'ar 5/5/2004 21:53'!beRegularField	"Make me into a virtual field"	self isInstanceVariable: false.	self isVirtualField: false.	self serializable: true.	self changeEvent: (name, 'Changed') asSymbol.	self accessKey: nil.	self toGet: name.	self toSet: (name,':') asSymbol.! !!CFieldDefinition methodsFor: 'initialize' stamp: 'ar 5/5/2004 21:54'!beVirtualField	"Make me into a virtual field"	self isInstanceVariable: false.	self isVirtualField: true.	self serializable: false.	self changeEvent: nil.	self accessKey: nil.	self toGet: name.	self toSet: (name,':') asSymbol.! !!CFieldDefinition methodsFor: 'initialize'!initialize	"Initialize the receiver"	flags := 0.! !!CFieldDefinition methodsFor: 'accessing'!accessKey	"Answer the access key that is used to index the field some object"	^accessKey! !!CFieldDefinition methodsFor: 'accessing'!accessKey: anObject	"Set the access key that is used to index the field some object"	accessKey := anObject! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 3/9/2003 22:57'!changeEvent	^changeEvent ifNil:[(self name, 'Changed') asSymbol]! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 3/9/2003 22:57'!changeEvent: aSymbol	changeEvent := aSymbol.! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/6/2004 12:31'!color	^color! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/6/2004 18:07'!color: aColor	color := aColor ifNotNil:[aColor asColor].! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 9/22/2003 00:35'!deserializer	^deserializer! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 9/22/2003 00:35'!deserializer: aSymbol	deserializer := aSymbol! !!CFieldDefinition methodsFor: 'accessing'!isInstanceVariable	^(flags bitAnd: FlagInstanceVariable) == FlagInstanceVariable! !!CFieldDefinition methodsFor: 'accessing'!isInstanceVariable: aBool	flags := aBool 	ifTrue:[flags bitOr: FlagInstanceVariable] 					ifFalse:[flags bitClear: FlagInstanceVariable]! !!CFieldDefinition methodsFor: 'accessing'!isPrivateField	"Answer whether this field is private"	^(flags bitAnd: FlagPrivate) == FlagPrivate! !!CFieldDefinition methodsFor: 'accessing'!isPrivateField: aBool	"Answer whether this field is private"	flags := aBool ifTrue:[flags bitOr: FlagPrivate] ifFalse:[flags bitClear: FlagPrivate].! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 20:47'!isVirtualField	"Answer whether this field is private"	^(flags bitAnd: FlagVirtual) == FlagVirtual! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 20:48'!isVirtualField: aBool	"Answer whether this field is virtual"	flags := aBool ifTrue:[flags bitOr: FlagVirtual] ifFalse:[flags bitClear: FlagVirtual].! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 1/1/2003 20:09'!key	"for compatibility with bindings"	^self name asSymbol! !!CFieldDefinition methodsFor: 'accessing'!name	^name! !!CFieldDefinition methodsFor: 'accessing'!name: aString	name := aString! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 20:49'!nonSerializable	^(flags bitAnd: FlagNonSerializable) == FlagNonSerializable! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 20:50'!nonSerializable: aBool	"Answer whether this field is non-serializable"	flags := aBool ifTrue:[flags bitOr: FlagNonSerializable] ifFalse:[flags bitClear: FlagNonSerializable].! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 20:50'!serializable	^self nonSerializable not! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 20:50'!serializable: aBool	self nonSerializable: aBool not! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 9/22/2003 00:35'!serializer	^serializer! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 9/22/2003 00:35'!serializer: aSymbol	serializer := aSymbol! !!CFieldDefinition methodsFor: 'accessing'!toGet	"Answer the selector used to retrieve the value of this field"	^toGet! !!CFieldDefinition methodsFor: 'accessing'!toGet: aSymbol	"Set the selector used to retrieve the value of this field"	toGet := aSymbol! !!CFieldDefinition methodsFor: 'accessing'!toSet	"Answer the selector used to store the value of this field"	^toSet! !!CFieldDefinition methodsFor: 'accessing'!toSet: aSymbol	"Set the selector used to store the value of this field"	toSet := aSymbol.! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 18:41'!type	^type! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 18:41'!type: aType	type := aType.! !!CFieldDefinition methodsFor: 'accessing' stamp: 'ar 5/5/2004 20:48'!valueType	"Answer the type of the object that may be stored in the field described by the receiver"	^type! !!CFieldDefinition methodsFor: 'testing' stamp: 'ar 5/5/2004 20:53'!isGeneratingEvents	^self isRegularField and:[changeEvent notNil]! !!CFieldDefinition methodsFor: 'testing' stamp: 'ar 3/10/2003 01:54'!isReadOnly	^toSet == nil! !!CFieldDefinition methodsFor: 'testing' stamp: 'ar 5/5/2004 20:54'!isRegularField	^(self isVirtualField or:[self isInstanceVariable]) not! !!CFieldDefinition methodsFor: 'testing' stamp: 'ar 5/5/2004 20:51'!isSerializable	"Answer whether this field should be serialized"	^self isVirtualField not and:[self serializable]! !!CFieldDefinition methodsFor: 'testing' stamp: 'ar 5/5/2004 18:41'!isTyped	^type notNil! !!CFieldDefinition methodsFor: 'comparing'!= aFieldDef	^aFieldDef class == self class and:[self name = aFieldDef name and:[self flags = aFieldDef flags]]! !!CFieldDefinition methodsFor: 'comparing'!hash	^name hash! !!CFieldDefinition methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: '['; print: name; nextPutAll:']'.! !!CFieldDefinition methodsFor: 'private' stamp: 'ar 3/26/2004 15:13'!assignDefaultSetter	"Private. Assign a default setter for the field. This is needed by the compiler for being able to compile 'forward references' of fields."	toSet := (self name,':') asSymbol.! !!CFieldDefinition methodsFor: 'private' stamp: 'ar 1/1/2003 20:55'!flags	^flags! !!CFieldDefinition methodsFor: 'private' stamp: 'ar 1/1/2003 20:55'!flags: newFlags	flags := newFlags.! !!CFieldDefinition methodsFor: 'private' stamp: 'ar 5/6/2004 12:35'!importXmlFrom: xmlNode	"Read an XML representation of the receiver which can be used to fool old tools"	| val |	xmlNode name == #field 		ifFalse:[^self error: 'Cannot read field from #', xmlNode name].	name := xmlNode contentString asSymbol.	(val := xmlNode attributeAt: 'instanceVariable')		ifNotNil:[self isInstanceVariable: (xmlNode literalAt: 'instanceVariable')].	(val := xmlNode attributeAt: 'virtual')		ifNotNil:[self isVirtualField: (xmlNode literalAt: 'virtual')].	(val := xmlNode attributeAt: 'private')		ifNotNil:[self isPrivateField: (xmlNode literalAt: 'private')].	(val := xmlNode attributeAt: 'serializable')		ifNotNil:[self serializable: (xmlNode literalAt: 'serializable')].	(val := xmlNode attributeAt: 'type')		ifNotNil:[type := Smalltalk at: val asSymbol ifAbsent:[nil]].	(val := xmlNode attributeAt: 'toGet')		ifNotNil:[toGet := val asSymbol].	(val := xmlNode attributeAt: 'toSet')		ifNotNil:[toSet := val asSymbol].	(val := xmlNode attributeAt: 'accessKey')		ifNotNil:[accessKey := xmlNode literalAt: 'accessKey'].	(val := xmlNode attributeAt: 'changeEvent')		ifNotNil:[changeEvent := val asSymbol].	(val := xmlNode attributeAt: 'serializer')		ifNotNil:[serializer := val asSymbol].	(val := xmlNode attributeAt: 'deserializer')		ifNotNil:[deserializer := val asSymbol].	(val := xmlNode attributeAt: 'color')		ifNotNil:[color := Color fromHtmlColorRef: val].! !!CFieldDefinition methodsFor: 'private' stamp: 'ar 5/5/2004 22:15'!readXmlFrom: aStream	"Read an XML representation of the receiver which can be used to fool old tools"	| doc node |	doc := XMLDOMParser parseDocumentFrom: aStream.	node := doc elements first.	self importXmlFrom: node.! !!CFieldDefinition methodsFor: 'private' stamp: 'ar 5/6/2004 12:35'!storeXmlOn: writer	"Answer an XML representation of the receiver which can be used to fool old tools"	writer startTag: 'field'.	self isInstanceVariable		ifTrue:[writer attribute: 'instanceVariable' value: 'true'].	self isVirtualField		ifTrue:[writer attribute: 'virtual' value: 'true'].	self isPrivateField		ifTrue:[writer attribute: 'private' value: 'true'].	self nonSerializable		ifTrue:[writer attribute: 'serializable' value: 'false'].	self isTyped		ifTrue:[writer attribute: 'type' value: type name].	toGet isNil		ifFalse:[writer attribute: 'toGet' value: toGet].	toSet isNil		ifFalse:[writer attribute: 'toSet' value: toSet].	accessKey isNil		ifFalse:[writer attribute: 'accessKey' value: accessKey printString].	changeEvent isNil		ifFalse:[writer attribute: 'changeEvent' value: changeEvent].	serializer isNil		ifFalse:[writer attribute: 'serializer' value: serializer].	deserializer isNil		ifFalse:[writer attribute: 'deserializer' value: deserializer].	color isNil		ifFalse:[writer attribute: 'color' value: color asHtmlColorRef].	writer endTag.	writer pcData: name.	writer endTag: 'field'.! !!CFieldDefinition methodsFor: 'private' stamp: 'ar 5/5/2004 22:06'!xmlString	"Answer an XML representation of the receiver which can be used to fool old tools"	^String streamContents:[:s| self storeXmlOn: s].! !!CFieldDefinition class methodsFor: 'instance creation'!named: aString	^self new name: aString asSymbol! !!CFieldDefinition class methodsFor: 'instance creation'!new	^super new initialize! !!CFieldDefinition class methodsFor: 'class initialization' stamp: 'ar 5/5/2004 20:42'!initialize	"CFieldDefinition initialize"	"FlagInstanceVariable:		This flag determines whether the field is an instance variable."	FlagInstanceVariable := 1.	"FlagVirtual:		This flag marks fields delegating to some other object."	FlagVirtual := 2.	"FlagPrivate:		This flag marks private fields."	FlagPrivate := 4.	"FlagNonSerializable:		This flag marks non-serializable fields."	FlagNonSerializable := 8.! !!CFieldDefinitionTextAttribute methodsFor: 'accessing' stamp: 'ar 5/5/2004 17:27'!fieldClass	^fieldClass! !!CFieldDefinitionTextAttribute methodsFor: 'accessing' stamp: 'ar 5/5/2004 17:27'!fieldClass: aClass	fieldClass := aClass.! !!CFieldDefinitionTextAttribute methodsFor: 'accessing' stamp: 'ar 5/5/2004 17:27'!fieldDefinition	^fieldDefinition! !!CFieldDefinitionTextAttribute methodsFor: 'accessing' stamp: 'ar 5/5/2004 17:27'!fieldDefinition: aFieldDef	fieldDefinition := aFieldDef! !!CFieldDefinitionTextAttribute methodsFor: 'accessing' stamp: 'ar 5/5/2004 21:05'!menu	^fieldClass fieldMenuFor: fieldDefinition! !!CFieldDefinitionTextAttribute methodsFor: 'emphasis' stamp: 'ar 5/6/2004 15:32'!emphasizeScanner: scanner	"Set the emphasis for text display"	fieldDefinition isGeneratingEvents		ifTrue:[scanner addEmphasis: 1]. "bold"	fieldDefinition isVirtualField		ifTrue:[scanner addEmphasis: 2]. "italic"	fieldDefinition isInstanceVariable		ifTrue:[scanner textColor: Color red]		ifFalse:[(fieldDefinition toGet == nil and:[fieldDefinition toSet == nil]) ifTrue:[			scanner addEmphasis: 16. "struck out"		]].	fieldDefinition color ifNotNil:[		scanner textColor: (Color black mixed: 0.5 with: fieldDefinition color).	].! !!CFieldDefinitionTextAttribute class methodsFor: 'instance creation' stamp: 'ar 5/5/2004 17:27'!forField: aField in: aClass	^(self new)		fieldClass: aClass;		fieldDefinition: aField;		yourself! !!CFileOutMaker class methodsFor: 'fileOut' stamp: 'ar 10/4/2004 20:49'!fileOutTweak	"self fileOutTweak"	| tweakCompiler tweakPreload tweakCore tweakFull file |	file := FileStream forceNewFileNamed: 'Tweak-Organization.st'.	(SystemOrganization categories select:[:each| each beginsWith: 'Tweak-']) do:[:catName|		file cr; nextChunkPut: 'SystemOrganization addCategory: ', catName storeString.	].	file close.	tweakCompiler := (PackageInfo named: 'Tweak-Compiler') asChangeSet.	tweakPreload := (PackageInfo named: 'Tweak-Preload') asChangeSet.	tweakCore := (PackageInfo named: 'Tweak-Core') asChangeSet.	tweakFull := (PackageInfo named: 'Tweak') asChangeSet.	tweakFull forgetAllChangesFoundIn: tweakCompiler.	tweakFull forgetAllChangesFoundIn: tweakPreload.	tweakFull forgetAllChangesFoundIn: tweakCore.	tweakCore fileOut.	tweakPreload fileOut.	tweakCompiler fileOut.	tweakFull fileOut.! !!CMethodTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 20:43'!selector	^selector! !!CMethodTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 20:52'!selector: aString	selector := aString asSymbol.! !!CMethodTrigger methodsFor: 'starting' stamp: 'ar 7/28/2004 22:56'!installIn: receiver	"Install this trigger for the given receiver"	^self subclassResponsibility! !!CMethodTrigger methodsFor: 'starting' stamp: 'ar 7/28/2004 22:56'!startUpIn: receiver	"Install and start this trigger for the given receiver"	^self installIn: receiver! !!CMethodTrigger methodsFor: 'comparing' stamp: 'ar 4/27/2004 20:43'!= aTrigger	"Compare method triggers"	self class == aTrigger class ifFalse:[^false].	^selector == aTrigger selector! !!CMethodTrigger methodsFor: 'comparing' stamp: 'ar 4/27/2004 20:42'!hash	"hash is implemented because = is implemented"	^selector identityHash! !!CEventTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 20:40'!changeEvent	^changeEvent! !!CEventTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 20:40'!eventName	^eventName! !!CEventTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 20:46'!eventName: aString	eventName := aString asSymbol.! !!CEventTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 20:40'!fieldName	^fieldName! !!CEventTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 20:50'!fieldName: aString	fieldName := aString asSymbol.	changeEvent := (fieldName, 'Changed') asSymbol.! !!CEventTrigger methodsFor: 'starting' stamp: 'ar 7/28/2004 22:55'!installIn: receiver	"Install the trigger in the given receiver"	| eventSource script |	eventSource := fieldName ifNil:[receiver] ifNotNil:[receiver get: fieldName].	script := receiver startScript: selector when: {eventSource. eventName}.	changeEvent ifNotNil:[		script startScript: #onUpdateTrigger:from: 				when: {receiver. changeEvent}.	].	script myTrigger: self.	^script! !!CEventTrigger methodsFor: 'comparing' stamp: 'ar 4/27/2004 21:08'!= aTrigger	^(super = aTrigger) 		and:[eventName == aTrigger eventName		and:[fieldName == aTrigger fieldName]]! !!CEventTrigger methodsFor: 'comparing' stamp: 'ar 4/27/2004 21:09'!hash	^super hash bitXor: eventName identityHash! !!CEventTrigger methodsFor: 'printing' stamp: 'ar 4/27/2004 21:21'!printOn: aStream	aStream nextPutAll: self class name.	aStream nextPut: $(.	aStream nextPutAll: 'on: '.	aStream nextPutAll: eventName.	fieldName ifNotNil:[		aStream nextPutAll: ' in: '.		aStream nextPutAll: fieldName.	].	aStream nextPutAll: ' -> '.	aStream print: selector.	aStream nextPut: $).! !!CNamespace class methodsFor: 'accessing' stamp: 'ar 3/27/2004 04:46'!fullName	"Answer the fully qualified path for this namespace"	| superName |	self == CNamespace ifTrue:[^''].	superName := superclass fullName.	superName isEmpty ifTrue:[^name].	^superName,'::', name! !!CNamespace class methodsFor: 'accessing' stamp: 'ar 3/27/2004 04:47'!fullNameFor: localName	"Answer the fully qualified name for the given local name"	^(self fullName,'::', localName)! !!CNamespace class methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:26'!obsolete	self classesDo:[:aClass| aClass removeFromSystem: false].	^super obsolete.! !!CNamespace class methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:26'!organization	^organization ifNil:[organization := SystemOrganizer defaultList: self names keys asArray].! !!CNamespace class methodsFor: 'accessing' stamp: 'ar 3/27/2004 04:22'!uniqueInstance	"Answer the unique instance of this name space"	^uniqueInstance ifNil:[uniqueInstance := self new]! !!CNamespace class methodsFor: 'browsing' stamp: 'ar 3/27/2004 01:27'!browse	| browser |	browser := NSTweakBrowser new.	browser environment: self.	Browser		openBrowserView: (browser openEditString: nil)		label: self name.	^browser! !!CNamespace class methodsFor: 'changes' stamp: 'ar 3/27/2004 01:27'!logChange: change	^Smalltalk logChange: change! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 14:13'!at: aString	^self names at: aString asSymbol! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 14:13'!at: aString ifAbsent: aBlock	^self names at: aString asSymbol ifAbsent: aBlock! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 14:13'!at: aString ifPresent: aBlock	^self names at: aString asSymbol ifPresent: aBlock! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 14:13'!at: aString put: aValue	^self names at: aString asSymbol put: aValue! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 01:58'!bindingOf: varName	| aSymbol binding |	aSymbol := varName asSymbol.	binding := self names bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Pass to parent namespace"	self == CNamespace		ifFalse:[^superclass bindingOf: aSymbol].	"For the root, we only resolve Squeak to alias Smalltalk for the time being"	aSymbol == #Squeak ifTrue:[^Smalltalk associationAt: #Smalltalk].	^nil! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 01:27'!bindingsDo: aBlock	^self names bindingsDo: aBlock! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 01:28'!classBindingOf: varName	"For initialization messages grant the regular scope"	^super bindingOf: varName! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 01:28'!classesDo: aBlock	self bindingsDo:[:assoc| assoc value isBehavior ifTrue:[aBlock value: assoc value]].! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 14:13'!includesKey: aName	"does this pool include aName"	^(self bindingOf: aName asSymbol) notNil! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 01:28'!keyAtIdentityValue: obj ifAbsent: aBlock	^self names keyAtIdentityValue: obj ifAbsent: aBlock! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 01:28'!names	^names ifNil:[names := IdentityDictionary new].! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 06:04'!removeClassFromSystem: aClass logged: aBool	"Delete the class, aClass, from the system, but log the removal neither to the current change set nor to the changes log"	aBool ifTrue:[		aClass wantsChangeSetLogging ifTrue:			[ChangeSet current noteRemovalOf: aClass].		aClass acceptsLoggingOfCompilation ifTrue:			[Smalltalk logChange:  self name, ' removeClassNamed: #', aClass localName].	].	self organization removeElement: aClass localName.	self names removeKey: aClass localName ifAbsent: [].	Smalltalk removeClassFromSystem: aClass logged: false.! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 01:28'!scopeFor: varName from: lower envtAndPathIfFound: envtAndPathBlock	| binding path cls list |	binding := self names bindingOf: varName.	binding ifNil:[^nil].	path := String streamContents:[:s|		cls := self.		list := #().		[cls == CNamespace] whileFalse:[			list := list copyWith: cls name.			cls := cls superclass].		list reversed do:[:scope|  s nextPutAll: scope; nextPutAll: '::'].	].					^envtAndPathBlock		value: self		value: path.! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 13:58'!template: aSystemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class."	^self templateForSubclassOf: 'Squeak::Object' category: aSystemCategoryName! !!CNamespace class methodsFor: 'lookup' stamp: 'ar 3/27/2004 13:58'!templateForSubclassOf: priorClassName category: systemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"	^priorClassName asString, ' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString,''''! !!CNamespace class methodsFor: 'compiling' stamp: 'ar 3/27/2004 04:16'!defaultCompilerClass	"Answer the default compiler class for this name space"	^Compiler! !!CNamespace class methodsFor: 'compiling' stamp: 'ar 3/27/2004 04:23'!evaluate: aString notifying: aController logged: logFlag	^self 		defaultCompilerClass		evaluate: aString 		notifying: aController 		logged: logFlag		in: self! !!CNamespace class methodsFor: 'hacks' stamp: 'ar 3/27/2004 06:02'!defineClass: aClass	"Define the given class in this environment. This is a hack 	allowing Smalltalk to see classes defined in name spaces."	| stName stBinding myName myBinding newName newBinding cat oldEnv |	stName := aClass name.	stBinding := Smalltalk bindingOf: stName.	"Figure out the local name"	myName := (stName findTokens:':') last.	myBinding := self bindingOf: myName.	(myBinding == nil or:[myBinding value == aClass]) ifFalse:[		"Something screwed up"		self notify: 'WARNING: ', myName, ' already exists.Proceed will overwrite it.'.	].	newName := (self fullNameFor: myName) asSymbol.	newBinding := Smalltalk bindingOf: newName.	(newBinding == nil or:[newBinding value == aClass]) ifFalse:[		"Something screwed up"		self notify: 'WARNING: Smalltalk::',newName, ' already exists.Proceed will overwrite it.'.	].	"Finally, really do it"	cat := aClass category.	oldEnv := aClass environment.	aClass environment: self.	self at: myName put: aClass.	oldEnv organization removeElement: stName.	self organization classify: myName under: cat.	aClass setName: newName.	stBinding ifNil:[		Smalltalk at: newName put: aClass.	] ifNotNil:[		Smalltalk removeKey: stBinding key.		stBinding key: newName.		Smalltalk add: stBinding.	].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/11/2004 19:41'!allFieldNames	^Array streamContents:[:s| self allFieldNamesDo:[:f| s nextPut: f]].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/11/2004 19:42'!allFieldNamesDo: aBlock	| theClass |	theClass := self.	[theClass == Object] whileFalse:[		theClass classFields do:[:f| aBlock value: f name].		theClass := theClass superclass.	].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/11/2004 19:43'!allFields	^Array streamContents:[:s| self allFieldsDo:[:f| s nextPut: f]].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/11/2004 19:42'!allFieldsDo: aBlock	| theClass |	theClass := self.	[theClass == Object] whileFalse:[		theClass classFields do: aBlock.		theClass := theClass superclass.	].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/11/2004 19:39'!allVariableNames	"Answer all variable names for the receiver"	^Array streamContents:[:s|		s nextPutAll: self allInstVarNames.		s nextPutAll: self allFieldNames.	].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/27/2004 01:56'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"Next look in declared environment."	binding := self environment bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil ifTrue: [^ nil].	superclass environment == self environment		ifFalse:[^nil]. "don't leave environment"	^superclass bindingOf: aSymbol! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 5/5/2004 23:22'!browserDefinition: style	"Answer a definition of the receiver shown in the browser with the given style"	"Default"	^self tweakDefinition! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/11/2004 19:10'!classFields	"At some point we need to pull the switch here. We should only use the 'classFields' and have the iVars identify itself as instance variables."	^classFields ifNil:[#()]! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 5/6/2004 02:10'!defineFields: aString	"Give us a new set of field names"	| newFields oldFields field myVars root list |	(aString beginsWith: '<?xml') ifTrue:[		"XML field definition"		root := (XMLDOMParser parseDocumentFrom: aString readStream) elements first.		root name == #fields ifFalse:[^self error:'Not a field definition'].		classFields := root elements asArray collect:[:node|			(CFieldDefinition new) importXmlFrom: node; yourself		].		self myInstanceVariables: (classFields 			select:[:each| each isInstanceVariable]			thenCollect:[:each| each name]) asArray.		^self changed].	newFields := (Scanner new scanFieldNames: aString) collect: [:x | x asSymbol].	oldFields := Dictionary new.	self classFields do:[:f| oldFields at: f name put: f].	classFields := newFields collect:[:fieldName|		field := oldFields removeKey: fieldName ifAbsent:[nil].		field ifNil:["Make us a new one"			field := CFieldDefinition new.			field name: fieldName.			field beRegularField.			self compilePropertyAccessorFor: field name.		].		field.	].	oldFields := oldFields asArray.	oldFields isEmpty ifTrue:[^nil].	"Remove remaining fields"	myVars := self myInstanceVariables.	oldFields do:[:each|		each isInstanceVariable 			ifTrue:[myVars := myVars copyWithout: each name].		each toGet ifNotNil:[self removeSelector: each toGet].		each toSet ifNotNil:[self removeSelector: each toSet].	].	self myInstanceVariables: myVars.	self fieldsChanged.	"Figure out obsolete references"	list := SortedCollection new.	self allSelect:[:meth| oldFields anySatisfy:[:f| meth refersToField: f]] into: list.	list size > 0 ifTrue:[		SystemNavigation new browseMessageList: list name: 'Obsolete References'	].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 5/6/2004 00:02'!fieldsChanged	ChangeSet current changeClass: self from: self.	self signal: #fieldsChanged.! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 10/4/2004 20:40'!instanceVariablesString	"Fake it."	| writer |	self == CProtoObject ifTrue:[^super instanceVariablesString].	^String streamContents:[:s| 		writer := XMLWriter on: s.		writer xmlDeclaration: '1.0'.		writer startTag: 'fields'; endTag.		self classFields do:[:f| f storeXmlOn: writer].		writer endTag: 'fields'.	].! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/27/2004 01:39'!printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble _ self printString , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ self methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		sourceFile position: oldPos.		preamble size > 0 ifTrue:    "Copy the preamble"			[outStream copyPreamble: preamble from: sourceFile].		"Copy the method chunk"		newPos _ outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos _ outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 3/11/2004 19:13'!scopeHas: varName ifTrue: aBlock	(self bindingOf: varName) ifNotNilDo:[:assoc| aBlock value: assoc. ^true].	^false! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 5/5/2004 23:17'!squeakInstanceVariablesString	^super instanceVariablesString! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 7/30/2004 08:30'!subclass: newName instanceVariableNames: iVars classVariableNames: cVars poolDictionaries: pools category: cat	| aClass ivList |	aClass := Smalltalk at: newName ifAbsent:[nil].	aClass ifNil:[		"Define w/o instVars"		aClass := super subclass: newName 			instanceVariableNames: '' 			classVariableNames: cVars 			poolDictionaries: pools 			category: cat.	] ifNotNil:[		"Define w/ existing instVars"		ivList := (aClass inheritsFrom: CProtoObject)			ifTrue:[aClass squeakInstanceVariablesString]			ifFalse:[''].		aClass := super subclass: newName 			instanceVariableNames: ivList			classVariableNames: cVars 			poolDictionaries: pools 			category: cat.	].	"Define for real"	aClass ifNotNil:[aClass defineFields: iVars].	^aClass! !!CProtoObject class methodsFor: 'class definition' stamp: 'ar 5/6/2004 00:39'!tweakDefinition	"Answer a definition of the receiver."	| aStream path |	aStream _ CTextStream on: (Text new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [path _ ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: '''.		self classFields do:[:f| 			aStream withAttribute: (CFieldDefinitionTextAttribute forField: f in: self)				do:[aStream nextPutAll: (f name ifNil:['???'])].		] separatedBy:[aStream space].	aStream nextPut:$'.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!CProtoObject class methodsFor: 'method triggers' stamp: 'ar 4/27/2004 21:06'!allMethodTriggersDo: aBlock	| theClass triggers trigger |	theClass := self.	[theClass == Object] whileFalse:[		triggers := theClass methodTriggers.		1 to: triggers size do:[:i|			trigger := triggers at: i.			aBlock value: trigger.		].		theClass := theClass superclass].! !!CProtoObject class methodsFor: 'method triggers' stamp: 'ar 4/27/2004 21:02'!methodTriggerAt: selector	"Answer the method trigger for the given selector, if any"	| method |	method := self compiledMethodAt: selector ifAbsent:[^nil].	^self methodTriggerFor: method selector: selector! !!CProtoObject class methodsFor: 'method triggers' stamp: 'ar 4/27/2004 21:05'!methodTriggerFor: method selector: methodSelector	"Answer the method trigger for the given selector, if any"	| props value |	props := method properties ifNil:[^nil].	value := props at: #on ifAbsent:[nil].	value ifNotNil:[		^(CEventTrigger new)			selector: methodSelector;			eventName: value;			yourself].	value := props at: #ticking ifAbsent:[nil].	value ifNotNil:[		^(CTickingTrigger new)			selector: methodSelector;			frequency: value;			yourself].	value := props at: #on:in: ifAbsent:[nil].	value ifNotNil:[		^(CEventTrigger new)			selector: methodSelector;			eventName: value first;			fieldName: value last;			yourself].	^nil! !!CProtoObject class methodsFor: 'method triggers' stamp: 'ar 3/11/2004 19:16'!methodTriggers	^methodTriggers ifNil:[^#()]! !!CProtoObject class methodsFor: 'method triggers' stamp: 'ar 4/27/2004 21:18'!zapMethodTriggers	"Zap the existing method triggers - DON'T DO THIS!!!!!!"	methodTriggers := nil.! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 5/6/2004 03:16'!addSelector: selector withMethod: newMethod	| oldMethod |	oldMethod := self compiledMethodAt: selector ifAbsent:[nil].	super addSelector: selector withMethod: newMethod.	self updatePropertiesFor: selector from: oldMethod to: newMethod.! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/25/2004 17:09'!changeEventFor: aMethod	"If present, answer the value of the <bewareOf:> annotation in the method specifying which event to listen to for changes of the method."	| props |	props := aMethod properties ifNil:[^nil].	^props at: #bewareOf ifAbsent:[nil].! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 5/6/2004 03:17'!compileIVarAccessorFor: fieldName	| code cat |	cat := (self organization categoryOfElement: fieldName) ifNil:['accessing'].	code := String streamContents:[:s|		s nextPutAll: fieldName.		s crtab; nextPutAll: '"Answer the ', fieldName, ' of the receiver"'.		s crtab; nextPutAll: '^', fieldName.	].	self compile: code classified: cat.	code := String streamContents:[:s|		s nextPutAll: fieldName; nextPutAll: ': aValue'.		s crtab; nextPutAll: '"Modify the receiver''s ', fieldName, '"'.		s crtab; nextPutAll: fieldName.		s nextPutAll: ' := aValue'.	].	self compile: code classified: cat! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 5/6/2004 03:17'!compilePropertyAccessorFor: fieldName	| code eventName cat |	cat := (self organization categoryOfElement: fieldName) ifNil:['accessing'].	eventName := fieldName,'Changed'.	code := String streamContents:[:s|		s nextPutAll: fieldName.		s crtab; nextPutAll: '"Answer the ', fieldName, ' of the receiver"'.		s crtab; nextPutAll: '<bewareOf: #', eventName,'>'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldName.	].	self compile: code classified: cat.	code := String streamContents:[:s|		s nextPutAll: fieldName; nextPutAll: ': aValue'.		s crtab; nextPutAll: '"Modify the receiver''s ', fieldName, '"'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldName.		s nextPutAll: ' put: aValue'.		s nextPutAll: ' with: #', eventName.	].	self compile: code classified: cat.! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 5/5/2004 21:41'!compileVirtualAccessorFor: fieldName	| code cat |	cat := (self organization categoryOfElement: fieldName) ifNil:['accessing'].	code := String streamContents:[:s|		s nextPutAll: fieldName.		s crtab; nextPutAll: '"Answer the ', fieldName, ' of the receiver"'.		s crtab; nextPutAll: '^self mustBeImplemented: #', fieldName.	].	self compile: code classified: cat.	code := String streamContents:[:s|		s nextPutAll: fieldName; nextPutAll: ': aValue'.		s crtab; nextPutAll: '"Modify the receiver''s ', fieldName, '"'.		s crtab; nextPutAll: '^self mustBeImplemented: #', fieldName,':'.	].	self compile: code classified: cat.! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/11/2004 19:17'!deserialize: fieldName using: aSelectorOrNil	"Associate aSelectorOrNil as the serializer for the given field"	self classFields do:[:aField|		aField name = fieldName ifTrue:[			aField deserializer: aSelectorOrNil.		].	].	"We should probably raise an exception here if the field isn't even present..."! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/26/2004 22:30'!fieldVariableNodes	"Answer the variable nodes for our fields"	^self allFields collect:[:each| CFieldNode new fieldDefinition: each].! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/25/2004 17:17'!fixChangeEvents	"CProtoObject fixChangeEvents"	| evt theField |	self withAllSubclassesDo:[:each|		each selectorsAndMethodsDo:[:sel :meth|			evt := self changeEventFor: meth.			evt ifNotNil:[				theField := each classFields detect:[:any| any name = sel] ifNone:[nil].				theField ifNotNil:[theField changeEvent: evt]]]].! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 5/5/2004 21:37'!myInstanceVariables	^instanceVariables ifNil:[#()]! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 5/5/2004 22:43'!myInstanceVariables: anArray	self instVarNames = anArray ifTrue:[^self].	(ClassBuilder new)		superclass: superclass		subclass: name		instanceVariableNames: anArray		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 4/27/2004 21:16'!recreateMethodProperties	"Recreate all the method properties of the receiver the hard way"	self selectorsAndMethodsDo:[:selector :method|		self updatePropertiesFor: selector from: method to: nil.		self updatePropertiesFor: selector from: nil to: method.	].! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/11/2004 19:17'!removeSelector: selector	| oldMethod |	oldMethod := self compiledMethodAt: selector ifAbsent:[^nil].	super removeSelector: selector.	self updatePropertiesFor: selector from: oldMethod to: nil.! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/11/2004 19:16'!serialize: fieldName using: aSelectorOrNil	"Associate aSelectorOrNil as the serializer for the given field"	self classFields do:[:aField|		aField name = fieldName ifTrue:[			aField serializer: aSelectorOrNil.		].	].	"We should probably raise an exception here if the field isn't even present..."! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 4/27/2004 21:11'!startAllScripts: selector triggeredBy: aTrigger	"Horribly slow ..."	self allSubInstancesDo:[:inst| aTrigger startUpIn: inst].! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/11/2004 19:16'!stopAllScripts: selector triggeredBy: aTrigger	"Horribly slow ..."	self allSubInstancesDo:[:inst|		inst myScripts do:[:each|			(each selector == selector and:[each myTrigger = aTrigger]) ifTrue:[				inst stopScript: each.			].		].	].! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 5/6/2004 01:20'!updatePropertiesFor: selector from: oldMethod to: newMethod	| props value fieldName oldTrigger oldEvent newTrigger newEvent theField |	oldMethod ifNotNil:[		oldTrigger := self methodTriggerFor: oldMethod selector: selector.		oldEvent := self changeEventFor: oldMethod.		"See if the selector defined a getter for one of our fields"		(newMethod == nil and:[oldMethod numArgs = 0]) ifTrue:[			self classFields do:[:each|  each toGet == selector ifTrue:[each toGet: nil]].			"And we really *should* signal the user's attention towards use of that setter"		].		"See if the selector defined a setter for one of our fields"		(newMethod == nil and:[selector last = $: and:[oldMethod numArgs = 1]]) ifTrue:[			self classFields do:[:each|  each toSet == selector ifTrue:[each toSet: nil]].			"And we really *should* signal the user's attention towards use of that setter"		].		"See if the old method defined a serializer/deserializer"		props := oldMethod properties.		props ifNotNil:[			value := props at: #serialize ifAbsent:[nil].			value ifNotNil:[self serialize: value using: nil].			value := props at: #deserialize ifAbsent:[nil].			value ifNotNil:[self deserialize: value using: nil].		].	].	newMethod ifNotNil:[		newTrigger := self methodTriggerFor: newMethod selector: selector.		newEvent := self changeEventFor: newMethod.		"See if the new method defines a setter for one of our fields"		(oldMethod  == nil and:[selector last = $: and:[newMethod numArgs = 1]]) ifTrue:[			fieldName := selector allButLast.			self classFields do:[:each| each name = fieldName ifTrue:[each toSet: selector]].		].		"See if the new method defines a serializer/deserializer"		props := newMethod properties.		props ifNotNil:[			value := props at: #serialize ifAbsent:[nil].			value ifNotNil:[self serialize: value using: selector].			value := props at: #deserialize ifAbsent:[nil].			value ifNotNil:[self deserialize: value using: selector].		].	].	oldTrigger = newTrigger ifFalse:[		oldTrigger ifNotNil:[			self stopAllScripts: selector triggeredBy: oldTrigger.			methodTriggers := self methodTriggers copyWithout: oldTrigger.		].		newTrigger ifNotNil:[			self startAllScripts: selector triggeredBy: newTrigger.			methodTriggers := self methodTriggers copyWith: newTrigger.		].	].	oldEvent = newEvent ifFalse:[		theField := self classFields detect:[:any| any name = selector] ifNone:[nil].		theField ifNotNil:[theField changeEvent: newEvent].	].! !!CProtoObject class methodsFor: 'compiling' stamp: 'ar 3/12/2004 00:05'!variableNodes	^self fieldVariableNodes, super variableNodes! !!CProtoObject class methodsFor: 'uniclasses' stamp: 'ar 3/11/2004 19:21'!baseClass	"Answer the base (non-uni) class of the receiver"	self isUniClass ifTrue:[^superclass] ifFalse:[^self].! !!CProtoObject class methodsFor: 'uniclasses' stamp: 'ar 3/11/2004 19:22'!beUniClassFrom: aClass	"Prepare the receiver to be a uniclass based on aClass' definition."	| org |	"--- copy the organization manually - something is wrong with #copy here---"	org := organization.	organization := nil.	self selectors do:[:sel|		self organization classify: sel under: (org categoryOfElement: sel).	].	"--- this should be ClassOrganizer>>copy ---"	name := '*', aClass baseClass name asString.	aClass == aClass baseClass ifFalse:[		"Don't copy this if we're subclassing for real"		classFields := aClass classFields.		methodTriggers := aClass methodTriggers.	].	^self! !!CProtoObject class methodsFor: 'uniclasses' stamp: 'ar 3/11/2004 19:19'!instVarNamesFrom: baseClass	| aClass ivNames |	ivNames := #().	aClass := self.	[aClass == baseClass] whileFalse:[		ivNames := aClass instVarNames, ivNames.		aClass := aClass superclass].	^ivNames! !!CProtoObject class methodsFor: 'uniclasses' stamp: 'ar 3/11/2004 19:19'!isSystemDefined	^Smalltalk includesKey: name! !!CProtoObject class methodsFor: 'uniclasses' stamp: 'ar 3/11/2004 19:19'!isUniClass	^name first = $*! !!CProtoObject class methodsFor: 'uniclasses' stamp: 'ar 3/27/2004 14:52'!newUniClass	"Make a new uni class just like me"	| baseClass newClass |	"Get the base (non-uni) class"	baseClass := self baseClass.	"Create a new anonymous subclass"	newClass := ClassBuilder new		newSubclassOf: baseClass		type: baseClass typeOfClass		instanceVariables: (self instVarNamesFrom: baseClass)		from: (self == baseClass ifFalse:[self]).	baseClass addUniClass: newClass.	baseClass removeSubclass: newClass.	newClass beUniClassFrom: self.	^newClass! !!CProtoObject class methodsFor: 'compiler' stamp: 'ar 3/26/2004 16:42'!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^self == CProtoObject ifTrue:[Compiler] ifFalse:[CCompiler]! !!CProtoObject class methodsFor: 'compiler' stamp: 'ar 5/6/2004 03:03'!decompilerClass	"Answer a decompiler class appropriate for compiled methods of this class."	^CDecompiler! !!CProtoObject class methodsFor: 'compiler' stamp: 'ar 3/26/2004 21:29'!evaluatorClass	"Answer an evaluator class appropriate for evaluating expressions in the  context of this class."	^self == CProtoObject ifTrue:[Compiler] ifFalse:[CCompiler]! !!CProtoObject class methodsFor: 'compiler' stamp: 'ar 3/26/2004 16:42'!parserClass	"Answer a compiler class appropriate for source methods of this class."	^self == CProtoObject ifTrue:[Parser] ifFalse:[CParser]! !!CProtoObject class methodsFor: 'compiler' stamp: 'ar 3/27/2004 02:07'!subclassDefinerClass	"Answer an evaluator class appropriate for evaluating definitions of new 	subclasses of this class."	^CCompiler! !!CProtoObject class methodsFor: 'printing' stamp: 'bf 7/22/2004 13:32'!nameForDisplay	| n | 	n _ super nameForDisplay.	^ n first = $C		ifTrue: [n allButFirst]		ifFalse: [n]! !!CProtoObject class methodsFor: 'printing' stamp: 'ar 3/27/2004 01:36'!printOn: aStream 	self environment scopeFor: self name from: nil envtAndPathIfFound:[:env :path|		aStream nextPutAll: path.	].	aStream nextPutAll: self name.! !!CProtoObject class methodsFor: 'class hierarchy' stamp: 'ar 3/27/2004 01:52'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	| subs |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subs _ SortedCollection sortBlock:[:c1 :c2| c1 name <= c2 name].	self subclassesDo: [:aClass | subs add: aClass].	subs do:[:aClass|		aClass allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!CProtoObject class methodsFor: 'accessing' stamp: 'ar 3/27/2004 05:37'!category	"Answer the system organization category for the receiver."	^category ifNil:[self environment organization categoryOfElement: self localName]! !!CProtoObject class methodsFor: 'source code' stamp: 'ar 5/6/2004 02:41'!sourceCodeAt: selector	^self sourceCodeAt: selector ifAbsent:[self methodDict errorNotFound: selector]! !!CProtoObject class methodsFor: 'source code' stamp: 'ar 5/6/2004 03:16'!sourceCodeAt: selector ifAbsent: aBlock	| method |	method := self methodDict at: selector ifAbsent: [^ aBlock value].	^method getSourceFor: selector in: self! !!CProtoObject class methodsFor: 'source code' stamp: 'ar 5/6/2004 02:48'!sourceCodeAt: selector toGet: field	^String streamContents:[:s|		s nextPutAll: selector.		s crtab; nextPutAll: '"Answer the receiver''s ', field name, '"'.		field isGeneratingEvents ifTrue:[			s crtab; nextPutAll: '<bewareOf: #', field changeEvent,'>'.		].		s crtab nextPutAll: '^', field name.	].! !!CProtoObject class methodsFor: 'source code' stamp: 'ar 5/6/2004 02:47'!sourceCodeAt: selector toSet: field	| type typeName |	type := (field type ifNil:[Object]).	typeName := (type name first isVowel ifTrue: ['an'] ifFalse: ['a']), type name.	^String streamContents:[:s|		s nextPutAll: selector.		s space; nextPutAll: typeName.		s crtab; nextPutAll: '"Modify the receiver''s ', field name, '"'.		s crtab nextPutAll: field name, ' := ', typeName	].! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 00:36'!addField: fieldOrName	| field |	fieldOrName isString ifTrue:[		field := CFieldDefinition new.		field name: fieldOrName asSymbol.		field beRegularField.	] ifFalse:[field := fieldOrName].	(self classFields anySatisfy:[:any| any name = field name]) 		ifTrue:[^self error: 'Field already defined'].	classFields := self classFields copyWith: field.	field isInstanceVariable ifTrue:[		self myInstanceVariables: (self myInstanceVariables copyWith: field name).	].	field isInstanceVariable ifTrue:[self compileIVarAccessorFor: field name].	field isVirtualField ifTrue:[self compileVirtualAccessorFor: field name].	field isRegularField ifTrue:[self compilePropertyAccessorFor: field name].	self fieldsChanged! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 02:26'!allReferencesTo: fieldOrName	| list field |	fieldOrName isString 		ifTrue:[field := self fieldNamed: fieldOrName] 		ifFalse:[field := fieldOrName].	field ifNil:[^#()].	list := SortedCollection new.	self withAllSubclassesDo:[:cls|		cls allSelect:[:meth| meth refersToField: field] into: list.	].	^list! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 02:07'!allSelect: aBlock into: list	self selectorsAndMethodsDo:[:sel :meth|		(aBlock value: meth) ifTrue:[			list add: (MethodReference new setStandardClass: self methodSymbol: sel).		].	].! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 02:24'!asField: fieldOrName	fieldOrName isString 		ifTrue:[^self fieldNamed: fieldOrName] 		ifFalse:[^fieldOrName].! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 02:25'!browseAllReferencesTo: fieldOrName	"CPlayer browseAllReferencesTo: #costume"	^SystemNavigation new		browseMessageList: (self allReferencesTo: fieldOrName)		name: fieldOrName name,' references'		autoSelect: (self asField: fieldOrName) name.! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 15:34'!defineField: fieldDef colorName: cc	cc = #none 		ifTrue:[fieldDef color: nil]		ifFalse:[fieldDef color: (Color perform: cc)].	self fieldsChanged.! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 00:31'!defineIVarField: fieldDef	"Make fieldDef be an instance variable"	fieldDef isInstanceVariable ifTrue:[^self].	fieldDef beInstanceVariable.	self myInstanceVariables: (self myInstanceVariables copyWith: fieldDef name).	"Compile iVar accessors"	self compileIVarAccessorFor: fieldDef name.	self fieldsChanged.! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 00:01'!defineRegularField: fieldDef	"Make fieldDef be a regular field"	| iVar |	fieldDef isRegularField ifTrue:[^self].	"First compile property accessor"	self compilePropertyAccessorFor: fieldDef name.	iVar := fieldDef isInstanceVariable.	fieldDef beRegularField.	iVar ifTrue:[		self myInstanceVariables: (self myInstanceVariables copyWithout: fieldDef name)	].	self fieldsChanged.! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 00:01'!defineVirtualField: fieldDef	| iVar |	fieldDef isVirtualField ifTrue:[^self].	"First compile virtual accessor"	self compileVirtualAccessorFor: fieldDef name.	iVar := fieldDef isInstanceVariable.	fieldDef beVirtualField.	iVar ifTrue:[		self myInstanceVariables: (self myInstanceVariables copyWithout: fieldDef name).	].	self fieldsChanged.! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 15:47'!fieldMenuFor: fieldDef	"Answer an interactive menu for the given field definition"	| menu item colorMenu theColor |	Processor activeProcess isScriptingProcess ifFalse:[^self morphicFieldMenuFor: fieldDef].	menu := CMenu new.	menu label: fieldDef name.	item := menu add: 'Regular Field' target: self 				action: #defineRegularField: argument: fieldDef.	item checked: fieldDef isRegularField.	item := menu add: 'Virtual Field' target: self 				action: #defineVirtualField: argument: fieldDef.	item checked: fieldDef isVirtualField.	item := menu add: 'Instance Variable' target: self 				action: #defineIVarField: argument: fieldDef.	item checked: fieldDef isInstanceVariable.	menu addSeparator.	item := menu add: 'Serializable' target: self 				action: #flipSerializable: argument: fieldDef.	item checked: fieldDef isSerializable.	fieldDef isVirtualField ifTrue:[item disabled: true].	menu addSeparator.	colorMenu := CMenu new.	colorMenu label: 'Color'.	#(none red green blue yellow magenta cyan) do:[:cc|		theColor := cc == #none ifTrue:[nil] ifFalse:[Color perform: cc].		item := colorMenu add: cc target: self action: #defineField:colorName: arguments: {fieldDef. cc}.		item checked: fieldDef color = theColor.	].	menu add: 'Field Color' subMenu: colorMenu.	^menu! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/5/2004 21:15'!flipPrivate: fieldDef	^self inform: 'Not implemented'! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 00:01'!flipSerializable: fieldDef	fieldDef serializable: fieldDef serializable not.	self fieldsChanged.! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/5/2004 21:15'!flipTyped: fieldDef	^self inform: 'Not implemented'! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 15:35'!morphicFieldMenuFor: fieldDef	"Answer an interactive menu for the given field definition"	| menu str theColor colorMenu |	menu := MenuMorph new.	menu title: fieldDef name.	str := (fieldDef isRegularField ifTrue:['<on>'] ifFalse:['<off>']), 'Regular Field'.	menu add: str target: self selector: #defineRegularField: argument: fieldDef.	str := (fieldDef isVirtualField ifTrue:['<on>'] ifFalse:['<off>']), 'Virtual Field'.	menu add: str target: self selector: #defineVirtualField: argument: fieldDef.	str := (fieldDef isInstanceVariable ifTrue:['<on>'] ifFalse:['<off>']), 'Instance Variable'.	menu add: str target: self selector: #defineIVarField: argument: fieldDef.	fieldDef isVirtualField ifFalse:[		menu addLine.		str := (fieldDef isSerializable ifTrue:['<on>'] ifFalse:['<off>']), 'Serializable'.		menu add: str target: self selector: #flipSerializable: argument: fieldDef.		menu addLine.	].	colorMenu := MenuMorph new.	#(none red green blue yellow magenta cyan) do:[:cc|		theColor := cc == #none ifTrue:[nil] ifFalse:[Color perform: cc].		str := ((fieldDef color = theColor) ifTrue:['<on>'] ifFalse:['<off>']), cc.		colorMenu add: str target: self selector: #defineField:colorName: argumentList: {fieldDef. cc}.	].	menu add: 'Field Color' subMenu: colorMenu.	^menu! !!CProtoObject class methodsFor: 'user interface' stamp: 'ar 5/6/2004 00:31'!removeField: fieldOrName	| fieldName field |	fieldName := fieldOrName isString ifTrue:[fieldOrName] ifFalse:[fieldOrName name].	field := classFields detect:[:any| any name = fieldName] ifNone:[nil].	field ifNil:[^nil].	field toGet ifNotNil:[self removeSelector: field toGet].	field toSet ifNotNil:[self removeSelector: field toSet].	field isInstanceVariable ifTrue:[		self myInstanceVariables: (self myInstanceVariables copyWithout: fieldName).	].	self fieldsChanged! !!CProtoObject class methodsFor: 'deprecated' stamp: 'ar 5/6/2004 11:20'!fixFields	"Fix the field definition for existing classes"	"CProtoObject allSubclassesDo:[:cls| cls fixFields]"	| undeclared field meth |	undeclared := self myInstanceVariables select:[:x|		self classFields noneSatisfy:[:f| f name = x and:[f isInstanceVariable]].	].	undeclared do:[:each|		field := CFieldDefinition new.		field name: each.		field beInstanceVariable.		(self includesSelector: field toGet) ifFalse:[field toGet: nil].		(self includesSelector: field toSet) ifFalse:[field toSet: nil].		classFields := {field}, self classFields.	].	(self classFields select:[:f| f isRegularField]) do:[:f|		meth := self compiledMethodAt: f toGet ifAbsent:[nil].		(meth == nil 			or:[(meth sends: #propertyValueAt:)			or:[(meth sends: #propertyValueAt:ifAbsent:)]]) ifFalse:[				f isVirtualField: true.		].		meth := self compiledMethodAt: f toSet ifAbsent:[nil].		(meth == nil 			or:[(meth sends: #propertyValueAt:put:with:)			or:[(meth sends: #propertyValueAt:put:)]]) ifFalse:[				f isVirtualField: true.		].	].	self fieldsChanged.! !!CProtoObject class methodsFor: 'deprecated' stamp: 'ar 6/2/2004 16:21'!subclass: newName fieldNames: fields instanceVariableNames: iVars classVariableNames: cVars poolDictionaries: pools category: cat	"Old-style definition - convert to XML before going on"	| ivString ff writer |	ivString := String streamContents:[:out|		writer := XMLWriter on: out.		writer xmlDeclaration: '1.0'.		writer startTag: 'fields'; endTag.		(Scanner new scanFieldNames: iVars) do:[:iv|			ff := CFieldDefinition new.			ff name: iv.			ff beInstanceVariable.			ff storeXmlOn: writer.		].		(Scanner new scanFieldNames: fields) do:[:iv|			ff := CFieldDefinition new.			ff name: iv asSymbol.			ff beRegularField.			ff storeXmlOn: writer.		].		writer endTag: 'fields'.	].	^self subclass: newName instanceVariableNames: ivString classVariableNames: cVars poolDictionaries: pools category: cat! !!CProtoObject class methodsFor: 'monticello' stamp: 'ar 7/31/2004 17:11'!asMCFieldDefinition	^((Smalltalk 		at: #MCTweakFieldsDefinition 		ifAbsent:[self error: 'Need TweakMC fixes']) new)			className: self name;			fields: self instanceVariablesString;	yourself! !!CProtoObject class methodsFor: 'monticello' stamp: 'ar 7/29/2004 19:43'!classDefinitions	^ Array 			with: self asClassDefinition			with: self asMCFieldDefinition! !!CTickingTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 21:04'!frequency	^frequency! !!CTickingTrigger methodsFor: 'accessing' stamp: 'ar 4/27/2004 21:04'!frequency: aNumber	frequency := aNumber! !!CTickingTrigger methodsFor: 'starting' stamp: 'ar 7/28/2004 22:56'!installIn: receiver	"Install the script in the receiver"	| script |	script := receiver makeTicking: selector withArguments: #() at: frequency.	script myTrigger: self.	^script! !!CTickingTrigger methodsFor: 'starting' stamp: 'ar 7/28/2004 22:57'!startUpIn: receiver	"Install and start this trigger for the given receiver"	| script |	script := self installIn: receiver.	script resumeScript.	^script! !!CTickingTrigger methodsFor: 'comparing' stamp: 'ar 4/27/2004 21:09'!= aTrigger	^super = aTrigger and:[frequency = aTrigger frequency]! !!CTickingTrigger methodsFor: 'comparing' stamp: 'ar 4/27/2004 21:09'!hash	^super hash bitXor: frequency hash! !!Tweak class methodsFor: 'compiling' stamp: 'ar 3/27/2004 04:16'!defaultCompilerClass	"Answer the default compiler class for this name space"	^CCompiler! !!Tweak class reorganize!('compiling' defaultCompilerClass)!!Tweak reorganize!('Tweak-Test')!!CTickingTrigger class reorganize!('as yet unclassified')!!CTickingTrigger reorganize!('accessing' frequency frequency:)('starting' installIn: startUpIn:)('comparing' = hash)!!CProtoObject class reorganize!('class definition' allFieldNames allFieldNamesDo: allFields allFieldsDo: allVariableNames bindingOf: browserDefinition: classFields defineFields: fieldsChanged instanceVariablesString printMethodChunk:withPreamble:on:moveSource:toFile: scopeHas:ifTrue: squeakInstanceVariablesString subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: tweakDefinition)('method triggers' allMethodTriggersDo: methodTriggerAt: methodTriggerFor:selector: methodTriggers zapMethodTriggers)('compiling' addSelector:withMethod: changeEventFor: compileIVarAccessorFor: compilePropertyAccessorFor: compileVirtualAccessorFor: deserialize:using: fieldVariableNodes fixChangeEvents myInstanceVariables myInstanceVariables: recreateMethodProperties removeSelector: serialize:using: startAllScripts:triggeredBy: stopAllScripts:triggeredBy: updatePropertiesFor:from:to: variableNodes)('uniclasses' baseClass beUniClassFrom: instVarNamesFrom: isSystemDefined isUniClass newUniClass)('compiler' compilerClass decompilerClass evaluatorClass parserClass subclassDefinerClass)('printing' nameForDisplay printOn:)('class hierarchy' allSubclassesWithLevelDo:startingLevel:)('accessing' category)('source code' sourceCodeAt: sourceCodeAt:ifAbsent: sourceCodeAt:toGet: sourceCodeAt:toSet:)('user interface' addField: allReferencesTo: allSelect:into: asField: browseAllReferencesTo: defineField:colorName: defineIVarField: defineRegularField: defineVirtualField: fieldMenuFor: flipPrivate: flipSerializable: flipTyped: morphicFieldMenuFor: removeField:)('deprecated' fixFields subclass:fieldNames:instanceVariableNames:classVariableNames:poolDictionaries:category:)('monticello' asMCFieldDefinition classDefinitions)!!CProtoObject reorganize!('as yet unclassified')!!CNamespace class reorganize!('accessing' fullName fullNameFor: obsolete organization uniqueInstance)('browsing' browse)('changes' logChange:)('lookup' at: at:ifAbsent: at:ifPresent: at:put: bindingOf: bindingsDo: classBindingOf: classesDo: includesKey: keyAtIdentityValue:ifAbsent: names removeClassFromSystem:logged: scopeFor:from:envtAndPathIfFound: template: templateForSubclassOf:category:)('compiling' defaultCompilerClass evaluate:notifying:logged:)('hacks' defineClass:)!!CNamespace reorganize!('as yet unclassified')!!CEventTrigger class reorganize!('as yet unclassified')!!CMethodTrigger class reorganize!('as yet unclassified')!!CEventTrigger reorganize!('accessing' changeEvent eventName eventName: fieldName fieldName:)('starting' installIn:)('comparing' = hash)('printing' printOn:)!!CMethodTrigger reorganize!('accessing' selector selector:)('starting' installIn: startUpIn:)('comparing' = hash)!!CFileOutMaker class reorganize!('fileOut' fileOutTweak)!!CFileOutMaker reorganize!('as yet unclassified')!!CFieldDefinitionTextAttribute class reorganize!('instance creation' forField:in:)!!CFieldDefinitionTextAttribute reorganize!('accessing' fieldClass fieldClass: fieldDefinition fieldDefinition: menu)('emphasis' emphasizeScanner:)!CFieldDefinition initialize!!CFieldDefinition class reorganize!('instance creation' named: new)('class initialization' initialize)!!CFieldDefinition reorganize!('initialize' beInstanceVariable beRegularField beVirtualField initialize)('accessing' accessKey accessKey: changeEvent changeEvent: color color: deserializer deserializer: isInstanceVariable isInstanceVariable: isPrivateField isPrivateField: isVirtualField isVirtualField: key name name: nonSerializable nonSerializable: serializable serializable: serializer serializer: toGet toGet: toSet toSet: type type: valueType)('testing' isGeneratingEvents isReadOnly isRegularField isSerializable isTyped)('comparing' = hash)('printing' printOn:)('private' assignDefaultSetter flags flags: importXmlFrom: readXmlFrom: storeXmlOn: xmlString)!