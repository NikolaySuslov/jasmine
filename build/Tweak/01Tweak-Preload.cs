'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 4 October 2004 at 10:02:16 pm'!!Color methodsFor: '*Tweak-Preload' stamp: 'ar 10/1/2003 20:16'!asHtmlColorRef	"Convert the receiver into HTML RRGGBB represenation"	"Examples:		Color red asHtmlColorRef.		Color green asHtmlColorRef.		Color blue asHtmlColorRef.		(Color r: 0.25 g: 0.5 b: 0.75) asHtmlColorRef	"	| r g b table |	r := self red * 255 asInteger.	g := self green * 255 asInteger.	b := self blue * 255 asInteger.	table := #('0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A' 'B' 'C' 'D' 'E' 'F').	^(table at: (r // 16)+1), (table at: (r \\ 16)+1),	(table at: (g // 16)+1), (table at: (g \\ 16)+1),	(table at: (b // 16)+1), (table at: (b \\ 16)+1)! !!Color methodsFor: '*Tweak-Preload' stamp: 'ar 12/1/2003 20:53'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'type' value: 'Color'.	xmlWriter attribute: 'red' value: (self red truncateTo: 0.01) printString.	xmlWriter attribute: 'green' value: (self green truncateTo: 0.01) printString.	xmlWriter attribute: 'blue' value: (self blue truncateTo: 0.01) printString.	xmlWriter attribute: 'alpha' value: (self alpha truncateTo: 0.01) printString.	xmlWriter endEmptyTag: aKey.! !!Color methodsFor: '*Tweak-Preload'!isOrientedFill	^false! !!Color methodsFor: '*Tweak-Preload' stamp: 'ar 9/17/2003 17:28'!serializeOn: aSerializer	^aSerializer writeColor: self! !!Color class methodsFor: '*Tweak-Preload' stamp: 'ar 5/6/2004 12:35'!fromHtmlColorRef: aString	aString size = 6 ifFalse:[^self error: 'Not a color ref'].	^self 		r: (aString first digitValue * 16) + (aString second digitValue) / 255.0		g: (aString third digitValue * 16) + (aString fourth digitValue) / 255.0		b: (aString fifth digitValue * 16) + (aString sixth digitValue) / 255.0! !!Color class methodsFor: '*Tweak-Preload' stamp: 'ar 12/8/2002 03:08'!fullColorPaletteForDepth: depth extent: chartExtent	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color fullColorPaletteForDepth: 16 extent: 190@60) display"	| basicHue x y c startHue palette transHt vSteps grayWidth hSteps |	palette _ Form extent: chartExtent depth: depth.	transHt _ -1.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	grayWidth _ 10.	startHue _ 338.0.	vSteps _ palette height - transHt // 2.	hSteps _ palette width - grayWidth.	x _ 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.		y _ transHt+1.		0 to: vSteps do: [:n | 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		1 to: vSteps do: [:n | 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		x _ x + 1].	y _ transHt + 1.	1 to: vSteps * 2 do: [:n | 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y _ y + 1].	^ palette! !!XMLElement methodsFor: '*Tweak-Preload' stamp: 'ar 12/2/2003 21:30'!asLiteral: aString	| ch num |	aString = 'nil' ifTrue:[^nil].	aString = 'true' ifTrue:[^true].	aString = 'false' ifTrue:[^false].	ch := (aString at: 1).	"strings"	ch = $' ifTrue:[^self convertLiteralString: aString].	"symbols"	ch = $# ifTrue:[^self convertLiteralSymbol: aString].	"globals"	(ch isLetter and:[ch isUppercase]) ifTrue:[^Smalltalk at: (aString asSymbol)].	"numbers/points"	(ch = $- or:[ch isDigit]) ifTrue:[		num := self convertLiteralNumeric: aString.		num ifNotNil:[^num].	].	^Object readFrom: aString! !!XMLElement methodsFor: '*Tweak-Preload' stamp: 'ar 12/2/2003 21:31'!convertLiteralNumeric: aString	"Convert aString from a literal number/point - this needs to be ultra-fast"	| stream num ch |	stream := ReadStream on: aString.	num := Number readFrom: stream.	ch := stream peek ifNil:[^num].	ch = $@ ifTrue:[		stream next.		num := num @ (Number readFrom: stream).	].	stream atEnd ifTrue:[^num].	"bail for everything else"	^nil! !!XMLElement methodsFor: '*Tweak-Preload' stamp: 'ar 12/2/2003 21:30'!convertLiteralString: aString	"Convert aString from a literal string - this needs to be ultra-fast"	| out nextIndex lastIndex |	(aString at: 1) = $' ifFalse:[self error: 'string quote expected'].	"do a quick match for a single-quoted string"	nextIndex := aString indexOf: $' startingAt: 2.	nextIndex = aString size ifTrue:[^aString copyFrom: 2 to: aString size-1].	"do it the slow way"	out := WriteStream on: (String new: aString size - 2).	lastIndex := 1.	[nextIndex := aString indexOf: $' startingAt: lastIndex+1.	nextIndex = 0 ifTrue:[self error: 'string quote expected'].	nextIndex < aString size] whileTrue:[		out nextPutAll: (aString copyFrom: lastIndex+1 to: nextIndex-1).		(aString at: nextIndex + 1) = $' ifFalse:[self error: 'string quote expected'].		out nextPut: $'.		lastIndex := nextIndex+1.	].	out nextPutAll: (aString copyFrom: lastIndex+1 to: aString size-1).	^out contents! !!XMLElement methodsFor: '*Tweak-Preload' stamp: 'ar 12/2/2003 21:31'!convertLiteralSymbol: aString	"Convert aString from a literal symbol - this needs to be ultra-fast"	(aString at: 1) = $# ifFalse:[self error: 'hash mark expected'].	(aString at: 2) = $' ifFalse:[^Symbol intern: (aString copyFrom: 2 to: aString size)].	^(self convertLiteralString: (aString copyFrom: 2 to: aString size)) asSymbol! !!XMLElement methodsFor: '*Tweak-Preload' stamp: 'ar 12/2/2003 21:30'!literalAt: key	| attr |	attr := self attributeAt: key ifAbsent:[self errorNotFound: key].	^self asLiteral: attr! !